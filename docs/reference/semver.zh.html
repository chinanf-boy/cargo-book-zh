<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>SemVer Compatibility - Rust Cargo 官书（非官方翻译)</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Cargo ">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.zh.html">Introduction</a></li><li class="chapter-item expanded "><a href="../getting-started/index.zh.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-started/installation.zh.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="../getting-started/first-steps.zh.html"><strong aria-hidden="true">1.2.</strong> First Steps with Cargo</a></li></ol></li><li class="chapter-item expanded "><a href="../guide/index.zh.html"><strong aria-hidden="true">2.</strong> Cargo Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../guide/why-cargo-exists.zh.html"><strong aria-hidden="true">2.1.</strong> Why Cargo Exists</a></li><li class="chapter-item expanded "><a href="../guide/creating-a-new-project.zh.html"><strong aria-hidden="true">2.2.</strong> Creating a New Package</a></li><li class="chapter-item expanded "><a href="../guide/working-on-an-existing-project.zh.html"><strong aria-hidden="true">2.3.</strong> Working on an Existing Package</a></li><li class="chapter-item expanded "><a href="../guide/dependencies.zh.html"><strong aria-hidden="true">2.4.</strong> Dependencies</a></li><li class="chapter-item expanded "><a href="../guide/project-layout.zh.html"><strong aria-hidden="true">2.5.</strong> Package Layout</a></li><li class="chapter-item expanded "><a href="../guide/cargo-toml-vs-cargo-lock.zh.html"><strong aria-hidden="true">2.6.</strong> Cargo.toml vs Cargo.lock</a></li><li class="chapter-item expanded "><a href="../guide/tests.zh.html"><strong aria-hidden="true">2.7.</strong> Tests</a></li><li class="chapter-item expanded "><a href="../guide/continuous-integration.zh.html"><strong aria-hidden="true">2.8.</strong> Continuous Integration</a></li><li class="chapter-item expanded "><a href="../guide/cargo-home.zh.html"><strong aria-hidden="true">2.9.</strong> Cargo Home</a></li><li class="chapter-item expanded "><a href="../guide/build-cache.zh.html"><strong aria-hidden="true">2.10.</strong> Build Cache</a></li></ol></li><li class="chapter-item expanded "><a href="../reference/index.zh.html"><strong aria-hidden="true">3.</strong> Cargo Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/specifying-dependencies.zh.html"><strong aria-hidden="true">3.1.</strong> Specifying Dependencies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/overriding-dependencies.zh.html"><strong aria-hidden="true">3.1.1.</strong> Overriding Dependencies</a></li></ol></li><li class="chapter-item expanded "><a href="../reference/manifest.zh.html"><strong aria-hidden="true">3.2.</strong> The Manifest Format</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/cargo-targets.zh.html"><strong aria-hidden="true">3.2.1.</strong> Cargo Targets</a></li></ol></li><li class="chapter-item expanded "><a href="../reference/workspaces.zh.html"><strong aria-hidden="true">3.3.</strong> Workspaces</a></li><li class="chapter-item expanded "><a href="../reference/features.zh.html"><strong aria-hidden="true">3.4.</strong> Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/features-examples.zh.html"><strong aria-hidden="true">3.4.1.</strong> Features Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../reference/profiles.zh.html"><strong aria-hidden="true">3.5.</strong> Profiles</a></li><li class="chapter-item expanded "><a href="../reference/config.zh.html"><strong aria-hidden="true">3.6.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="../reference/environment-variables.zh.html"><strong aria-hidden="true">3.7.</strong> Environment Variables</a></li><li class="chapter-item expanded "><a href="../reference/build-scripts.zh.html"><strong aria-hidden="true">3.8.</strong> Build Scripts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/build-script-examples.zh.html"><strong aria-hidden="true">3.8.1.</strong> Build Script Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../reference/publishing.zh.html"><strong aria-hidden="true">3.9.</strong> Publishing on crates.io</a></li><li class="chapter-item expanded "><a href="../reference/pkgid-spec.zh.html"><strong aria-hidden="true">3.10.</strong> Package ID Specifications</a></li><li class="chapter-item expanded "><a href="../reference/source-replacement.zh.html"><strong aria-hidden="true">3.11.</strong> Source Replacement</a></li><li class="chapter-item expanded "><a href="../reference/external-tools.zh.html"><strong aria-hidden="true">3.12.</strong> External Tools</a></li><li class="chapter-item expanded "><a href="../reference/registries.zh.html"><strong aria-hidden="true">3.13.</strong> Registries</a></li><li class="chapter-item expanded "><a href="../reference/resolver.zh.html"><strong aria-hidden="true">3.14.</strong> Dependency Resolution</a></li><li class="chapter-item expanded "><a href="../reference/semver.zh.html" class="active"><strong aria-hidden="true">3.15.</strong> SemVer Compatibility</a></li><li class="chapter-item expanded "><a href="../reference/future-incompat-report.zh.html"><strong aria-hidden="true">3.16.</strong> Future incompat report</a></li><li class="chapter-item expanded "><a href="../reference/unstable.zh.html"><strong aria-hidden="true">3.17.</strong> Unstable Features</a></li></ol></li><li class="chapter-item expanded "><a href="../commands/index.zh.html"><strong aria-hidden="true">4.</strong> Cargo Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../commands/general-commands.zh.html"><strong aria-hidden="true">4.1.</strong> General Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../commands/cargo.zh.html"><strong aria-hidden="true">4.1.1.</strong> cargo</a></li><li class="chapter-item expanded "><a href="../commands/cargo-help.zh.html"><strong aria-hidden="true">4.1.2.</strong> cargo help</a></li><li class="chapter-item expanded "><a href="../commands/cargo-version.zh.html"><strong aria-hidden="true">4.1.3.</strong> cargo version</a></li></ol></li><li class="chapter-item expanded "><a href="../commands/build-commands.zh.html"><strong aria-hidden="true">4.2.</strong> Build Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../commands/cargo-bench.zh.html"><strong aria-hidden="true">4.2.1.</strong> cargo bench</a></li><li class="chapter-item expanded "><a href="../commands/cargo-build.zh.html"><strong aria-hidden="true">4.2.2.</strong> cargo build</a></li><li class="chapter-item expanded "><a href="../commands/cargo-check.zh.html"><strong aria-hidden="true">4.2.3.</strong> cargo check</a></li><li class="chapter-item expanded "><a href="../commands/cargo-clean.zh.html"><strong aria-hidden="true">4.2.4.</strong> cargo clean</a></li><li class="chapter-item expanded "><a href="../commands/cargo-doc.zh.html"><strong aria-hidden="true">4.2.5.</strong> cargo doc</a></li><li class="chapter-item expanded "><a href="../commands/cargo-fetch.zh.html"><strong aria-hidden="true">4.2.6.</strong> cargo fetch</a></li><li class="chapter-item expanded "><a href="../commands/cargo-fix.zh.html"><strong aria-hidden="true">4.2.7.</strong> cargo fix</a></li><li class="chapter-item expanded "><a href="../commands/cargo-run.zh.html"><strong aria-hidden="true">4.2.8.</strong> cargo run</a></li><li class="chapter-item expanded "><a href="../commands/cargo-rustc.zh.html"><strong aria-hidden="true">4.2.9.</strong> cargo rustc</a></li><li class="chapter-item expanded "><a href="../commands/cargo-rustdoc.zh.html"><strong aria-hidden="true">4.2.10.</strong> cargo rustdoc</a></li><li class="chapter-item expanded "><a href="../commands/cargo-test.zh.html"><strong aria-hidden="true">4.2.11.</strong> cargo test</a></li><li class="chapter-item expanded "><a href="../commands/cargo-report.zh.html"><strong aria-hidden="true">4.2.12.</strong> cargo report</a></li></ol></li><li class="chapter-item expanded "><a href="../commands/manifest-commands.zh.html"><strong aria-hidden="true">4.3.</strong> Manifest Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../commands/cargo-generate-lockfile.zh.html"><strong aria-hidden="true">4.3.1.</strong> cargo generate-lockfile</a></li><li class="chapter-item expanded "><a href="../commands/cargo-locate-project.zh.html"><strong aria-hidden="true">4.3.2.</strong> cargo locate-project</a></li><li class="chapter-item expanded "><a href="../commands/cargo-metadata.zh.html"><strong aria-hidden="true">4.3.3.</strong> cargo metadata</a></li><li class="chapter-item expanded "><a href="../commands/cargo-pkgid.zh.html"><strong aria-hidden="true">4.3.4.</strong> cargo pkgid</a></li><li class="chapter-item expanded "><a href="../commands/cargo-tree.zh.html"><strong aria-hidden="true">4.3.5.</strong> cargo tree</a></li><li class="chapter-item expanded "><a href="../commands/cargo-update.zh.html"><strong aria-hidden="true">4.3.6.</strong> cargo update</a></li><li class="chapter-item expanded "><a href="../commands/cargo-vendor.zh.html"><strong aria-hidden="true">4.3.7.</strong> cargo vendor</a></li><li class="chapter-item expanded "><a href="../commands/cargo-verify-project.zh.html"><strong aria-hidden="true">4.3.8.</strong> cargo verify-project</a></li></ol></li><li class="chapter-item expanded "><a href="../commands/package-commands.zh.html"><strong aria-hidden="true">4.4.</strong> Package Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../commands/cargo-init.zh.html"><strong aria-hidden="true">4.4.1.</strong> cargo init</a></li><li class="chapter-item expanded "><a href="../commands/cargo-install.zh.html"><strong aria-hidden="true">4.4.2.</strong> cargo install</a></li><li class="chapter-item expanded "><a href="../commands/cargo-new.zh.html"><strong aria-hidden="true">4.4.3.</strong> cargo new</a></li><li class="chapter-item expanded "><a href="../commands/cargo-search.zh.html"><strong aria-hidden="true">4.4.4.</strong> cargo search</a></li><li class="chapter-item expanded "><a href="../commands/cargo-uninstall.zh.html"><strong aria-hidden="true">4.4.5.</strong> cargo uninstall</a></li></ol></li><li class="chapter-item expanded "><a href="../commands/publishing-commands.zh.html"><strong aria-hidden="true">4.5.</strong> Publishing Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../commands/cargo-login.zh.html"><strong aria-hidden="true">4.5.1.</strong> cargo login</a></li><li class="chapter-item expanded "><a href="../commands/cargo-owner.zh.html"><strong aria-hidden="true">4.5.2.</strong> cargo owner</a></li><li class="chapter-item expanded "><a href="../commands/cargo-package.zh.html"><strong aria-hidden="true">4.5.3.</strong> cargo package</a></li><li class="chapter-item expanded "><a href="../commands/cargo-publish.zh.html"><strong aria-hidden="true">4.5.4.</strong> cargo publish</a></li><li class="chapter-item expanded "><a href="../commands/cargo-yank.zh.html"><strong aria-hidden="true">4.5.5.</strong> cargo yank</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../faq.zh.html"><strong aria-hidden="true">5.</strong> FAQ</a></li><li class="chapter-item expanded "><a href="../appendix/glossary.zh.html"><strong aria-hidden="true">6.</strong> Appendix: Glossary</a></li><li class="chapter-item expanded "><a href="../appendix/git-authentication.zh.html"><strong aria-hidden="true">7.</strong> Appendix: Git Authentication</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Cargo 官书（非官方翻译)</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/chinanf-boy/cargo-book-zh/edit/master/src/reference/semver.zh.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="semver-compatibility"><a class="header" href="#semver-compatibility">SemVer Compatibility</a></h1>
<p>本章详细介绍了对于新版本的软件包，通常认为什么是兼容的或破坏性的SemVer更改。看到了吗<a href="resolver.html#semver-compatibility">SemVer compatibility</a>本节详细介绍了什么是SemVer，以及Cargo如何使用它来确保库的兼容性。</p>
<p>这些只是<em>指导方针</em>，而不是所有项目都必须遵守的硬性规定。这个<a href="#change-categories">Change categories</a>第节详细介绍了本指南如何对变更的级别和严重性进行分类。本指南的大部分内容侧重于将导致<code>cargo</code>和<code>rustc</code>未能建造出以前有用的东西。几乎每一个变更都会带来一些风险，即它会对运行时行为产生负面影响，在这些情况下，项目维护人员通常会判断它是否是一个SemVer不兼容的变更。</p>
<p>另见<a href="https://github.com/rust-dev-tools/rust-semverver">rust-semverver</a>，这是一个尝试以编程方式检查兼容性规则的实验工具。</p>
<h2 id="change-categories"><a class="header" href="#change-categories">Change categories</a></h2>
<p>以下列出的所有政策均按变化程度分类：</p>
<ul>
<li><strong>重大变化</strong>：需要进行大幅度碰撞的更改。</li>
<li><strong>小变化</strong>：只需要轻微碰撞的更改。</li>
<li><strong>可能是零钱</strong>一些项目可能会考虑重大变化，而其他项目则考虑较小。</li>
</ul>
<p>“可能突破”类别包括具有以下特征的更改：<em>潜在的</em>在更新过程中中断，但不一定会导致中断。应仔细考虑这些变化的影响。具体性质将取决于变更和项目维护人员的原则。</p>
<p>一些项目可能会选择只在一个小的更改上增加补丁号。建议遵循SemVer规范，并且只在补丁版本中应用错误修复。然而，一个bug修复可能需要一个标记为“微小更改”的API更改，并且不应该影响兼容性。本指南没有对如何对待每个“微小变化”采取立场，因为微小变化和补丁变化之间的区别是取决于变化性质的惯例。</p>
<p>有些更改被标记为“微小”，尽管它们有破坏构建的潜在风险。这适用于可能性极低的情况，并且潜在的破坏性代码不太可能用惯用语言编写，或者特别不鼓励使用。</p>
<p>本指南使用术语“主要”和“次要”，假设这与“1.0.0”或更高版本有关。以“0.y.z”开头的初始开发版本可以将“y”中的更改视为主要版本，“z”中的更改视为次要版本。“0.0.z”版本总是主要的变化。这是因为Cargo使用的约定是，只有最左边的非零组件中的更改才被视为不兼容。</p>
<ul>
<li>API兼容性
<ul>
<li>项目
<ul>
<li><a href="#item-remove">Major: renaming/moving/removing any public items</a></li>
<li><a href="#item-new">Minor: adding new public items</a></li>
</ul>
</li>
<li>结构体
<ul>
<li><a href="#struct-add-private-field-when-public">Major: adding a private struct field when all current fields are public</a></li>
<li><a href="#struct-add-public-field-when-no-private">Major: adding a public field when no private field exists</a></li>
<li><a href="#struct-private-fields-with-private">Minor: adding or removing private fields when at least one already exists</a></li>
<li><a href="#struct-tuple-normal-with-private">Minor: going from a tuple struct with all private fields (with at least one field) to a normal struct, or vice versa</a></li>
</ul>
</li>
<li>枚举类型
<ul>
<li><a href="#enum-variant-new">Major: adding new enum variants (without <code>non_exhaustive</code>)</a></li>
<li><a href="#enum-fields-new">Major: adding new fields to an enum variant</a></li>
</ul>
</li>
<li>特点
<ul>
<li><a href="#trait-new-item-no-default">Major: adding a non-defaulted trait item</a></li>
<li><a href="#trait-item-signature">Major: any change to trait item signatures</a></li>
<li><a href="#trait-new-default-item">Possibly-breaking: adding a defaulted trait item</a></li>
<li><a href="#trait-object-safety">Major: adding a trait item that makes the trait non-object safe</a></li>
<li><a href="#trait-new-parameter-no-default">Major: adding a type parameter without a default</a></li>
<li><a href="#trait-new-parameter-default">Minor: adding a defaulted trait type parameter</a></li>
</ul>
</li>
<li>启动位置
<ul>
<li><a href="#impl-item-new">Possibly-breaking change: adding any inherent items</a></li>
</ul>
</li>
<li>仿制药
<ul>
<li><a href="#generic-bounds-tighten">Major: tightening generic bounds</a></li>
<li><a href="#generic-bounds-loosen">Minor: loosening generic bounds</a></li>
<li><a href="#generic-new-default">Minor: adding defaulted type parameters</a></li>
<li><a href="#generic-generalize-identical">Minor: generalizing a type to use generics (with identical types)</a></li>
<li><a href="#generic-generalize-different">Major: generalizing a type to use generics (with possibly different types)</a></li>
<li><a href="#generic-more-generic">Minor: changing a generic type to a more generic type</a></li>
</ul>
</li>
<li>功能
<ul>
<li><a href="#fn-change-arity">Major: adding/removing function parameters</a></li>
<li><a href="#fn-generic-new">Possibly-breaking: introducing a new function type parameter</a></li>
<li><a href="#fn-generalize-compatible">Minor: generalizing a function to use generics (supporting original type)</a></li>
<li><a href="#fn-generalize-mismatch">Major: generalizing a function to use generics with type mismatch</a></li>
</ul>
</li>
<li>属性
<ul>
<li><a href="#attr-no-std-to-std">Major: switching from <code>no_std</code> support to requiring <code>std</code></a></li>
</ul>
</li>
</ul>
</li>
<li>工具和环境兼容性
<ul>
<li><a href="#env-new-rust">Possibly-breaking: changing the minimum version of Rust required</a></li>
<li><a href="#env-change-requirements">Possibly-breaking: changing the platform and environment requirements</a></li>
<li>Cargo
<ul>
<li><a href="#cargo-feature-add">Minor: adding a new Cargo feature</a></li>
<li><a href="#cargo-feature-remove">Major: removing a Cargo feature</a></li>
<li><a href="#cargo-feature-remove-another">Major: removing a feature from a feature list if that changes functionality or public items</a></li>
<li><a href="#cargo-remove-opt-dep">Possibly-breaking: removing an optional dependency</a></li>
<li><a href="#cargo-change-dep-feature">Minor: changing dependency features</a></li>
<li><a href="#cargo-dep-add">Minor: adding dependencies</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#application-compatibility">Application compatibility</a></li>
</ul>
<h2 id="api-compatibility"><a class="header" href="#api-compatibility">API compatibility</a></h2>
<p>下面的所有示例都包含三个部分：原始代码、修改后的代码，以及可能出现在另一个项目中的代码用法示例。在一个小的改变中，示例用法应该成功地使用之前和之后的版本构建。</p>
<p><a id="item-remove"></a></p>
<h3 id="major-renamingmovingremoving-any-public-items"><a class="header" href="#major-renamingmovingremoving-any-public-items">Major: renaming/moving/removing any public items</a></h3>
<p>没有公开曝光的<a href="../../reference/items.html">item</a>将导致该项的任何使用无法编译。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub fn foo() {}

///////////////////////////////////////////////////////////
// After
// ... item has been removed

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    updated_crate::foo(); // Error: cannot find function `foo`
}
</code></pre>
<p>这包括添加任何类型的<a href="../../reference/conditional-compilation.html#the-cfg-attribute"><code>cfg</code> attribute</a>它可以根据以下内容更改可用的项目或行为：<a href="../../reference/conditional-compilation.html">conditional compilation</a>.</p>
<p>缓解策略：</p>
<ul>
<li>将要删除的项目标记为<a href="../../reference/attributes/diagnostics.html#the-deprecated-attribute">deprecated</a>，然后在以后的版本中删除它们。</li>
<li>将重命名的项目标记为<a href="../../reference/attributes/diagnostics.html#the-deprecated-attribute">deprecated</a>，并使用<a href="../../reference/items/use-declarations.html"><code>pub use</code></a>要重新导出为旧名称的项。</li>
</ul>
<p><a id="item-new"></a></p>
<h3 id="minor-adding-new-public-items"><a class="header" href="#minor-adding-new-public-items">Minor: adding new public items</a></h3>
<p>添加新的、公开的<a href="../../reference/items.html">items</a>这是一个小变化。</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
// ... absence of item

///////////////////////////////////////////////////////////
// After
pub fn foo() {}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
// `foo` is not used since it didn't previously exist.
</code></pre>
<p>请注意，在某些罕见的情况下，这可能是一个错误<strong>零钱</strong>由于全球进口。例如，如果您添加了一个新特性，而一个项目使用了一个全局导入，将该特性引入范围，并且新特性引入了一个关联项，该项与它所实现的任何类型都冲突，这可能会由于不明确而导致编译时错误。例子：</p>
<pre><code class="language-rust ignore">// Breaking change example

///////////////////////////////////////////////////////////
// Before
// ... absence of trait

///////////////////////////////////////////////////////////
// After
pub trait NewTrait {
    fn foo(&amp;self) {}
}

impl NewTrait for i32 {}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::*;

pub trait LocalTrait {
    fn foo(&amp;self) {}
}

impl LocalTrait for i32 {}

fn main() {
    123i32.foo(); // Error:  multiple applicable items in scope
}
</code></pre>
<p>这不被认为是一个重大变化，因为传统上，glob进口是一个已知的兼容性风险。Glob应避免从外部箱子进口物品。</p>
<p><a id="struct-add-private-field-when-public"></a></p>
<h3 id="major-adding-a-private-struct-field-when-all-current-fields-are-public"><a class="header" href="#major-adding-a-private-struct-field-when-all-current-fields-are-public">Major: adding a private struct field when all current fields are public</a></h3>
<p>当一个私有字段被添加到一个以前拥有所有公共字段的结构中时，这将破坏任何试图用<a href="../../reference/expressions/struct-expr.html">struct literal</a>.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo {
    pub f1: i32,
}

///////////////////////////////////////////////////////////
// After
pub struct Foo {
    pub f1: i32,
    f2: i32,
}

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    let x = updated_crate::Foo { f1: 123 }; // Error: cannot construct `Foo`
}
</code></pre>
<p>缓解策略：</p>
<ul>
<li>不要向所有公共字段结构添加新字段。</li>
<li>将结构标记为<a href="../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a>当第一次引入struct以防止用户使用struct literal语法时，而是提供构造函数方法和/或<a href="../../std/default/trait.Default.html">Default</a>实施</li>
</ul>
<p><a id="struct-add-public-field-when-no-private"></a></p>
<h3 id="major-adding-a-public-field-when-no-private-field-exists"><a class="header" href="#major-adding-a-public-field-when-no-private-field-exists">Major: adding a public field when no private field exists</a></h3>
<p>当一个公共字段被添加到一个包含所有公共字段的结构中时，这将破坏任何试图用公共字段构造它的代码<a href="../../reference/expressions/struct-expr.html">struct literal</a>.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo {
    pub f1: i32,
}

///////////////////////////////////////////////////////////
// After
pub struct Foo {
    pub f1: i32,
    pub f2: i32,
}

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    let x = updated_crate::Foo { f1: 123 }; // Error: missing field `f2`
}
</code></pre>
<p>缓解策略：</p>
<ul>
<li>不要向所有公共字段结构添加新字段。</li>
<li>将结构标记为<a href="../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a>当第一次引入struct以防止用户使用struct literal语法时，而是提供构造函数方法和/或<a href="../../std/default/trait.Default.html">Default</a>实施</li>
</ul>
<p><a id="struct-private-fields-with-private"></a></p>
<h3 id="minor-adding-or-removing-private-fields-when-at-least-one-already-exists"><a class="header" href="#minor-adding-or-removing-private-fields-when-at-least-one-already-exists">Minor: adding or removing private fields when at least one already exists</a></h3>
<p>当结构已经至少有一个私有字段时，可以安全地从结构中添加或删除私有字段。</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[derive(Default)]
pub struct Foo {
    f1: i32,
}

///////////////////////////////////////////////////////////
// After
#[derive(Default)]
pub struct Foo {
    f2: f64,
}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
fn main() {
    // Cannot access private fields.
    let x = updated_crate::Foo::default();
}
</code></pre>
<p>这是安全的，因为现有代码不能使用<a href="../../reference/expressions/struct-expr.html">struct literal</a>去构建它，也不完全匹配它的内容。</p>
<p>请注意，对于元组结构，这是一个<strong>重大变化</strong>如果元组包含公共字段，并且添加或删除私有字段会更改任何公共字段的索引。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[derive(Default)]
pub struct Foo(pub i32, i32);

///////////////////////////////////////////////////////////
// After
#[derive(Default)]
pub struct Foo(f64, pub i32, i32);

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    let x = updated_crate::Foo::default();
    let y = x.0; // Error: is private
}
</code></pre>
<p><a id="struct-tuple-normal-with-private"></a></p>
<h3 id="minor-going-from-a-tuple-struct-with-all-private-fields-with-at-least-one-field-to-a-normal-struct-or-vice-versa"><a class="header" href="#minor-going-from-a-tuple-struct-with-all-private-fields-with-at-least-one-field-to-a-normal-struct-or-vice-versa">Minor: going from a tuple struct with all private fields (with at least one field) to a normal struct, or vice versa</a></h3>
<p>如果所有字段都是私有的，那么将元组结构更改为普通结构（反之亦然）是安全的。</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[derive(Default)]
pub struct Foo(i32);

///////////////////////////////////////////////////////////
// After
#[derive(Default)]
pub struct Foo {
    f1: i32,
}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
fn main() {
    // Cannot access private fields.
    let x = updated_crate::Foo::default();
}
</code></pre>
<p>这是安全的，因为现有代码不能使用<a href="../../reference/expressions/struct-expr.html">struct literal</a>构建它，也不匹配它的内容。</p>
<p><a id="enum-variant-new"></a></p>
<h3 id="major-adding-new-enum-variants-without-non_exhaustive"><a class="header" href="#major-adding-new-enum-variants-without-non_exhaustive">Major: adding new enum variants (without <code>non_exhaustive</code>)</a></h3>
<p>如果枚举不使用<a href="../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a>属性</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub enum E {
    Variant1,
}

///////////////////////////////////////////////////////////
// After
pub enum E {
    Variant1,
    Variant2,
}

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    use updated_crate::E;
    let x = E::Variant1;
    match x { // Error: `Variant2` not covered
        E::Variant1 =&gt; {}
    }
}
</code></pre>
<p>缓解策略：</p>
<ul>
<li>引入枚举时，将其标记为<a href="../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a>强制用户使用<a href="../../reference/patterns.html#wildcard-pattern">wildcard patterns</a>捕捉新的变种。</li>
</ul>
<p><a id="enum-fields-new"></a></p>
<h3 id="major-adding-new-fields-to-an-enum-variant"><a class="header" href="#major-adding-new-fields-to-an-enum-variant">Major: adding new fields to an enum variant</a></h3>
<p>向枚举变量添加新字段是一个突破性的改变，因为所有字段都是公共的，构造函数和匹配项将无法编译。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub enum E {
    Variant1 { f1: i32 },
}

///////////////////////////////////////////////////////////
// After
pub enum E {
    Variant1 { f1: i32, f2: i32 },
}

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    use updated_crate::E;
    let x = E::Variant1 { f1: 1 }; // Error: missing f2
    match x {
        E::Variant1 { f1 } =&gt; {} // Error: missing f2
    }
}
</code></pre>
<p>缓解策略：</p>
<ul>
<li>引入枚举时，将变量标记为<a href="../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>non_exhaustive</code></a>因此，如果没有通配符，就无法构造或匹配它。
<pre><code class="language-rust ignore skip">pub enum E {
    #[non_exhaustive]
    Variant1{f1: i32}
}
</code></pre>
</li>
<li>引入枚举时，使用显式结构作为值，这样可以控制字段的可见性。
<pre><code class="language-rust ignore skip">pub struct Foo {
   f1: i32,
   f2: i32,
}
pub enum E {
    Variant1(Foo)
}
</code></pre>
</li>
</ul>
<p><a id="trait-new-item-no-default"></a></p>
<h3 id="major-adding-a-non-defaulted-trait-item"><a class="header" href="#major-adding-a-non-defaulted-trait-item">Major: adding a non-defaulted trait item</a></h3>
<p>将非默认项添加到特征中是一个突破性的改变。这将打破这种特性的任何实现者。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}

///////////////////////////////////////////////////////////
// After
pub trait Trait {
    fn foo(&amp;self);
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}  // Error: not all trait items implemented
</code></pre>
<p>缓解策略：</p>
<ul>
<li>始终为新关联的特征项提供默认实现或值。</li>
<li>在介绍这种特质时，使用<a href="https://rust-lang.github.io/api-guidelines/future-proofing.html#sealed-traits-protect-against-downstream-implementations-c-sealed">sealed trait</a>防止箱子外的用户实现该特性的技术。</li>
</ul>
<p><a id="trait-item-signature"></a></p>
<h3 id="major-any-change-to-trait-item-signatures"><a class="header" href="#major-any-change-to-trait-item-signatures">Major: any change to trait item signatures</a></h3>
<p>对特征项签名进行任何更改都是一个突破性的改变。这可能会打破这种特质的外部实现者。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {
    fn f(&amp;self, x: i32) {}
}

///////////////////////////////////////////////////////////
// After
pub trait Trait {
    // For sealed traits or normal functions, this would be a minor change
    // because generalizing with generics strictly expands the possible uses.
    // But in this case, trait implementations must use the same signature.
    fn f&lt;V&gt;(&amp;self, x: V) {}
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {
    fn f(&amp;self, x: i32) {}  // Error: trait declaration has 1 type parameter
}
</code></pre>
<p>缓解策略：</p>
<ul>
<li>引入带有默认实现的新项，以覆盖新功能，而不是修改现有项。</li>
<li>在介绍这种特质时，使用<a href="https://rust-lang.github.io/api-guidelines/future-proofing.html#sealed-traits-protect-against-downstream-implementations-c-sealed">sealed trait</a>防止箱子外的用户实现该特性的技术。</li>
</ul>
<p><a id="trait-new-default-item"></a></p>
<h3 id="possibly-breaking-adding-a-defaulted-trait-item"><a class="header" href="#possibly-breaking-adding-a-defaulted-trait-item">Possibly-breaking: adding a defaulted trait item</a></h3>
<p>添加默认特征项通常是安全的。然而，这有时会导致编译错误。例如，如果另一个特征中存在同名的方法，这可能会导致歧义。</p>
<pre><code class="language-rust ignore">// Breaking change example

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}

///////////////////////////////////////////////////////////
// After
pub trait Trait {
    fn foo(&amp;self) {}
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Trait;
struct Foo;

trait LocalTrait {
    fn foo(&amp;self) {}
}

impl Trait for Foo {}
impl LocalTrait for Foo {}

fn main() {
    let x = Foo;
    x.foo(); // Error: multiple applicable items in scope
}
</code></pre>
<p>请注意，这种模糊性确实存在<em>不</em>存在的名称冲突<a href="../../reference/items/implementations.html#inherent-implementations">inherent
implementations</a>，因为他们优先于特质项目。</p>
<p>查看<a href="#trait-object-safety">trait-object-safety</a>在添加特性项时要考虑的特殊情况。</p>
<p>缓解策略：</p>
<ul>
<li>一些项目可能会认为这种破损是可以接受的，尤其是如果新项目名称不太可能与任何现有代码冲突的话。仔细选择名称以避免这些冲突。此外，要求下游用户添加<a href="../../reference/expressions/call-expr.html#disambiguating-function-calls">disambiguation syntax</a>更新依赖项时选择正确的函数。</li>
</ul>
<p><a id="trait-object-safety"></a></p>
<h3 id="major-adding-a-trait-item-that-makes-the-trait-non-object-safe"><a class="header" href="#major-adding-a-trait-item-that-makes-the-trait-non-object-safe">Major: adding a trait item that makes the trait non-object safe</a></h3>
<p>这是一个突破性的改变，添加一个特性项，改变特性为不存在<a href="../../reference/items/traits.html#object-safety">object safe</a>.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}

///////////////////////////////////////////////////////////
// After
pub trait Trait {
    // An associated const makes the trait not object-safe.
    const CONST: i32 = 123;
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}

fn main() {
    let obj: Box&lt;dyn Trait&gt; = Box::new(Foo); // Error: cannot be made into an object
}
</code></pre>
<p>反过来做是安全的（把一个非对象安全的特征变成一个安全的特征）。</p>
<p><a id="trait-new-parameter-no-default"></a></p>
<h3 id="major-adding-a-type-parameter-without-a-default"><a class="header" href="#major-adding-a-type-parameter-without-a-default">Major: adding a type parameter without a default</a></h3>
<p>在没有默认特性的情况下添加类型参数是一个突破性的改变。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}

///////////////////////////////////////////////////////////
// After
pub trait Trait&lt;T&gt; {}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}  // Error: missing generics
</code></pre>
<p>缓解策略：</p>
<ul>
<li>查看<a href="#trait-new-parameter-default">adding a defaulted trait type parameter</a>.</li>
</ul>
<p><a id="trait-new-parameter-default"></a></p>
<h3 id="minor-adding-a-defaulted-trait-type-parameter"><a class="header" href="#minor-adding-a-defaulted-trait-type-parameter">Minor: adding a defaulted trait type parameter</a></h3>
<p>向trait添加类型参数是安全的，只要它有默认值。外部实现者将使用默认值，而无需指定参数。</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}

///////////////////////////////////////////////////////////
// After
pub trait Trait&lt;T = i32&gt; {}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}
</code></pre>
<p><a id="impl-item-new"></a></p>
<h3 id="possibly-breaking-change-adding-any-inherent-items"><a class="header" href="#possibly-breaking-change-adding-any-inherent-items">Possibly-breaking change: adding any inherent items</a></h3>
<p>通常，向实现中添加固有项应该是安全的，因为固有项优先于特性项。然而，在某些情况下，如果名称与具有不同签名的实现特征项相同，冲突可能会导致问题。</p>
<pre><code class="language-rust ignore">// Breaking change example

///////////////////////////////////////////////////////////
// Before
pub struct Foo;

///////////////////////////////////////////////////////////
// After
pub struct Foo;

impl Foo {
    pub fn foo(&amp;self) {}
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Foo;

trait Trait {
    fn foo(&amp;self, x: i32) {}
}

impl Trait for Foo {}

fn main() {
    let x = Foo;
    x.foo(1); // Error: this function takes 0 arguments
}
</code></pre>
<p>请注意，如果签名匹配，则不会出现编译时错误，但运行时行为可能会发生无声更改（因为它现在正在执行不同的函数）。</p>
<p>缓解策略：</p>
<ul>
<li>一些项目可能会认为这种破损是可以接受的，尤其是如果新项目名称不太可能与任何现有代码冲突的话。仔细选择名称以避免这些冲突。此外，要求下游用户添加<a href="../../reference/expressions/call-expr.html#disambiguating-function-calls">disambiguation syntax</a>更新依赖项时选择正确的函数。</li>
</ul>
<p><a id="generic-bounds-tighten"></a></p>
<h3 id="major-tightening-generic-bounds"><a class="header" href="#major-tightening-generic-bounds">Major: tightening generic bounds</a></h3>
<p>收紧类型的泛型界限是一个突破性的改变，因为这会打破用户对宽松界限的期望。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo&lt;A&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// After
pub struct Foo&lt;A: Eq&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Foo;

fn main() {
    let s = Foo { f1: 1.23 }; // Error: the trait bound `{float}: Eq` is not satisfied
}
</code></pre>
<p><a id="generic-bounds-loosen"></a></p>
<h3 id="minor-loosening-generic-bounds"><a class="header" href="#minor-loosening-generic-bounds">Minor: loosening generic bounds</a></h3>
<p>放松类型的泛型界限是安全的，因为它只扩展了允许的范围。</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo&lt;A: Clone&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// After
pub struct Foo&lt;A&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::Foo;

fn main() {
    let s = Foo { f1: 123 };
}
</code></pre>
<p><a id="generic-new-default"></a></p>
<h3 id="minor-adding-defaulted-type-parameters"><a class="header" href="#minor-adding-defaulted-type-parameters">Minor: adding defaulted type parameters</a></h3>
<p>向类型添加类型参数是安全的，只要它有默认值。所有现有引用都将使用默认值，而无需指定参数。</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[derive(Default)]
pub struct Foo {}

///////////////////////////////////////////////////////////
// After
#[derive(Default)]
pub struct Foo&lt;A = i32&gt; {
    f1: A,
}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::Foo;

fn main() {
    let s: Foo = Default::default();
}
</code></pre>
<p><a id="generic-generalize-identical"></a></p>
<h3 id="minor-generalizing-a-type-to-use-generics-with-identical-types"><a class="header" href="#minor-generalizing-a-type-to-use-generics-with-identical-types">Minor: generalizing a type to use generics (with identical types)</a></h3>
<p>结构或枚举字段可以从具体类型更改为泛型类型参数，前提是更改会导致所有现有用例的类型相同。例如，允许进行以下更改：</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo(pub u8);

///////////////////////////////////////////////////////////
// After
pub struct Foo&lt;T = u8&gt;(pub T);

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::Foo;

fn main() {
    let s: Foo = Foo(123);
}
</code></pre>
<p>因为现有的<code>Foo</code>是的缩写<code>Foo&lt;u8&gt;</code>这会产生相同的字段类型。</p>
<p><a id="generic-generalize-different"></a></p>
<h3 id="major-generalizing-a-type-to-use-generics-with-possibly-different-types"><a class="header" href="#major-generalizing-a-type-to-use-generics-with-possibly-different-types">Major: generalizing a type to use generics (with possibly different types)</a></h3>
<p>如果类型可以更改，将结构或枚举字段从具体类型更改为泛型类型参数可能会中断。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo&lt;T = u8&gt;(pub T, pub u8);

///////////////////////////////////////////////////////////
// After
pub struct Foo&lt;T = u8&gt;(pub T, pub T);

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Foo;

fn main() {
    let s: Foo&lt;f32&gt; = Foo(3.14, 123); // Error: mismatched types
}
</code></pre>
<p><a id="generic-more-generic"></a></p>
<h3 id="minor-changing-a-generic-type-to-a-more-generic-type"><a class="header" href="#minor-changing-a-generic-type-to-a-more-generic-type">Minor: changing a generic type to a more generic type</a></h3>
<p>将泛型类型更改为更通用的类型是安全的。例如，下面添加了一个默认为原始类型的泛型参数，这是安全的，因为所有现有用户将对这两个字段使用相同的类型，不需要指定默认参数。</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo&lt;T&gt;(pub T, pub T);

///////////////////////////////////////////////////////////
// After
pub struct Foo&lt;T, U = T&gt;(pub T, pub U);

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::Foo;

fn main() {
    let s: Foo&lt;f32&gt; = Foo(1.0, 2.0);
}
</code></pre>
<p><a id="fn-change-arity"></a></p>
<h3 id="major-addingremoving-function-parameters"><a class="header" href="#major-addingremoving-function-parameters">Major: adding/removing function parameters</a></h3>
<p>改变函数的算术性是一个突破性的改变。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub fn foo() {}

///////////////////////////////////////////////////////////
// After
pub fn foo(x: i32) {}

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    updated_crate::foo(); // Error: this function takes 1 argument
}
</code></pre>
<p>缓解策略：</p>
<ul>
<li>引入具有新签名的新函数，并可能<a href="../../reference/attributes/diagnostics.html#the-deprecated-attribute">deprecate</a>老的那个。</li>
<li>介绍采用struct参数的函数，其中struct是使用builder模式构建的。这允许将来将新字段添加到结构中。</li>
</ul>
<p><a id="fn-generic-new"></a></p>
<h3 id="possibly-breaking-introducing-a-new-function-type-parameter"><a class="header" href="#possibly-breaking-introducing-a-new-function-type-parameter">Possibly-breaking: introducing a new function type parameter</a></h3>
<p>通常，添加非默认类型参数是安全的，但在某些情况下，这可能是一个突破性的更改：</p>
<pre><code class="language-rust ignore">// Breaking change example

///////////////////////////////////////////////////////////
// Before
pub fn foo&lt;T&gt;() {}

///////////////////////////////////////////////////////////
// After
pub fn foo&lt;T, U&gt;() {}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::foo;

fn main() {
    foo::&lt;u8&gt;(); // Error: this function takes 2 generic arguments but 1 generic argument was supplied
}
</code></pre>
<p>然而，这种显式调用非常罕见（通常可以用其他方式编写），因此这种中断通常是可以接受的。我们应该考虑使用显式类型参数调用相关函数的可能性。</p>
<p><a id="fn-generalize-compatible"></a></p>
<h3 id="minor-generalizing-a-function-to-use-generics-supporting-original-type"><a class="header" href="#minor-generalizing-a-function-to-use-generics-supporting-original-type">Minor: generalizing a function to use generics (supporting original type)</a></h3>
<p>函数的参数类型或其返回值可以是<em>广义的</em>使用泛型，包括引入新的类型参数，只要可以将其实例化为原始类型。例如，允许进行以下更改：</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub fn foo(x: u8) -&gt; u8 {
    x
}
pub fn bar&lt;T: Iterator&lt;Item = u8&gt;&gt;(t: T) {}

///////////////////////////////////////////////////////////
// After
use std::ops::Add;
pub fn foo&lt;T: Add&gt;(x: T) -&gt; T {
    x
}
pub fn bar&lt;T: IntoIterator&lt;Item = u8&gt;&gt;(t: T) {}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::{bar, foo};

fn main() {
    foo(1);
    bar(vec![1, 2, 3].into_iter());
}
</code></pre>
<p>因为所有现有的使用都是新签名的实例。</p>
<p>也许有些令人惊讶的是，鉴于每个特征都实现了自身，一般化也适用于特征对象：</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}
pub fn foo(t: &amp;dyn Trait) {}

///////////////////////////////////////////////////////////
// After
pub trait Trait {}
pub fn foo&lt;T: Trait + ?Sized&gt;(t: &amp;T) {}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::{foo, Trait};

struct Foo;
impl Trait for Foo {}

fn main() {
    let obj = Foo;
    foo(&amp;obj);
}
</code></pre>
<p>（使用<code>?Sized</code>是必要的；否则您无法恢复原始签名。）</p>
<p>以这种方式引入泛型可能会导致类型推断失败。这通常很少见，对于某些项目来说可能是可以接受的，因为这可以通过附加类型注释来修复。</p>
<pre><code class="language-rust ignore">// Breaking change example

///////////////////////////////////////////////////////////
// Before
pub fn foo() -&gt; i32 {
    0
}

///////////////////////////////////////////////////////////
// After
pub fn foo&lt;T: Default&gt;() -&gt; T {
    Default::default()
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::foo;

fn main() {
    let x = foo(); // Error: type annotations needed
}
</code></pre>
<p><a id="fn-generalize-mismatch"></a></p>
<h3 id="major-generalizing-a-function-to-use-generics-with-type-mismatch"><a class="header" href="#major-generalizing-a-function-to-use-generics-with-type-mismatch">Major: generalizing a function to use generics with type mismatch</a></h3>
<p>如果泛型类型限制或更改了以前允许的类型，则更改函数参数或返回类型是一种突破性的更改。例如，以下内容添加了现有代码可能无法满足的通用约束：</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub fn foo(x: Vec&lt;u8&gt;) {}

///////////////////////////////////////////////////////////
// After
pub fn foo&lt;T: Copy + IntoIterator&lt;Item = u8&gt;&gt;(x: T) {}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::foo;

fn main() {
    foo(vec![1, 2, 3]); // Error: `Copy` is not implemented for `Vec&lt;u8&gt;`
}
</code></pre>
<p><a id="attr-no-std-to-std"></a></p>
<h3 id="major-switching-from-no_std-support-to-requiring-std"><a class="header" href="#major-switching-from-no_std-support-to-requiring-std">Major: switching from <code>no_std</code> support to requiring <code>std</code></a></h3>
<p>如果您的库特别支持<a href="../../reference/names/preludes.html#the-no_std-attribute"><code>no_std</code></a>环境，这是一个突破性的变化，使新的版本需要<code>std</code>.</p>
<pre><code class="language-rust ignore skip">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
#![no_std]
pub fn foo() {}

///////////////////////////////////////////////////////////
// After
pub fn foo() {
    std::time::SystemTime::now();
}

///////////////////////////////////////////////////////////
// Example usage that will break.
// This will fail to link for no_std targets because they don't have a `std` crate.
#![no_std]
use updated_crate::foo;

fn example() {
    foo();
}
</code></pre>
<p>缓解策略：</p>
<ul>
<li>避免这种情况的一个常见习惯用法是包含<code>std</code> <a href="features.html">Cargo feature</a>这可以选择性地启用<code>std</code>支持，当该功能关闭时，该库可以在<code>no_std</code>环境</li>
</ul>
<h2 id="tooling-and-environment-compatibility"><a class="header" href="#tooling-and-environment-compatibility">Tooling and environment compatibility</a></h2>
<p><a id="env-new-rust"></a></p>
<h3 id="possibly-breaking-changing-the-minimum-version-of-rust-required"><a class="header" href="#possibly-breaking-changing-the-minimum-version-of-rust-required">Possibly-breaking: changing the minimum version of Rust required</a></h3>
<p>在新版本的Rust中引入新功能可以打破使用旧版本Rust的项目。这还包括在新发布的Cargo中使用新功能，以及要求在之前在stable上工作的箱子中只使用夜间功能。</p>
<p>出于各种原因，一些项目选择在小版本中允许这种情况。更新到更新版本的Rust通常相对容易。Rust还有一个快速的6周发布周期，一些项目将在一个发布窗口内提供兼容性（例如当前的稳定版本加上N个以前的版本）。请记住，一些大型项目可能无法快速更新其 Rust 工具链。</p>
<p>缓解策略：</p>
<ul>
<li>使用<a href="features.html">Cargo features</a>让新功能选择加入。</li>
<li>为旧版本提供一个大的支持窗口。</li>
<li>如果可能，请复制新标准库项的源，以便可以继续使用旧版本，但利用新功能。</li>
<li>提供一个较旧的次要版本的单独分支，可以接收重要错误修复的后台端口。</li>
<li>留心这件事<a href="https://github.com/rust-lang/rust/issues/64796"><code>[cfg(version(..))]</code></a>和<a href="https://github.com/rust-lang/rust/issues/64797"><code>#[cfg(accessible(..))]</code></a>为新功能提供选择加入机制的功能。这些频道目前不稳定，只能在夜间频道使用。</li>
</ul>
<p><a id="env-change-requirements"></a></p>
<h3 id="possibly-breaking-changing-the-platform-and-environment-requirements"><a class="header" href="#possibly-breaking-changing-the-platform-and-environment-requirements">Possibly-breaking: changing the platform and environment requirements</a></h3>
<p>对于一个库所运行的环境，有各种各样的假设，例如主机平台、操作系统版本、可用服务、文件系统支持等。如果您发布一个新版本，限制以前支持的内容，那么这可能是一个突破性的改变，例如，需要更新版本的操作系统。这些更改可能很难跟踪，因为您可能并不总是知道更改是否在未自动测试的环境中中断。</p>
<p>一些项目可能认为这种破坏是可以接受的，尤其是如果大多数用户不太可能破坏，或者项目没有支持所有环境的资源。另一个值得注意的情况是，当供应商停止支持某些硬件或操作系统时，项目可能认为停止支持也是合理的。</p>
<p>缓解策略：</p>
<ul>
<li>记录您特别支持的平台和环境。</li>
<li>在CI中的各种环境中测试代码。</li>
</ul>
<h3 id="cargo"><a class="header" href="#cargo">Cargo</a></h3>
<p><a id="cargo-feature-add"></a></p>
<h4 id="minor-adding-a-new-cargo-feature"><a class="header" href="#minor-adding-a-new-cargo-feature">Minor: adding a new Cargo feature</a></h4>
<p>添加新的内容通常是安全的<a href="features.html">Cargo features</a>。如果该功能引入了新的更改，导致出现突破性的更改，这可能会给具有更严格向后兼容性需求的项目带来困难。在这种情况下，避免将该功能添加到“默认”列表中，并可能记录启用该功能的后果。</p>
<pre><code class="language-toml"># MINOR CHANGE

###########################################################
# Before
[features]
# ..empty

###########################################################
# After
[features]
std = []
</code></pre>
<p><a id="cargo-feature-remove"></a></p>
<h4 id="major-removing-a-cargo-feature"><a class="header" href="#major-removing-a-cargo-feature">Major: removing a Cargo feature</a></h4>
<p>这通常是一个突破性的改变删除<a href="features.html">Cargo features</a>。这将导致启用该功能的任何项目出错。</p>
<pre><code class="language-toml"># MAJOR CHANGE

###########################################################
# Before
[features]
logging = []

###########################################################
# After
[dependencies]
# ..logging removed
</code></pre>
<p>缓解策略：</p>
<ul>
<li>清楚地记录你的特征。如果存在内部或实验性功能，请将其标记为该功能，以便用户了解该功能的状态。</li>
<li>保留旧功能<code>Cargo.toml</code>，但在其他方面删除其功能。记录该功能已被弃用，并在未来的主要SemVer版本中删除它。</li>
</ul>
<p><a id="cargo-feature-remove-another"></a></p>
<h4 id="major-removing-a-feature-from-a-feature-list-if-that-changes-functionality-or-public-items"><a class="header" href="#major-removing-a-feature-from-a-feature-list-if-that-changes-functionality-or-public-items">Major: removing a feature from a feature list if that changes functionality or public items</a></h4>
<p>如果从另一个功能中删除一个功能，如果现有用户希望通过该功能可以使用该功能，那么这可能会中断现有用户。</p>
<pre><code class="language-toml"># Breaking change example

###########################################################
# Before
[features]
default = [&quot;std&quot;]
std = []

###########################################################
# After
[features]
default = []  # This may cause packages to fail if they are expecting std to be enabled.
std = []
</code></pre>
<p><a id="cargo-remove-opt-dep"></a></p>
<h4 id="possibly-breaking-removing-an-optional-dependency"><a class="header" href="#possibly-breaking-removing-an-optional-dependency">Possibly-breaking: removing an optional dependency</a></h4>
<p>删除可选依赖项可能会中断使用库的项目，因为另一个项目可能通过<a href="features.html">Cargo features</a>.</p>
<pre><code class="language-toml"># Breaking change example

###########################################################
# Before
[dependencies]
curl = { version = &quot;0.4.31&quot;, optional = true }

###########################################################
# After
[dependencies]
# ..curl removed
</code></pre>
<p>缓解策略：</p>
<ul>
<li>清楚地记录你的特征。如果可选的依赖项不包含在文档的特征列表中，那么您可能会认为更改无文档条目是安全的。</li>
<li>保留可选依赖项，只是不要在库中使用它。</li>
<li>将可选依赖项替换为<a href="features.html">Cargo feature</a>这不起任何作用，并记录它已被弃用。</li>
<li>使用支持可选依赖项的高级功能，并将其记录为支持扩展功能的首选方式。例如，如果您的库对“networking”之类的东西有可选支持，请创建一个通用功能名“networking”，以启用实现“networking”所需的可选依赖项。然后记录“联网”功能。</li>
</ul>
<p><a id="cargo-change-dep-feature"></a></p>
<h4 id="minor-changing-dependency-features"><a class="header" href="#minor-changing-dependency-features">Minor: changing dependency features</a></h4>
<p>更改依赖项上的功能通常是安全的，只要该功能不引入破坏性的更改。</p>
<pre><code class="language-toml"># MINOR CHANGE

###########################################################
# Before
[dependencies]
rand = { version = &quot;0.7.3&quot;, features = [&quot;small_rng&quot;] }


###########################################################
# After
[dependencies]
rand = &quot;0.7.3&quot;
</code></pre>
<p><a id="cargo-dep-add"></a></p>
<h4 id="minor-adding-dependencies"><a class="header" href="#minor-adding-dependencies">Minor: adding dependencies</a></h4>
<p>添加新的依赖项通常是安全的，只要新的依赖项不会引入导致破坏性更改的新需求。例如，添加一个新的依赖项是一个重大的改变，该依赖项需要在以前在stable上工作的项目中每晚工作一次。</p>
<pre><code class="language-toml"># MINOR CHANGE

###########################################################
# Before
[dependencies]
# ..empty

###########################################################
# After
[dependencies]
log = &quot;0.4.11&quot;
</code></pre>
<h2 id="application-compatibility"><a class="header" href="#application-compatibility">Application compatibility</a></h2>
<p>Cargo项目还可能包括具有自己接口（例如CLI接口、操作系统级交互等）的可执行二进制文件。因为它们是Cargo包装的一部分，所以它们通常使用和共享与包装相同的版本。在对应用程序进行更改时，您需要决定是否以及如何与用户签订SemVer合同。一个应用程序的潜在破坏性和兼容性更改太多，无法列出，因此我们鼓励您使用<a href="https://semver.org/">SemVer</a>规范来指导您决定如何对应用程序应用版本控制，或者至少记录您的承诺。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../reference/resolver.zh.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../reference/future-incompat-report.zh.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../reference/resolver.zh.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../reference/future-incompat-report.zh.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
