<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Cargo 官书（非官方翻译)</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Cargo ">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.zh.html">Introduction</a></li><li class="chapter-item expanded "><a href="getting-started/index.zh.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-started/installation.zh.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="getting-started/first-steps.zh.html"><strong aria-hidden="true">1.2.</strong> First Steps with Cargo</a></li></ol></li><li class="chapter-item expanded "><a href="guide/index.zh.html"><strong aria-hidden="true">2.</strong> Cargo Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guide/why-cargo-exists.zh.html"><strong aria-hidden="true">2.1.</strong> Why Cargo Exists</a></li><li class="chapter-item expanded "><a href="guide/creating-a-new-project.zh.html"><strong aria-hidden="true">2.2.</strong> Creating a New Package</a></li><li class="chapter-item expanded "><a href="guide/working-on-an-existing-project.zh.html"><strong aria-hidden="true">2.3.</strong> Working on an Existing Package</a></li><li class="chapter-item expanded "><a href="guide/dependencies.zh.html"><strong aria-hidden="true">2.4.</strong> Dependencies</a></li><li class="chapter-item expanded "><a href="guide/project-layout.zh.html"><strong aria-hidden="true">2.5.</strong> Package Layout</a></li><li class="chapter-item expanded "><a href="guide/cargo-toml-vs-cargo-lock.zh.html"><strong aria-hidden="true">2.6.</strong> Cargo.toml vs Cargo.lock</a></li><li class="chapter-item expanded "><a href="guide/tests.zh.html"><strong aria-hidden="true">2.7.</strong> Tests</a></li><li class="chapter-item expanded "><a href="guide/continuous-integration.zh.html"><strong aria-hidden="true">2.8.</strong> Continuous Integration</a></li><li class="chapter-item expanded "><a href="guide/cargo-home.zh.html"><strong aria-hidden="true">2.9.</strong> Cargo Home</a></li><li class="chapter-item expanded "><a href="guide/build-cache.zh.html"><strong aria-hidden="true">2.10.</strong> Build Cache</a></li></ol></li><li class="chapter-item expanded "><a href="reference/index.zh.html"><strong aria-hidden="true">3.</strong> Cargo Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/specifying-dependencies.zh.html"><strong aria-hidden="true">3.1.</strong> Specifying Dependencies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/overriding-dependencies.zh.html"><strong aria-hidden="true">3.1.1.</strong> Overriding Dependencies</a></li></ol></li><li class="chapter-item expanded "><a href="reference/manifest.zh.html"><strong aria-hidden="true">3.2.</strong> The Manifest Format</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/cargo-targets.zh.html"><strong aria-hidden="true">3.2.1.</strong> Cargo Targets</a></li></ol></li><li class="chapter-item expanded "><a href="reference/workspaces.zh.html"><strong aria-hidden="true">3.3.</strong> Workspaces</a></li><li class="chapter-item expanded "><a href="reference/features.zh.html"><strong aria-hidden="true">3.4.</strong> Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/features-examples.zh.html"><strong aria-hidden="true">3.4.1.</strong> Features Examples</a></li></ol></li><li class="chapter-item expanded "><a href="reference/profiles.zh.html"><strong aria-hidden="true">3.5.</strong> Profiles</a></li><li class="chapter-item expanded "><a href="reference/config.zh.html"><strong aria-hidden="true">3.6.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="reference/environment-variables.zh.html"><strong aria-hidden="true">3.7.</strong> Environment Variables</a></li><li class="chapter-item expanded "><a href="reference/build-scripts.zh.html"><strong aria-hidden="true">3.8.</strong> Build Scripts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/build-script-examples.zh.html"><strong aria-hidden="true">3.8.1.</strong> Build Script Examples</a></li></ol></li><li class="chapter-item expanded "><a href="reference/publishing.zh.html"><strong aria-hidden="true">3.9.</strong> Publishing on crates.io</a></li><li class="chapter-item expanded "><a href="reference/pkgid-spec.zh.html"><strong aria-hidden="true">3.10.</strong> Package ID Specifications</a></li><li class="chapter-item expanded "><a href="reference/source-replacement.zh.html"><strong aria-hidden="true">3.11.</strong> Source Replacement</a></li><li class="chapter-item expanded "><a href="reference/external-tools.zh.html"><strong aria-hidden="true">3.12.</strong> External Tools</a></li><li class="chapter-item expanded "><a href="reference/registries.zh.html"><strong aria-hidden="true">3.13.</strong> Registries</a></li><li class="chapter-item expanded "><a href="reference/resolver.zh.html"><strong aria-hidden="true">3.14.</strong> Dependency Resolution</a></li><li class="chapter-item expanded "><a href="reference/semver.zh.html"><strong aria-hidden="true">3.15.</strong> SemVer Compatibility</a></li><li class="chapter-item expanded "><a href="reference/future-incompat-report.zh.html"><strong aria-hidden="true">3.16.</strong> Future incompat report</a></li><li class="chapter-item expanded "><a href="reference/unstable.zh.html"><strong aria-hidden="true">3.17.</strong> Unstable Features</a></li></ol></li><li class="chapter-item expanded "><a href="commands/index.zh.html"><strong aria-hidden="true">4.</strong> Cargo Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/general-commands.zh.html"><strong aria-hidden="true">4.1.</strong> General Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/cargo.zh.html"><strong aria-hidden="true">4.1.1.</strong> cargo</a></li><li class="chapter-item expanded "><a href="commands/cargo-help.zh.html"><strong aria-hidden="true">4.1.2.</strong> cargo help</a></li><li class="chapter-item expanded "><a href="commands/cargo-version.zh.html"><strong aria-hidden="true">4.1.3.</strong> cargo version</a></li></ol></li><li class="chapter-item expanded "><a href="commands/build-commands.zh.html"><strong aria-hidden="true">4.2.</strong> Build Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/cargo-bench.zh.html"><strong aria-hidden="true">4.2.1.</strong> cargo bench</a></li><li class="chapter-item expanded "><a href="commands/cargo-build.zh.html"><strong aria-hidden="true">4.2.2.</strong> cargo build</a></li><li class="chapter-item expanded "><a href="commands/cargo-check.zh.html"><strong aria-hidden="true">4.2.3.</strong> cargo check</a></li><li class="chapter-item expanded "><a href="commands/cargo-clean.zh.html"><strong aria-hidden="true">4.2.4.</strong> cargo clean</a></li><li class="chapter-item expanded "><a href="commands/cargo-doc.zh.html"><strong aria-hidden="true">4.2.5.</strong> cargo doc</a></li><li class="chapter-item expanded "><a href="commands/cargo-fetch.zh.html"><strong aria-hidden="true">4.2.6.</strong> cargo fetch</a></li><li class="chapter-item expanded "><a href="commands/cargo-fix.zh.html"><strong aria-hidden="true">4.2.7.</strong> cargo fix</a></li><li class="chapter-item expanded "><a href="commands/cargo-run.zh.html"><strong aria-hidden="true">4.2.8.</strong> cargo run</a></li><li class="chapter-item expanded "><a href="commands/cargo-rustc.zh.html"><strong aria-hidden="true">4.2.9.</strong> cargo rustc</a></li><li class="chapter-item expanded "><a href="commands/cargo-rustdoc.zh.html"><strong aria-hidden="true">4.2.10.</strong> cargo rustdoc</a></li><li class="chapter-item expanded "><a href="commands/cargo-test.zh.html"><strong aria-hidden="true">4.2.11.</strong> cargo test</a></li><li class="chapter-item expanded "><a href="commands/cargo-report.zh.html"><strong aria-hidden="true">4.2.12.</strong> cargo report</a></li></ol></li><li class="chapter-item expanded "><a href="commands/manifest-commands.zh.html"><strong aria-hidden="true">4.3.</strong> Manifest Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/cargo-generate-lockfile.zh.html"><strong aria-hidden="true">4.3.1.</strong> cargo generate-lockfile</a></li><li class="chapter-item expanded "><a href="commands/cargo-locate-project.zh.html"><strong aria-hidden="true">4.3.2.</strong> cargo locate-project</a></li><li class="chapter-item expanded "><a href="commands/cargo-metadata.zh.html"><strong aria-hidden="true">4.3.3.</strong> cargo metadata</a></li><li class="chapter-item expanded "><a href="commands/cargo-pkgid.zh.html"><strong aria-hidden="true">4.3.4.</strong> cargo pkgid</a></li><li class="chapter-item expanded "><a href="commands/cargo-tree.zh.html"><strong aria-hidden="true">4.3.5.</strong> cargo tree</a></li><li class="chapter-item expanded "><a href="commands/cargo-update.zh.html"><strong aria-hidden="true">4.3.6.</strong> cargo update</a></li><li class="chapter-item expanded "><a href="commands/cargo-vendor.zh.html"><strong aria-hidden="true">4.3.7.</strong> cargo vendor</a></li><li class="chapter-item expanded "><a href="commands/cargo-verify-project.zh.html"><strong aria-hidden="true">4.3.8.</strong> cargo verify-project</a></li></ol></li><li class="chapter-item expanded "><a href="commands/package-commands.zh.html"><strong aria-hidden="true">4.4.</strong> Package Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/cargo-init.zh.html"><strong aria-hidden="true">4.4.1.</strong> cargo init</a></li><li class="chapter-item expanded "><a href="commands/cargo-install.zh.html"><strong aria-hidden="true">4.4.2.</strong> cargo install</a></li><li class="chapter-item expanded "><a href="commands/cargo-new.zh.html"><strong aria-hidden="true">4.4.3.</strong> cargo new</a></li><li class="chapter-item expanded "><a href="commands/cargo-search.zh.html"><strong aria-hidden="true">4.4.4.</strong> cargo search</a></li><li class="chapter-item expanded "><a href="commands/cargo-uninstall.zh.html"><strong aria-hidden="true">4.4.5.</strong> cargo uninstall</a></li></ol></li><li class="chapter-item expanded "><a href="commands/publishing-commands.zh.html"><strong aria-hidden="true">4.5.</strong> Publishing Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/cargo-login.zh.html"><strong aria-hidden="true">4.5.1.</strong> cargo login</a></li><li class="chapter-item expanded "><a href="commands/cargo-owner.zh.html"><strong aria-hidden="true">4.5.2.</strong> cargo owner</a></li><li class="chapter-item expanded "><a href="commands/cargo-package.zh.html"><strong aria-hidden="true">4.5.3.</strong> cargo package</a></li><li class="chapter-item expanded "><a href="commands/cargo-publish.zh.html"><strong aria-hidden="true">4.5.4.</strong> cargo publish</a></li><li class="chapter-item expanded "><a href="commands/cargo-yank.zh.html"><strong aria-hidden="true">4.5.5.</strong> cargo yank</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="faq.zh.html"><strong aria-hidden="true">5.</strong> FAQ</a></li><li class="chapter-item expanded "><a href="appendix/glossary.zh.html"><strong aria-hidden="true">6.</strong> Appendix: Glossary</a></li><li class="chapter-item expanded "><a href="appendix/git-authentication.zh.html"><strong aria-hidden="true">7.</strong> Appendix: Git Authentication</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Cargo 官书（非官方翻译)</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-cargo-book"><a class="header" href="#the-cargo-book">The Cargo Book</a></h1>
<p><img src="images/Cargo-Logo-Small.png" alt="Cargo Logo" /></p>
<p>Cargo 是<a href="https://www.rust-lang.org/">Rust</a>的 <em>箱子经理</em>。Cargo 会下载所需要的依赖项，还能编译您的代码，生成可分发的箱子，并将它们上传到<a href="https://crates.io/">crates.io</a> - Rust 社区的 <a href="./appendix/glossary.zh.html#package-registry" title="&quot;package registry&quot; (glossary entry)"><em>package registry</em></a> 。你可以为这本书做出贡献在<a href="https://github.com/rust-lang/cargo/tree/master/src/doc">GitHub</a>.</p>
<h3 id="章节"><a class="header" href="#章节">章节</a></h3>
<p><strong><a href="getting-started/index.zh.html">入门</a></strong></p>
<p>要开始使用 Cargo，请安装 Cargo(和 Rust)并设置您的第一个箱子.</p>
<p><strong><a href="guide/index.zh.html">Cargo 指南</a></strong></p>
<p>该指南将为您提供，有关如何使用 Cargo 开发 Rust 箱子的所有信息.</p>
<p><strong><a href="reference/index.zh.html">Cargo 参考</a></strong></p>
<p>该参考文献涵盖了 Cargo 各个领域的细节.</p>
<p><strong><a href="faq.zh.html">常见问题</a></strong></p>
<p><strong>附加:</strong></p>
<ul>
<li><a href="appendix/glossary.zh.html">术语</a></li>
<li><a href="appendix/git-authentication.html">Git Authentication</a></li>
</ul>
<p><strong>其他文档:</strong></p>
<ul>
<li><a href="https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md">Changelog</a> —
Detailed notes about changes in Cargo in each release.</li>
<li><a href="https://doc.rust-lang.org/">Rust documentation website</a> — Links to official
Rust documentation and tools.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>要开始使用 Cargo，请安装 Cargo(和 Rust)，并设置您的第一个<a href="getting-started/../appendix/glossary.zh.html#crate" title="&quot;crate&quot; (glossary entry)"><em>crate</em></a>.</p>
<ul>
<li><a href="getting-started/./installation.zh.html">安装</a></li>
<li><a href="getting-started/./first-steps.zh.html">Cargo 的第一步</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<h3 id="安装-rust-和-cargo"><a class="header" href="#安装-rust-和-cargo">安装 Rust 和 Cargo</a></h3>
<p>获得 Cargo 的最简单方法是使用<code>rustup</code>脚本，获取当前稳定版本的 <a href="https://www.rust-lang.org/">Rust</a>，它同时带上了<code>cargo</code>:</p>
<p>在 Linux 和 macOS 系统上，这可以通过以下方式完成:</p>
<pre><code class="language-console">curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>它将下载一个脚本，然后开始安装。如果一切顺利，您会看到:</p>
<pre><code class="language-console">Rust is installed now. Great!
</code></pre>
<p>在 Windows 上，下载并运行<a href="https://win.rustup.rs/">rustup-init.exe</a>。它将在控制台中启动安装，并在成功时显示上述消息.</p>
<p>在此之后，你可以使用<code>rustup</code>命令去安装，<code>beta</code>或者<code>nightly</code>版本的 Rust 和 Cargo。</p>
<p>有关其他安装选项和信息，请访问 Rust 网站的<a href="https://www.rust-lang.org/tools/install">安装</a>页面.</p>
<h3 id="从源头构建-cargo"><a class="header" href="#从源头构建-cargo">从源头构建 Cargo</a></h3>
<p>或者，你可以<a href="https://github.com/rust-lang/cargo#compiling-from-source">以源代码的方式，构建 Cargo</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cargo-的第一步"><a class="header" href="#cargo-的第一步">Cargo 的第一步</a></h2>
<p>本章节提供，cargo 命令的一些常用场景。如：</p>
<ol>
<li>生成一个新的<a href="getting-started/../appendix/glossary.zh.html#package" title="&quot;package&quot; (glossary entry)"><strong><em>package</em></strong></a></li>
<li>在 package 内，编译 <a href="getting-started/../appendix/glossary.zh.html#crate" title="&quot;crate&quot; (glossary entry)"><strong><em>crate</em></strong></a></li>
<li>以及，运行程序</li>
</ol>
<p>要使用 Cargo 启动新项目，请使用<code>cargo new</code>:</p>
<pre><code class="language-shell">$ cargo new hello_world
</code></pre>
<p>默认我们会传递<code>--bin</code>参数，表明我们正在制作一个二进制程序: 如果我们正在创建一个库(lib)，我们就会把传递<code>--lib</code>参数。</p>
<p>让我们来看看 Cargo 为我们带来了什么:</p>
<pre><code class="language-shell">$ cd hello_world
$ tree .
.
├── Cargo.toml
└── src
    └── main.rs

1 directory, 2 files
</code></pre>
<p>这就是我们开始所需要的一切。首先，让我们看看<code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
</code></pre>
<p>这被称为，<strong>manifest</strong>元清单，它包含了 Cargo 编译项目所需的所有元数据.</p>
<p>那<code>src/main.rs</code>有啥:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Cargo 为我们创造了一个“hello_world“，也就是一个<a href="getting-started/../appendix/glossary.zh.html#crate" title="&quot;crate&quot; (glossary entry)"><strong><em>binary crate</em></strong></a>。让我们来编译它:</p>
<pre><code class="language-shell">$ cargo build
   Compiling hello_world v0.1.0 (file:///path/to/project/hello_world)
</code></pre>
<p>然后，运行它:</p>
<pre><code class="language-shell">$ ./target/debug/hello_world
Hello, world!
</code></pre>
<p>我们也可以直接使用<code>cargo run</code>，它会自行编译，然后运行它， 一步到位:</p>
<pre><code class="language-shell">$ cargo run
     Fresh hello_world v0.1.0 (file:///path/to/project/hello_world)
   Running `target/hello_world`
Hello, world!
</code></pre>
<h2 id="走得更远"><a class="header" href="#走得更远">走得更远</a></h2>
<p>有关使用 Cargo 的更多详细信息，请查看<a href="getting-started/../guide/index.zh.html">Cargo 指南</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cargo-guide"><a class="header" href="#cargo-guide">Cargo Guide</a></h2>
<p>本指南将为您提供有关如何使用 Cargo 开发 Rust 包的所有信息.</p>
<ul>
<li><a href="guide/./why-cargo-exists.zh.html">为什么 Cargo 存在</a></li>
<li><a href="guide/./creating-a-new-project.zh.html">创建一个新包</a></li>
<li><a href="guide/./working-on-an-existing-project.zh.html">使用现有的 Cargo 箱子</a></li>
<li><a href="guide/./dependencies.zh.html">依赖</a></li>
<li><a href="guide/./project-layout.zh.html">项目布局</a></li>
<li><a href="guide/./cargo-toml-vs-cargo-lock.zh.html">Cargo.toml 与 Cargo.lock</a></li>
<li><a href="guide/./tests.zh.html">测试</a></li>
<li><a href="guide/./continuous-integration.zh.html">持续集成</a></li>
<li><a href="guide/./cargo-home.zh.html">Cargo Home</a></li>
<li><a href="guide/./build-cache.zh.html">构建的缓存</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="为什么-cargo-存在"><a class="header" href="#为什么-cargo-存在">为什么 Cargo 存在</a></h2>
<h3 id="前言"><a class="header" href="#前言">前言</a></h3>
<p>在 Rust, 正如你所了解的，一个库或执行程序被叫做 箱子。而箱子是通过 Rust 编译器<code>rustc</code>所编译的。当我们与 Rust 相遇，第一个源代码回事著名的 Hello World 程序，它可以直接用<code>rustc</code>编译。</p>
<pre><code class="language-console">$ rustc hello.rs
$ ./hello
Hello, world!
</code></pre>
<p>注意到，上面的命令，是需要指明文件名的。如果，我们直接使用 <code>rustc</code>，那么，命令行的调用，就会夹杂着不同的命令。更别说，特殊(更详细)的命令行选项的指定，去包括外部依赖…</p>
<p>更重要的是，当项目具有各种外部依赖，你要管理它们的版本，确保正确性与方便性。</p>
<p>为了可以做到人性化，不直接操作<code>rustc</code>，我们引入了更高的抽象工具 —— 包管理器</p>
<h3 id="出场cargo"><a class="header" href="#出场cargo">出场：Cargo</a></h3>
<p>Cargo 就是一个 Rust 的包管理器。允许 Rust 项目声明其各种依赖项，并确保您始终获得可重复的构建。</p>
<p>为了实现这一目标,Cargo 做了四件事:</p>
<ul>
<li>引入两个，包含各种项目信息的元数据文件。</li>
<li>获取，并构建项目的依赖项.</li>
<li>正确使用参数，以调用<code>rustc</code>或其他构建工具，构建你的项目。</li>
<li>介绍，更容易使用 Rust 项目的约定(规范/风格)。</li>
</ul>
<p>往大的说，Cargo 给构建一个程序，一个库，带来了一种标准化的方式，不去管项目的名字，更不需要直接调用 <code>rustc</code>，我们可以更常规地调用<code>cargo build</code>，然后，让 cargo 处理正确的<code>rustc</code>调用。Cargo 还会自动从<a href="guide/../appendix/glossary.zh.html#registry" title="&quot;registry&quot; (glossary entry)"><em>registry</em></a>，获取我们的依赖项，安排得明明白白。</p>
<p>一语言之，有了 Cargo，你的 Rust 就有了垫脚石。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="创建一个新项目"><a class="header" href="#创建一个新项目">创建一个新项目</a></h2>
<p>要使用 Cargo 启动 新<a href="guide/../appendix/glossary.zh.html#package" title="&quot;package&quot; (glossary entry)">package</a>，请使用<code>cargo new</code>:</p>
<pre><code class="language-shell">$ cargo new hello_world --bin
</code></pre>
<p>我们传递<code>--bin</code>，是因为我们正在制作一个二进制程序(默认): 如果我们正在创建一个库(lib)，我们就会把传递<code>--lib</code>。默认情况下，这个目录会初始化为一个新的<code>git</code>存储库，如果您不希望它这样做，请传递<code>--vcs none</code>。</p>
<p>让我们来看看 Cargo 为我们带来了什么:</p>
<pre><code class="language-shell">$ cd hello_world
$ tree .
.
├── Cargo.toml
└── src
    └── main.rs

1 directory, 2 files
</code></pre>
<p>这就是我们开始所需要的一切首。先让我们看看<code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;

[dependencies]
</code></pre>
<p>这被称为一个<strong>manifest</strong>元清单，它包含了 Cargo 编译项目所需的所有元数据，它是
<a href="https://toml.io/">TOML</a> 格式的文件。</p>
<p>那<code>src/main.rs</code>有啥:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Cargo 为我们创造了一个“hello_world“，一个<a href="guide/../appendix/glossary.zh.html#crate" title="&quot;crate&quot; (glossary entry)"><em>binary crate</em></a>。我们来编译它:</p>
<pre><code class="language-shell">$ cargo build
   Compiling hello_world v0.1.0 (file:///path/to/project/hello_world)
</code></pre>
<p>然后，运行它:</p>
<pre><code class="language-shell">$ ./target/debug/hello_world
Hello, world!
</code></pre>
<p>我们也可以直接使用<code>cargo run</code>，它会自行编译，然后运行它, 一步到位(如果，你看不到<code>Compiling</code>标识的输出行，说明你并没有更改那些项):</p>
<pre><code class="language-shell">$ cargo run
     Fresh hello_world v0.1.0 (file:///path/to/project/hello_world)
   Running `target/hello_world`
Hello, world!
</code></pre>
<p>这个<code>Cargo.lock</code>文件啊，是包含我们的依赖项的有关信息(即便还没有依赖)，其内容看起来可不是很有趣啊。再有就是<code>target</code>目录包含所有构建产品(二进制文件..)，并且，可以看出，Cargo 默认生成调试(debug)版本。您可以使用<code>cargo build --release</code>，这会在开启优化的情况下，编译文件:</p>
<pre><code class="language-shell">$ cargo build --release
   Compiling hello_world v0.1.0 (file:///path/to/project/hello_world)
</code></pre>
<p><code>cargo build --release</code>将结果二进制文件放入<code>target/release</code>，而不再是<code>target/debug</code>目录.</p>
<p>调试模式的编译是开发的默认设置 - 编译时间较短，因为编译器不进行优化，但代码运行速度较慢。发布(release)模式编译需要更长时间，但代码运行速度更快.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="在现有的-carog-项目上工作"><a class="header" href="#在现有的-carog-项目上工作">在现有的 Carog 项目上工作</a></h2>
<p>如果您下载使用 Cargo 的现有<a href="guide/../appendix/glossary.html#package" title="&quot;package&quot; (glossary entry)">package</a>，那么它很容易上手.</p>
<p>首先，从某个地方获取项目.在这个例子中，我们将使用<code>rand</code>项目，其从 GitHub 上的存储库克隆而来:</p>
<pre><code class="language-shell">$ git clone https://github.com/rust-lang-nursery/rand.git
$ cd rand
</code></pre>
<p>要建立，使用<code>cargo build</code>:</p>
<pre><code class="language-shell">$ cargo build
   Compiling rand v0.1.0 (file:///path/to/project/rand)
</code></pre>
<p>这将获取所有依赖项，然后与项目一起构建它们.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="从-cratesio-添加依赖项"><a class="header" href="#从-cratesio-添加依赖项">从 crates.io 添加依赖项</a></h2>
<p><a href="https://crates.io/">crates.io</a>是 Rust 社区的中央<a href="guide/../appendix/glossary.zh.html#package-registry" title="&quot;package-registry&quot; (glossary entry)"><em>package registry</em></a>，用作发现和下载<a href="guide/../appendix/glossary.zh.html#package" title="&quot;package&quot; (glossary entry)">packages</a> 的位置。<code>cargo</code>默认配置为，使用它来查找请求的包.</p>
<p>获取托管在<a href="https://crates.io/">crates.io</a>的依赖’库’，将它添加到您的<code>Cargo.toml</code>.</p>
<h3 id="添加依赖项"><a class="header" href="#添加依赖项">添加依赖项</a></h3>
<p>如果你的<code>Cargo.toml</code>，还没有<code>[dependencies]</code>部分，添加它，然后列出您要使用的<a href="guide/../appendix/glossary.zh.html#crate" title="&quot;crate&quot; (glossary entry)">crate</a>名称和版本。这个例子增加了一个<code>time</code>箱子依赖:</p>
<pre><code class="language-toml">[dependencies]
time = &quot;0.1.12&quot;
</code></pre>
<p>版本字符串是<a href="https://semver.org">SemVer</a>版本要求。该<a href="guide/../reference/specifying-dependencies.zh.html">指定依赖项</a>文档 提供了有关此处选项的更多信息.</p>
<p>如果我们还想添加一个<code>regex</code>箱子依赖，我们不需要为每个箱子都添加<code>[dependencies]</code>。下面就是你的<code>Cargo.toml</code>文件整体，看起来像依赖于<code>time</code>和<code>regex</code>箱:</p>
<pre><code class="language-toml">[package]
name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
time = &quot;0.1.12&quot;
regex = &quot;0.1.41&quot;
</code></pre>
<p>重新运行<code>cargo build</code>，Cargo 将获取新的依赖项及其所有依赖项，将它们全部编译，然后更新<code>Cargo.lock</code>:</p>
<pre><code class="language-shell">$ cargo build
      Updating registry `https://github.com/rust-lang/crates.io-index`
   Downloading memchr v0.1.5
   Downloading libc v0.1.10
   Downloading regex-syntax v0.2.1
   Downloading memchr v0.1.5
   Downloading aho-corasick v0.3.0
   Downloading regex v0.1.41
     Compiling memchr v0.1.5
     Compiling libc v0.1.10
     Compiling regex-syntax v0.2.1
     Compiling memchr v0.1.5
     Compiling aho-corasick v0.3.0
     Compiling regex v0.1.41
     Compiling hello_world v0.1.0 (file:///path/to/project/hello_world)
</code></pre>
<p>我们的<code>Cargo.lock</code>包含有关，我们使用的所有这些依赖项的哪个版本的确实信息.</p>
<p>现在，如果<code>regex</code>在<a href="https://crates.io/">crates.io</a>上更新了，在我们选择<code>cargo update</code>之前，我们仍会使用相同的版本进行构建.</p>
<p>你现在可以在<code>main.rs</code>，使用<code>regex</code>箱了。</p>
<pre><pre class="playground"><code class="language-rust">extern crate regex;

use regex::Regex;

fn main() {
    let re = Regex::new(r&quot;^\d{4}-\d{2}-\d{2}$&quot;).unwrap();
    println!(&quot;Did our date match? {}&quot;, re.is_match(&quot;2014-01-01&quot;));
}
</code></pre></pre>
<p>运行它，将显示:</p>
<pre><code class="language-shell">$ cargo run
   Running `target/hello_world`
Did our date match? true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="项目布局"><a class="header" href="#项目布局">项目布局</a></h2>
<p>Cargo 使用文件放置惯例，以便轻松进入新的 Cargo 项目:</p>
<pre><code class="language-text">.
├── Cargo.lock
├── Cargo.toml
├── src/
│   ├── lib.rs
│   ├── main.rs
│   └── bin/
│       ├── named-executable.rs
│       ├── another-executable.rs
│       └── multi-file-executable/
│           ├── main.rs
│           └── some_module.rs
├── benches/
│   ├── large-input.rs
│   └── multi-file-bench/
│       ├── main.rs
│       └── bench_module.rs
├── examples/
│   ├── simple.rs
│   └── multi-file-example/
│       ├── main.rs
│       └── ex_module.rs
└── tests/
    ├── some-integration-tests.rs
    └── multi-file-test/
        ├── main.rs
        └── test_module.rs
</code></pre>
<ul>
<li><code>Cargo.toml</code>和<code>Cargo.lock</code>存储在项目的根目录中.</li>
<li>源代码进入<code>src</code>目录</li>
<li>默认库文件是<code>src/lib.rs</code></li>
<li>默认的可执行文件是<code>src/main.rs</code></li>
<li>其他可执行文件，可以放入<code>src/bin/*.rs</code></li>
<li>集成测试进入<code>tests</code>目录</li>
<li>示例进入<code>examples</code>目录</li>
<li>基准进入<code>benches</code>目录</li>
</ul>
<p>如果一个 binary, example, bench 或是集成测试由多个源文件组成，那么在<code>src/bin</code>, <code>examples</code>, <code>benches</code>, or <code>tests</code>的子目录里，放一个带有额外<a href="guide/../appendix/glossary.zh.html#module" title="&quot;module&quot; (glossary entry)"><em>modules</em></a> 的<code>main.rs</code>文件。执行名为目录名。</p>
<p>关于 Rust’s 模块系统在这本书 <a href="guide/../../book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">the book</a>。</p>
<p>也可以看看 <a href="guide/../reference/cargo-targets.zh.html#configuring-a-target">配置一个 target</a> 关于手动配置 targets 的方法。
还可以看看 <a href="guide/../reference/cargo-targets.zh.html#target-auto-discovery">自动发现 Target</a> ，关于操纵 Cargo 自动推断 target 名称。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cargotoml-与-cargolock"><a class="header" href="#cargotoml-与-cargolock">Cargo.toml 与 Cargo.lock</a></h2>
<p><code>Cargo.toml</code>和<code>Cargo.lock</code>各有其目的。在我们谈论它们之前，这是一个总结:</p>
<ul>
<li><code>Cargo.toml</code>是从广义上描述你的依赖，并由你编写.</li>
<li><code>Cargo.lock</code>包含有关您的依赖项的确切信息。它由 Cargo 维护，不应手动编辑.</li>
</ul>
<p>如果您正在构建，其他项目要依赖的库，请将<code>Cargo.lock</code>放置在你的<code>.gitignore</code>。如果您正在构建可执行文件，如命令行工具或应用程序，请检查<code>Cargo.lock</code>位于<code>git</code>管理下。如果你对这是为什么感到好奇，请参阅<a href="guide/../faq.zh.html#why-do-binaries-have-cargolock-in-version-control-but-not-libraries">“为什么二进制文件在版本控制系统中有<code>Cargo.lock</code>，而库没有?” - FAQ </a>.</p>
<p>让我们再挖掘一下.</p>
<p><code>Cargo.toml</code>是一个<strong>manifest(清单)</strong>，我们可以在其中指定一系列关于我们项目的不同元数据的文件。例如，我们可以说我们依赖于另一个项目:</p>
<pre><code class="language-toml">[package]
name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]

[dependencies]
rand = { git = &quot;https://github.com/rust-lang-nursery/rand.git&quot; }
</code></pre>
<p>这个项目有一个依赖关系<code>rand</code>箱。在这种情况下，我们已经说过，我们依赖于 GitHub 上的特定 Git 存储库。由于我们尚未指定任何其他信息，因此 Cargo 假定我们打算使用最新提交的<code>master</code>分支构建我们的项目。</p>
<p>听起来不错? 嗯，但有一个问题: 如果你今天构建这个项目，然后你发送一份副本给我，我明天构建这个项目，可能会发生一些不好的事情。因在此期间，可能会有更多的<code>rand</code>提交，我的构建将包括新的提交，而你的不会。因此，我们会得到不同的构建。这很糟糕，因为我们需要可重复的构建.</p>
<p>我们可以通过放置一个<code>rev</code>来解决这个问题，写入我们<code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
rand = { git = &quot;https://github.com/rust-lang-nursery/rand.git&quot;, rev = &quot;9f35b8e&quot; }
</code></pre>
<p>现在我们的构建将是相同的。但是有一个很大的缺点:现在我们每次想要更新库时，都必须手动考虑 SHA-1。这既乏味又容易出错.</p>
<p>那现在<code>Cargo.lock</code>登场了。由于它的存在，我们不需要手动跟踪确切的修订版本: Cargo 将为我们做。当我们有这样的清单时:</p>
<pre><code class="language-toml">[package]
name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]

[dependencies]
rand = { git = &quot;https://github.com/rust-lang-nursery/rand.git&quot; }
</code></pre>
<p>Cargo 将采取最新的提交，并在我们第一次构建时，将这些信息写入我们的<code>Cargo.lock</code>。该文件将如下所示:</p>
<pre><code class="language-toml">[root]
name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
dependencies = [
 &quot;rand 0.1.0 (git+https://github.com/rust-lang-nursery/rand.git#9f35b8e439eeedd60b9414c58f389bdc6a3284f9)&quot;，
]

[[package]]
name = &quot;rand&quot;
version = &quot;0.1.0&quot;
source = &quot;git+https://github.com/rust-lang-nursery/rand.git#9f35b8e439eeedd60b9414c58f389bdc6a3284f9&quot;
</code></pre>
<p>你可以看到这里有更多的信息，包括我们用来构建的确切修订版本。现在，当您将项目交给其他人时，他们将使用完全相同的 SHA，即使我们没有在我们的项目<code>Cargo.toml</code>中指定它.</p>
<p>当我们准备选择，更新库的版本时，Cargo 会自动重新计算依赖关系，并为我们更新内容:</p>
<pre><code class="language-shell">$ cargo update           # updates all dependencies
$ cargo update -p rand   # updates just “rand”
</code></pre>
<p>这将写出一个新的<code>Cargo.lock</code>与新版本信息。请注意<code>cargo update</code>参数，实际上会是是一个<a href="guide/../reference/pkgid-spec.zh.html">包 ID 规范</a>，和<code>rand</code>只是一个简短的规范.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="测试"><a class="header" href="#测试">测试</a></h2>
<p>Cargo 可以使用<code>cargo test</code>命令运行您的测试。Cargo 寻找在两个地方运行的测试 :在你<code>src</code>中的每个文件，和<code>tests/</code>中的任何测试。测试你的<code>src</code>文件应该是单元测试，并在<code>tests/</code>中的应该是整合式测试。因此，您需要将<a href="guide/../appendix/glossary.zh.html#package" title="&quot;package&quot; (glossary entry)">package</a>导入到<code>tests</code>的文件中.</p>
<p>这是在我们的项目中，运行<code>cargo test</code>的一个例子，目前没有测试:</p>
<pre><code class="language-console">$ cargo test
   Compiling regex v1.5.0 (https://github.com/rust-lang/regex.git#9f9f693)
   Compiling hello_world v0.1.0 (file:///path/to/package/hello_world)
     Running target/test/hello_world-9c2b65bbb79eabce

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>如果我们的项目有测试，我们会看到更多的输出与正确的测试数量.</p>
<p>您还可以通过传递过滤器，来运行特定测试:</p>
<pre><code class="language-shell">$ cargo test foo
</code></pre>
<p>这将运行任何匹配的<code>foo</code>测试.</p>
<p><code>cargo test</code>还运行其他检查。例如，它将编译您包含的任何示例(examples)，并且还将测试文档中的示例。请看在 Rust 文档中的<a href="guide/../../book/ch11-00-testing.html">测试指南</a>，了解更多详细信息.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="持续集成"><a class="header" href="#持续集成">持续集成</a></h2>
<h3 id="travis-ci"><a class="header" href="#travis-ci">Travis CI</a></h3>
<p>要在 Travis CI 上测试您的项目，这里有一个<code>.travis.yml</code>文件示例:</p>
<pre><code class="language-yaml">language: rust
rust:
  - stable
  - beta
  - nightly
matrix:
  allow_failures:
    - rust: nightly
</code></pre>
<p>这将在所有三个 rust 版本下，进行测试，但 nightly 的任何破坏，都不会使整体构建失败。请看看<a href="https://docs.travis-ci.com/user/languages/rust/">Travis CI Rust 文档</a>了解更多信息.</p>
<h3 id="github-actions"><a class="header" href="#github-actions">GitHub Actions</a></h3>
<p>GitHub Actions 中，测试项目, 这里有个简单的 <code>.github/workflows/ci.yml</code> 文件:</p>
<pre><code class="language-yaml">name: Cargo Build &amp; Test

on:
  push:
  pull_request:

env:
  CARGO_TERM_COLOR: always

jobs:
  build_and_test:
    name: Rust project - latest
    runs-on: ubuntu-latest
    strategy:
      matrix:
        toolchain:
          - stable
          - beta
          - nightly
    steps:
      - uses: actions/checkout@v2
      - run: rustup update ${{ matrix.toolchain }} &amp;&amp; rustup default ${{ matrix.toolchain }}
      - run: cargo build --verbose
      - run: cargo test --verbose
</code></pre>
<p>这会测试三个 release channels (注意：一个错，整个测试流程就会是错误的)。 你还可以在 Github 上面， <code>&quot;Actions&quot; &gt; &quot;new workflow&quot;</code> ，并选择 Rust ，将 <a href="https://github.com/actions/starter-workflows/blob/main/ci/rust.yml">default configuration</a> 添加到你的库。 <a href="https://docs.github.com/en/actions">GitHub Actions 文档</a>有更多信息。</p>
<h3 id="gitlab-ci"><a class="header" href="#gitlab-ci">GitLab CI</a></h3>
<p>要在 GitLab CI 上测试您的包，这里有一个<code>.gitlab-ci.yml</code>文件示例:</p>
<pre><code class="language-yaml">stages:
  - build

rust-latest:
  stage: build
  image: rust:latest
  script:
    - cargo build --verbose
    - cargo test --verbose

rust-nightly:
  stage: build
  image: rustlang/rust:nightly
  script:
    - cargo build --verbose
    - cargo test --verbose
  allow_failure: true
</code></pre>
<p>这将测试 stable 版本和 nightly 版本，但 nightly 的任何破损，都不会使整体构建失败。欲获得更多信息，请看<a href="https://docs.gitlab.com/ce/ci/yaml/README.md">GitLab CI</a>.</p>
<h3 id="buildssrht"><a class="header" href="#buildssrht">builds.sr.ht</a></h3>
<p>在 sr.ht 测试你的项目, 在这里有个简单 <code>.build.yml</code> 文件。
要记得，更改你 <code>&lt;your repo&gt;</code> 和 <code>&lt;your project&gt;</code>。</p>
<pre><code class="language-yaml">image: archlinux
packages:
  - rustup
sources:
  - &lt;your repo&gt;
tasks:
  - setup: |
      rustup toolchain install nightly stable
      cd &lt;your project&gt;/
      rustup run stable cargo fetch
  - stable: |
      rustup default stable
      cd &lt;your project&gt;/
      cargo build --verbose
      cargo test --verbose
  - nightly: |
      rustup default nightly
      cd &lt;your project&gt;/
      cargo build --verbose ||:
      cargo test --verbose  ||:
  - docs: |
      cd &lt;your project&gt;/
      rustup run stable cargo doc --no-deps
      rustup run nightly cargo doc --no-deps ||:
</code></pre>
<p>这会在 stable channel 和 nightly
channel 上构建文档和测试, 但 nightly 版本的一个崩溃，不会对整个构建产生影响。 <a href="https://man.sr.ht/builds.sr.ht/">builds.sr.ht 文档</a> 有更多的信息。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cargo-home"><a class="header" href="#cargo-home">Cargo Home</a></h2>
<p>The “Cargo home” 的作用，就是作为下载和源代码的缓存位置。
当构建一个 <a href="guide/../appendix/glossary.html#crate" title="&quot;crate&quot; (glossary entry)">crate</a> 的时候, Cargo 会将下载的 依赖项，存储到 Cargo home.
通过 <code>CARGO_HOME</code> <a href="guide/../reference/environment-variables.html">environmental variable</a> 设置。
如果有需要，官方提供 <a href="https://crates.io/crates/home">home</a> 箱子，获取到位置.
默认情况下，位置是 <code>$HOME/.cargo/</code>。</p>
<p>号外， Cargo home 内部结构尚未稳定，留意留意。</p>
<p>The Cargo home 由以下部分组成：</p>
<h2 id="files"><a class="header" href="#files">Files:</a></h2>
<ul>
<li>
<p><code>config.toml</code>
Cargo’s 全局配置文件，参考书上会更详细点 <a href="guide/../reference/config.html">config entry</a>.</p>
</li>
<li>
<p><code>credentials.toml</code>
来自<a href="guide/../commands/cargo-login.html"><code>cargo login</code></a> 的私有登录证书，为了登录 <a href="guide/../appendix/glossary.html#registry" title="&quot;registry&quot; (glossary entry)">registry</a>.</p>
</li>
<li>
<p><code>.crates.toml</code>, <code>.crates2.json</code>
这些隐藏的文件包含 <a href="guide/../appendix/glossary.html#package" title="&quot;package&quot; (glossary entry)">package</a> 信息 —— 通过<a href="guide/../commands/cargo-install.html"><code>cargo install</code></a>下载的。这文件不要手动修改。</p>
</li>
</ul>
<h2 id="目录"><a class="header" href="#目录">目录:</a></h2>
<ul>
<li>
<p><code>bin</code>
通过 <a href="guide/../commands/cargo-install.html"><code>cargo install</code></a> or <a href="https://rust-lang.github.io/rustup/"><code>rustup</code></a>下载，箱子的可执行文件。
为了能够访问到这些文件，请将这个目录路径添加到<code>$PATH</code>环境变量。</p>
</li>
<li>
<p><code>git</code>
Git sources are stored here:</p>
<ul>
<li>
<p><code>git/db</code>
当一个箱子依赖一个 git repository, Cargo clones the repo 到这个目录；需要时则更新。</p>
</li>
<li>
<p><code>git/checkouts</code>
这里就是放着 <code>git/db</code> 里面，git repo 具体的 commit。
它给编译器供货。
同一个 git 存储库，不同 commit 的多个 checkout，是可能的</p>
</li>
</ul>
</li>
<li>
<p><code>registry</code>
箱子来源的包和元信息 (such as <a href="https://crates.io/">crates.io</a>) 会在这里.</p>
<ul>
<li>
<p><code>registry/index</code>
是一个git repo，它包含一个来源所有可用箱子的元信息 (versions, dependencies etc)。</p>
</li>
<li>
<p><code>registry/cache</code>
下载的依赖项就会存储在这里。箱子会被压缩成 gzip 格式，而后缀名是 <code>.crate</code>。</p>
</li>
<li>
<p><code>registry/src</code>
自然，如果一个 <code>.crate</code> 是被需要的, 就会解压缩，放到 <code>registry/src</code>，让<code>rustc</code>能够找到<code>.rs</code>文件</p>
</li>
</ul>
</li>
</ul>
<h2 id="caching-the-cargo-home-in-ci"><a class="header" href="#caching-the-cargo-home-in-ci">Caching the Cargo home in CI</a></h2>
<p>避免重复下载，所有的箱子依赖，在持续集成中，你可以缓存 <code>$CARGO_HOME</code> 目录。
然而，缓存整个目录非常低效率，因为它会包含两遍的下载文件。
比如：使用 <code>serde 1.0.92</code>，再缓存整个 <code>$CARGO_HOME</code>，那么实际上，我们是缓存了源代码两次：<code>registry/cache</code> 的 <code>serde-1.0.92.crate</code> ， 和<code>registry/src</code>的 <code>.rs</code> 。
自然，重复执行构建步骤，会让 CI 服务器花上些事件。 </p>
<p>所以答案是，只要缓存下面的就好：</p>
<ul>
<li><code>bin/</code></li>
<li><code>registry/index/</code></li>
<li><code>registry/cache/</code></li>
<li><code>git/db/</code></li>
</ul>
<h2 id="vendoring-all-dependencies-of-a-project"><a class="header" href="#vendoring-all-dependencies-of-a-project">Vendoring all dependencies of a project</a></h2>
<p>See the <a href="guide/../commands/cargo-vendor.html"><code>cargo vendor</code></a> subcommand.</p>
<h2 id="clearing-the-cache"><a class="header" href="#clearing-the-cache">Clearing the cache</a></h2>
<p>理论上，你可以对缓存执行许多操作，但</p>
<p>最好使用 <a href="https://crates.io/crates/cargo-cache">cargo-cache</a>，它提供简单的命令工具，清除缓存中的所选项，或展示大小。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="build-cache"><a class="header" href="#build-cache">Build cache</a></h2>
<p>Cargo 会将构建的产物，输出到 “target” 目录。默认来说，它会在你
<a href="guide/../appendix/glossary.html#workspace" title="&quot;workspace&quot; (glossary entry)"><em>workspace</em></a>目录下。要想改变，你可以设置
<code>CARGO_TARGET_DIR</code> <a href="guide/../reference/environment-variables.html">environment variable</a>, the <a href="guide/../reference/config.html#buildtarget-dir"><code>build.target-dir</code></a> config
value, or the <code>--target-dir</code> command-line flag。</p>
<p>目录的布局，取决于你是否有使用 <code>--target</code>去构建一个指定的平台。如果 <code>--target</code>没有指定，那么它会以运行环境的主机架构为蓝本。产物进到 target 目录, 而每个 <a href="guide/../reference/profiles.html">profile</a> 会存储在分开的子目录里:</p>
<table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody>
<tr><td><code style="white-space: nowrap">target/debug/</code></td><td>Contains output for the <code>dev</code> profile.</td></tr>
<tr><td><code style="white-space: nowrap">target/release/</code></td><td>Contains output for the <code>release</code> profile (with the <code>--release</code> option).</td></tr>
<tr><td><code style="white-space: nowrap">target/foo/</code></td><td>Contains build output for the <code>foo</code> profile (with the <code>--profile=foo</code> option).</td></tr>
</tbody></table>
<p>历史原因, <code>dev</code> 和 <code>test</code> profiles 存储在
<code>debug</code> 目录, 而 <code>release</code> and <code>bench</code> profiles 存储在
<code>release</code> 目录。 用户所定义的 profiles 则放在同名目录下。</p>
<p>如果配置了 <code>--target</code>, 产物输出的位置也是同名的:</p>
<table><thead><tr><th>目录</th><th>示例</th></tr></thead><tbody>
<tr><td><code style="white-space: nowrap">target/&lt;triple&gt;/debug/</code></td><td><code style="white-space: nowrap">target/thumbv7em-none-eabihf/debug/</code></td></tr>
<tr><td><code style="white-space: nowrap">target/&lt;triple&gt;/release/</code></td><td><code style="white-space: nowrap">target/thumbv7em-none-eabihf/release/</code></td></tr>
</tbody></table>
<blockquote>
<p><strong>注意了</strong>: 当 <code>--target</code>没有指定的时候, 有一个后果就是， Cargo will
会在 build scripts and proc macros，分享你的依赖项。<a href="guide/../reference/config.html#buildrustflags"><code>RUSTFLAGS</code></a>
也会在每次 <code>rustc</code> 调用分享。而使用了 <code>--target</code> ,
build scripts 和 proc macros 就会分离式构建 (主机架构
), 也不会分享 <code>RUSTFLAGS</code>。</p>
</blockquote>
<p>在 profile 目录里 (例如：<code>debug</code> 或 <code>release</code>), 产物会放到下面的目录：</p>
<table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody>
<tr><td><code style="white-space: nowrap">target/debug/</code></td><td>Contains the output of the package being built (the <a href="guide/../reference/cargo-targets.html#binaries">binary executables</a> and <a href="guide/../reference/cargo-targets.html#library">library targets</a>).</td></tr>
<tr><td><code style="white-space: nowrap">target/debug/examples/</code></td><td>Contains <a href="guide/../reference/cargo-targets.html#examples">example targets</a>.</td></tr>
</tbody></table>
<p>而一些命令的产物，也放到了各自的位置:</p>
<table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody>
<tr><td><code style="white-space: nowrap">target/doc/</code></td><td>Contains rustdoc documentation (<a href="guide/../commands/cargo-doc.html"><code>cargo doc</code></a>).</td></tr>
<tr><td><code style="white-space: nowrap">target/package/</code></td><td>Contains the output of the <a href="guide/../commands/cargo-package.html"><code>cargo package</code></a> and <a href="guide/../commands/cargo-publish.html"><code>cargo publish</code></a> commands.</td></tr>
</tbody></table>
<p>Cargo 还创建了一些构建过程，用得上的目录。这些，其实就可以说是 Cargo 内部资料了，且有改变的可能，如以下目录:</p>
<table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody>
<tr><td><code style="white-space: nowrap">target/debug/deps/</code></td><td>Dependencies and other artifacts.</td></tr>
<tr><td><code style="white-space: nowrap">target/debug/incremental/</code></td><td><code>rustc</code> <a href="guide/../reference/profiles.html#incremental">incremental output</a>, a cache used to speed up subsequent builds.</td></tr>
<tr><td><code style="white-space: nowrap">target/debug/build/</code></td><td>Output from <a href="guide/../reference/build-scripts.html">build scripts</a>.</td></tr>
</tbody></table>
<h3 id="dep-info-files"><a class="header" href="#dep-info-files">Dep-info files</a></h3>
<p>接下来，是“dep info“ 文件，它有着 <code>.d</code>
后缀。类 Makefile 语法，表明重建一个产物，所需的所有文件依赖。这些，可以让外部构建系统使用，这样他们可以知道 Cargo 是否需要重新执行。默认这些文件是绝对路径。相对路径，就看看
<a href="guide/../reference/config.html#builddep-info-basedir"><code>build.dep-info-basedir</code></a> 配置。</p>
<pre><code class="language-Makefile"># Example dep-info file found in target/debug/foo.d
/path/to/myproj/target/debug/foo: /path/to/myproj/src/lib.rs /path/to/myproj/src/main.rs
</code></pre>
<h3 id="shared-cache"><a class="header" href="#shared-cache">Shared cache</a></h3>
<p>第三方工具, <a href="https://github.com/mozilla/sccache">sccache</a>, 在不同 workspace 间，分享构建依赖</p>
<p>启用 <code>sccache</code>,</p>
<ul>
<li>安装 <code>cargo install sccache</code></li>
<li>设置<code>RUSTC_WRAPPER</code> 环境变量 to <code>sccache</code>。如果使用 bash，将 <code>export RUSTC_WRAPPER=sccache</code> 添加到
<code>.bashrc</code>。或者可以在 <a href="guide/../reference/config.html">Cargo
configuration</a>，设置 <a href="guide/../reference/config.html#buildrustc-wrapper"><code>build.rustc-wrapper</code></a>。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cargo-参考"><a class="header" href="#cargo-参考">Cargo 参考</a></h2>
<p>该参考文献涵盖了 Cargo 各个领域的细节.</p>
<ul>
<li><a href="reference/./specifying-dependencies.zh.html">指定依赖项</a>
<ul>
<li><a href="reference/overriding-dependencies.zh.html">覆盖依赖项</a></li>
</ul>
</li>
<li><a href="reference/./manifest.zh.html">清单格式</a>
<ul>
<li><a href="reference/cargo-targets.zh.html">Cargo Targets</a></li>
</ul>
</li>
<li><a href="reference/workspaces.zh.html">Workspaces</a></li>
<li><a href="reference/features.zh.html">Features</a>
<ul>
<li><a href="reference/features-examples.zh.html">Features 示例</a></li>
</ul>
</li>
<li><a href="reference/profiles.zh.html">Profiles</a></li>
<li><a href="reference/./config.zh.html">配置</a></li>
<li><a href="reference/./environment-variables.zh.html">环境变量</a></li>
<li><a href="reference/./build-scripts.zh.html">构建脚本</a>
<ul>
<li><a href="reference/build-script-examples.zh.html">Build Script 示例</a></li>
</ul>
</li>
<li><a href="reference/./publishing.zh.html">在 crates.io 上发布</a></li>
<li><a href="reference/./pkgid-spec.zh.html">包 ID 规格</a></li>
<li><a href="reference/./source-replacement.zh.html">来源更换</a></li>
<li><a href="reference/./external-tools.zh.html">外部工具</a></li>
<li><a href="reference/registries.zh.html">来源</a></li>
<li><a href="reference/resolver.zh.html">依赖项 解析</a></li>
<li><a href="reference/semver.zh.html">SemVer 格式版本的 兼容性</a></li>
<li><a href="reference/future-incompat-report.zh.html">Future 不兼容报告</a></li>
<li><a href="reference/./unstable.zh.html">不稳定的功能</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="依赖指定"><a class="header" href="#依赖指定">依赖指定</a></h2>
<p>您的箱子，可以依赖多个来源的库，如<a href="https://crates.io/">crates.io</a>，或是<code>git</code>的存储库或本地文件系统上的子目录。您还可以临时覆盖依赖项的位置 - 例如，便于能够测试，本地工作的错误修复。您可以为不同的平台，和或仅在开发期间，使用不同的依赖项。我们来看看如何做到这些.</p>
<h3 id="指定依赖来自-cratesio"><a class="header" href="#指定依赖来自-cratesio">指定依赖，来自 crates.io</a></h3>
<p>默认情况下，Cargo 是准备好，在<a href="https://crates.io/">crates.io</a>上查找依赖项。在这种情况下，只需要名称和版本字符串。在<a href="reference/../guide/index.zh.html">Cargo 指南</a>，我们选择了一个依赖项-<code>time</code>箱:</p>
<pre><code class="language-toml">[dependencies]
time = &quot;0.1.12&quot;
</code></pre>
<p>字符串<code>&quot;0.1.12&quot;</code>是一个版本。虽然看起来是一个规定的版本，但其实是范围性的版本，并且允许<a href="https://semver.org">SemVer</a>版本更新。看起来，此字符串中没有任何运算符，但它的解释方式与我们指定的<code>&quot;^0.1.12&quot;</code>方式相同，而<code>^</code>被称为跳脱条件.</p>
<h3 id="caret-requirements跳脱条件"><a class="header" href="#caret-requirements跳脱条件">Caret requirements(跳脱条件)</a></h3>
<p><strong>跳脱条件</strong>: 允许 SemVer 兼容更新指定版本。新的版本允许更新的条件是，不修改最左边的非零数字(无论<code>major，minor，patch</code>)。</p>
<p>在这种情况下，如果我们执行了<code>cargo update -p time</code>，Cargo 应该更新我们的<code>0.1.13</code>版本(如果是最新的<code>0.1.z</code>版本)，但不会更新为<code>0.2.0</code>。相反，我们若将版本字符串指定为<code>^1.0</code>，Cargo 应更新至<code>1.1</code>，如果是最新的<code>1.y</code>发布，但不是<code>2.0</code>版本。</p>
<p><code>0.0.x</code>并不与任何其他版本兼容.</p>
<p>以下是一些跳脱条件的例子以及它们允许的版本:</p>
<pre><code class="language-notrust">^1.2.3 := &gt;=1.2.3 &lt;2.0.0
^1.2 := &gt;=1.2.0 &lt;2.0.0
^1 := &gt;=1.0.0 &lt;2.0.0
^0.2.3 := &gt;=0.2.3 &lt;0.3.0
^0.2 := &gt;= 0.2.0 &lt; 0.3.0
^0.0.3 := &gt;=0.0.3 &lt;0.0.4
^0.0 := &gt;=0.0.0 &lt;0.1.0
^0 := &gt;=0.0.0 &lt;1.0.0
</code></pre>
<p>此兼容性约定与 SemVer，在处理 1.0.0 之前的版本方面有所不同。虽然 SemVer 说在 1.0.0 之前没有兼容性，但 Cargo 认为<code>0.x.y</code>是兼容<code>0.x.z</code>，这里<code>y ≥ z</code>和<code>x &gt; 0</code>。</p>
<p>更灵活地调整版本，是有可能，但何苦呢，是吧。</p>
<h3 id="caret-requirements"><a class="header" href="#caret-requirements">Caret requirements</a></h3>
<p><strong>Caret requirements</strong> 会是默认策略的一个备选项,
<code>^1.2.3</code> 其实就等于 <code>1.2.3</code>.</p>
<h3 id="tilde-条件"><a class="header" href="#tilde-条件">Tilde 条件</a></h3>
<p><strong>Tilde 条件</strong>指定具有更新最小版本的一定能力。如果指定 major 版本，minor 版本和 patch 程序版本，或仅指定 major 版本和 minor 版本，则仅允许 patch 程序级别更改。如果仅指定 major 版本，则允许进行 minor 和 patch 级别更改.</p>
<p><code>~1.2.3</code>是 Tilde 条件的一个例子.</p>
<pre><code class="language-notrust">~1.2.3 := &gt;=1.2.3 &lt;1.3.0
~1.2 := &gt;=1.2.0 &lt;1.3.0
~1 := &gt;=1.0.0 &lt;2.0.0
</code></pre>
<h3 id="通配符要求"><a class="header" href="#通配符要求">通配符要求</a></h3>
<p><strong>通配符条件</strong>允许任何通配符所在的版本.</p>
<p><code>*</code>，<code>1.*</code>和<code>1.2.*</code>是通配符条件的示例.</p>
<pre><code class="language-notrust">* := &gt;=0.0.0
1.* := &gt;=1.0.0 &lt;2.0.0
1.2.* := &gt;=1.2.0 &lt;1.3.0
</code></pre>
<h3 id="比较条件"><a class="header" href="#比较条件">比较条件</a></h3>
<p><strong>比较条件</strong>允许手动指定要依赖的版本范围或确切版本.</p>
<p>以下是比较条件的一些示例:</p>
<pre><code class="language-notrust">&gt;= 1.2.0
&gt; 1
&lt; 2
= 1.2.3
</code></pre>
<h3 id="多版本条件"><a class="header" href="#多版本条件">多版本条件</a></h3>
<p>多个版本，要求用逗号分隔，例如<code>&gt;= 1.2， &lt; 1.5</code>.</p>
<h3 id="其他来源的依赖项"><a class="header" href="#其他来源的依赖项">其他来源的依赖项</a></h3>
<p>要指定其他来源的依赖项，而不是 <a href="https://crates.io/">crates.io</a>, 第一步：配置<code>.cargo/config.toml</code> file. See the [registries
文档] 有更多信息。 <code>registry</code> 字段设置来源名称</p>
<pre><code class="language-toml">[dependencies]
some-crate = { version = &quot;1.0&quot;, registry = &quot;my-registry&quot; }
</code></pre>
<blockquote>
<p><strong>Note</strong>: <a href="https://crates.io/">crates.io</a> 是不允许有其他来源依赖项的项目，上传平台的。</p>
</blockquote>
<h3 id="依赖指定来自-git-存储库"><a class="header" href="#依赖指定来自-git-存储库">依赖指定，来自 <code>git</code> 存储库</a></h3>
<p>依赖于位于<code>git</code>存储库的库，您需要指定的最小信息，为一个<code>git</code>字段，其是存储库的<code>github</code>位置:</p>
<pre><code class="language-toml">[dependencies]
regex = { git = &quot;https://github.com/rust-lang/regex&quot; }
</code></pre>
<p>Cargo 将取得<code>git</code>，然后在这个位置找到一个存储库的请求箱子的<code>Cargo.toml</code>。方式是对<code>git</code>存储库里面的任何地方(不一定在根目录) - 例如，指定工作区中的成员包名称，和设置<code>git</code>到包含工作区的存储库).</p>
<p>由于我们尚未指定任何其他信息，因此 Cargo 假定我们打算使用最新的提交<code>master</code>分支，来构建我们的包。你可以将<code>git</code>字段和<code>rev</code>，<code>tag</code>， 还有<code>branch</code>，这些用于指定其他内容的字段组合起来。这是一个指定您希望在名为<code>next</code>分支上，使用最新提交的示例:</p>
<pre><code class="language-toml">[dependencies]
regex = { git = &quot;https://github.com/rust-lang/regex&quot;, branch = &quot;next&quot; }
</code></pre>
<p>其他的 <code>rev</code>。可以是 commit <code>rev = &quot;4c59b707&quot;</code>；远程存储库 <code>rev = &quot;refs/pull/493/head&quot;</code>。其中，各家 git 运营商，可能会有不同的名称方案。</p>
<p>一旦 <code>git</code> 依赖被添加, Cargo 锁住依赖最新的 commit。 不会自动更新到
。但可以手动<code>cargo update</code>更新。</p>
<p>私有的库，要看看<a href="reference/../appendix/git-authentication.zh.html">Git Authentication</a></p>
<blockquote>
<p><strong>Note</strong>: <a href="https://crates.io/">crates.io</a> 不允许夹杂 <code>git</code> 依赖
(<code>git</code> <a href="reference/specifying-dependencies.zh.html#development-dependencies">dev-dependencies</a> are ignored)。你也可以看看<a href="reference/specifying-dependencies.zh.html#multiple-locations">Multiple
locations</a> ，它有个备用的选择.</p>
</blockquote>
<h3 id="路径依赖指定"><a class="header" href="#路径依赖指定">路径，依赖指定</a></h3>
<p>随着时间的推移，我们来自<a href="reference/../guide/index.zh.html">指南</a>的<code>hello_world</code>示例已大幅增长! 它已经到了我们可能想分出一个单独的箱子供其他人使用的地步。为此，Cargo 支持<strong>路径依赖</strong>通常是位于一个存储库中的子箱。让我们开始在<code>hello_world</code>包的内部制作一个新的箱子:</p>
<pre><code class="language-console"># inside of hello_world/
$ cargo new hello_utils
</code></pre>
<p>这将创建一个新文件夹<code>hello_utils</code>，里面有一个<code>Cargo.toml</code>和<code>src</code>文件夹已准备好进行配置。为了告诉 Cargo，请打开<code>hello_world/Cargo.toml</code>，并添加你的<code>hello_utils</code>依赖:</p>
<pre><code class="language-toml">[dependencies]
hello_utils = { path = &quot;hello_utils&quot; }
</code></pre>
<p>这告诉 Cargo 我们依赖于一个叫做<code>hello_utils</code>的箱子，这能在<code>hello_utils</code>文件夹找到(相对于，写在<code>Cargo.toml</code>路径).</p>
<p>就是这样! 下一步<code>cargo build</code>将自动构建<code>hello_utils</code>，以及它自己的所有依赖项，其他人也可以开始使用它。但是，<a href="https://crates.io/">crates.io</a>不允许仅使用 <strong>路径指定依赖项</strong> 的包。如果我们想发布我们的<code>hello_world</code>箱子，我们需要发布一个版本<code>hello_utils</code>至<a href="https://crates.io">crates.io</a>，并在依赖项行中指定其版本:</p>
<pre><code class="language-toml">[dependencies]
hello_utils = { path = &quot;hello_utils&quot;, version = &quot;0.1.0&quot; }
</code></pre>
<h3 id="multiple-locations"><a class="header" href="#multiple-locations">Multiple locations</a></h3>
<p>可以指定，将来源版本与 <code>git</code> 或 <code>path</code>
位置结合起来。<code>git</code> 或 <code>path</code> 依赖会被本地使用 (这种情况下，
会针对本地的副本，检查 <code>version</code> ), 且当上传类似<a href="https://crates.io/">crates.io</a>平台时, 会使用来源的版本 。其他的组合则不被允许。例如：</p>
<pre><code class="language-toml">[dependencies]
# 本地就用 `my-bitflags` , 发布时，就是 version 1.0。
bitflags = { path = &quot;my-bitflags&quot;, version = &quot;1.0&quot; }

# 本地用 git,  发布时，就是 version 1.0。
smallvec = { git = &quot;https://github.com/servo/rust-smallvec&quot;, version = &quot;1.0&quot; }

# N.B. 注意 version 不正确, Cargo 编译会失败!
</code></pre>
<p>一个实际例子就是，在同一个工作区，你把一个库分进了多个包。本地版本，上传版本一手抓。与指定一个<a href="reference/overriding-dependencies.zh.html">override</a>类似, 但那个只有一个依赖声明可用。</p>
<h3 id="platform-specific-dependencies"><a class="header" href="#platform-specific-dependencies">Platform specific dependencies</a></h3>
<blockquote>
<p>平台决定依赖</p>
</blockquote>
<p>特定于平台的依赖项采用相同的格式，但在<code>target</code>下列出。像正常 Rust 一样的<code>#[cfg]</code>语法，将用于定义这些部分:</p>
<pre><code class="language-toml">[target.'cfg(windows)'.dependencies]
winhttp = &quot;0.4.0&quot;

[target.'cfg(unix)'.dependencies]
openssl = &quot;1.0.1&quot;

[target.'cfg(target_arch = &quot;x86&quot;)'.dependencies]
native = { path = &quot;native/i686&quot; }

[target.'cfg(target_arch = &quot;x86_64&quot;)'.dependencies]
native = { path = &quot;native/x86_64&quot; }
</code></pre>
<p>与 Rust 一样，这里的语法支持<code>not</code>，<code>any</code>，和<code>all</code>运算符组合各种 cfg 名称/值对。</p>
<p>如果想要知道那个 cfg targets 在你平台上可用，运行<code>rustc --print=cfg</code>。如果，你想知道其他平台的可用，比如64-bit Windows,
run <code>rustc --print=cfg --target=x86_64-pc-windows-msvc</code>.</p>
<p>不同 Rust, 你不能使用
<code>[target.'cfg(feature = &quot;fancy-feature&quot;)'.dependencies]</code> 要用 <a href="reference/features.zh.html">the <code>[features]</code> section</a>
:</p>
<pre><code class="language-toml">[dependencies]
foo = { version = &quot;1.0&quot;, optional = true }
bar = { version = &quot;1.0&quot;, optional = true }

[features]
fancy-feature = [&quot;foo&quot;, &quot;bar&quot;]
</code></pre>
<p>同样作用在 <code>cfg(debug_assertions)</code>, <code>cfg(test)</code> 个 <code>cfg(proc_macro)</code>.
这些值都不会工作，<code>rustc --print=cfg</code>会有默认值返回。
现在，通过配置值，添加依赖的方式还没有。</p>
<p>除了<code>#[cfg]</code>语法，Cargo 还支持列出依赖关系适用的完整目标:</p>
<pre><code class="language-toml">[target.x86_64-pc-windows-gnu.dependencies]
winhttp = &quot;0.4.0&quot;

[target.i686-unknown-linux-gnu.dependencies]
openssl = &quot;1.0.1&quot;
</code></pre>
<h4 id="自定义的-target-规范"><a class="header" href="#自定义的-target-规范">自定义的 target 规范</a></h4>
<p>如果你使用一个自定义的 target 规范 (such as <code>--target foo/bar.json</code>), 使用时，不要加上<code>.json</code> 后缀:</p>
<pre><code class="language-toml">[target.bar.dependencies]
winhttp = &quot;0.4.0&quot;

[target.my-special-i686-platform.dependencies]
openssl = &quot;1.0.1&quot;
native = { path = &quot;native/i686&quot; }
</code></pre>
<blockquote>
<p><strong>Note</strong>: 这功能是还没有在 stabel channel 落户。</p>
</blockquote>
<h3 id="development-dependencies"><a class="header" href="#development-dependencies">Development dependencies</a></h3>
<blockquote>
<p>开发(Dev)依赖项</p>
</blockquote>
<p>你可以添加一个<code>[dev-dependencies]</code>表格到<code>Cargo.toml</code>，其格式相当于<code>[dependencies]</code>:</p>
<pre><code class="language-toml">[dev-dependencies]
tempdir = &quot;0.3&quot;
</code></pre>
<p>编译用于构建的包时，不会使用 Dev 依赖，但用于编译测试，示例和基准。</p>
<p>这些依赖关系是<em>不会</em>传播到依赖于此包的其他包.</p>
<p>您还可以让<code>dev-dependencies</code>具有特定目标的开发依赖项，而不是<code>dependencies</code>标题。例如:</p>
<pre><code class="language-toml">[target.'cfg(unix)'.dev-dependencies]
mio = &quot;0.0.1&quot;
</code></pre>
<blockquote>
<p><strong>Note</strong>: 当一个包被发布后, 只有 dev-dependencies 指定的
<code>version</code> 会被放进发布的箱子。更多情况下，
dev-dependencies 仅在发布时有用, 但些许用户 (like OS
packagers) 在箱子运行一些测试啊，所以,  <code>version</code> 能给多点信息，也挺好的。</p>
</blockquote>
<h3 id="build-dependencies"><a class="header" href="#build-dependencies">Build dependencies</a></h3>
<blockquote>
<p>构建 依赖项</p>
</blockquote>
<p>您可以在构建脚本中使用，依赖其他基于 Cargo 的箱。依赖关系是由清单的<code>build-dependencies</code>部分定义:</p>
<pre><code class="language-toml">[build-dependencies]
cc = &quot;1.0.3&quot;
</code></pre>
<p>构建脚本<strong>并不是</strong>有权访问，<code>dependencies</code>或<code>dev-dependencies</code>部分，列出的依赖项。除非也在<code>dependencies</code>部分下面列出，否则构建依赖项同样不可用于包本身。包本身及其构建脚本是分开构建的，因此它们的依赖关系不重合。通过对依赖项进行独立化，使 Cargo 更简单，更清洁。</p>
<h3 id="choosing-features"><a class="header" href="#choosing-features">Choosing features</a></h3>
<blockquote>
<p>选择 特性</p>
</blockquote>
<p>如果您依赖的包提供条件特性，您可以指定使用哪个:</p>
<pre><code class="language-toml">[dependencies.awesome]
version = &quot;1.3.5&quot;
default-features = false # 不会包括默认特性， 和 任君选
                         # 单特性
features = [&quot;secure-password&quot;, &quot;civet&quot;]
</code></pre>
<p>有关 features 的更多信息，请参阅<a href="reference/./manifest.zh.html#the-features-section">清单文档</a>.</p>
<h3 id="renaming-dependencies-in-cargotoml"><a class="header" href="#renaming-dependencies-in-cargotoml">Renaming dependencies in <code>Cargo.toml</code></a></h3>
<blockquote>
<p>在<code>Cargo.toml</code>中的重命名依赖项</p>
</blockquote>
<p>写<code>Cargo.toml</code>的<code>[dependencies]</code>部分的时候，您为依赖项编写的字段通常与您在代码中导入的包的名称相匹配。但是，对于某些项目，您可能希望在代码中引用具有不同名称的包，而不管它是如何在 crates.io 上发布的。例如，您可能希望:</p>
<ul>
<li>避免在 Rust 代码常用<code>use foo as bar</code>.</li>
<li>依赖箱子的多个版本.</li>
<li>依赖来自不同注册表管理机构的同名箱.</li>
</ul>
<p>为了支持这个 ，Cargo 在<code>[dependencies]</code>部分使用 一个<code>package</code>字段，决定应该依赖哪个包:</p>
<pre><code class="language-toml">[package]
name = &quot;mypackage&quot;
version = &quot;0.0.1&quot;

[dependencies]
foo = &quot;0.1&quot;
bar = { git = &quot;https://github.com/example/project&quot;, package = &quot;foo&quot; }
baz = { version = &quot;0.1&quot;, registry = &quot;custom&quot;, package = &quot;foo&quot; }
</code></pre>
<p>在此示例中，Rust 代码中现在提供了三个包:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate foo; // crates.io
extern crate bar; // git repository
extern crate baz; // registry `custom`
<span class="boring">}
</span></code></pre></pre>
<p>所有这三个箱的包名称在他们自己<code>Cargo.toml</code>，都是<code>foo</code>，所以我们明确地告知 Cargo ，使用的是我们想要的<code>package</code>字段(如 package = “foo“包名，即我们在本地调用其他东西)。如果没有指定<code>package</code>，则默认为所请求的依赖项的名称。</p>
<p>请注意，如果您有一个可选的(optional)依赖项，例如:</p>
<pre><code class="language-toml">[dependencies]
bar = { version = &quot;0.1&quot;, package = 'foo', optional = true }
</code></pre>
<p>你依赖于一个<code>foo</code>箱子，其来自 crates.io，但你箱子有一个<code>bar</code>特性，取代了一个<code>foo</code>特性。也就是说，在重命名时，特性的名称拿掉了依赖项的名称，而不是包名称。</p>
<p>启用传递依赖项的工作方式类似，例如我们可以将以下内容，添加到上面的清单中:</p>
<pre><code class="language-toml">[features]
log-debug = ['bar/log-debug'] # 使用 'foo/log-debug' 就会出现一个错误!
</code></pre>
<script>
(function() {
    var fragments = {
        "#overriding-dependencies": "overriding-dependencies.html",
        "#testing-a-bugfix": "overriding-dependencies.html#testing-a-bugfix",
        "#working-with-an-unpublished-minor-version": "overriding-dependencies.html#working-with-an-unpublished-minor-version",
        "#overriding-repository-url": "overriding-dependencies.html#overriding-repository-url",
        "#prepublishing-a-breaking-change": "overriding-dependencies.html#prepublishing-a-breaking-change",
        "#overriding-with-local-dependencies": "overriding-dependencies.html#paths-overrides",
    };
    var target = fragments[window.location.hash];
    if (target) {
        var url = window.location.toString();
        var base = url.substring(0, url.lastIndexOf('/'));
        window.location.replace(base + "/" + target);
    }
})();
</script>
<div style="break-before: page; page-break-before: always;"></div><h3 id="依赖覆盖"><a class="header" href="#依赖覆盖">依赖覆盖</a></h3>
<p>许多场景，我们会想去，覆盖一个依赖，或以其他方式改变某些依赖关系。然而，他们中的大多数都可以归结为，将箱子发布到 crates.io 之前，使用箱子的(覆盖依赖)能力。例如:</p>
<ul>
<li>您编写的 <code>crate</code> ，也用于您编写的更大应用程序中，并且您希望在更大应用程序内，测试你这个<code>crate</code>的 bug fix 情况。</li>
<li>不是你编写的上游包，现在其 git 存储库的主分支上，有一个新功能或 bug fix ，您要测试它。</li>
<li>您即将发布新版本的 major 版本，但您希望在整个软件包中，进行集成测试，以确保新的主要版本能够正常运行.</li>
<li>您已经为上游的软件包，提交了一个针对您找到的 bug fix，但是您希望立即让您的应用程序，依赖此程序包的 fixed 版本，以避免 bug fix 程序被拒绝合并.</li>
</ul>
<p>这些场景目前都是通过[<code>[patch]</code> 清单部分 ][#this-patch-section]解决的</p>
<ul>
<li>用例
<ul>
<li><a href="reference/overriding-dependencies.zh.html#testing-a-bugfix">Testing a bugfix{测试一个修复}</a></li>
<li><a href="reference/overriding-dependencies.zh.html#working-with-an-unpublished-minor-version">Working with an unpublished minor version{使用一个未发布的 minor 版本}</a>
<ul>
<li><a href="reference/overriding-dependencies.zh.html#overriding-repository-url">Overriding repository URL{覆盖存储库 URL}</a></li>
</ul>
</li>
<li><a href="reference/overriding-dependencies.zh.html#prepublishing-a-breaking-change">Prepublishing a breaking change{预发布一个重大更新}</a></li>
<li><a href="reference/overriding-dependencies.zh.html#using-patch-with-multiple-versions">Using <code>[patch]</code> with multiple versions{多版本}</a></li>
</ul>
</li>
<li>Reference
<ul>
<li><a href="reference/overriding-dependencies.zh.html#the-patch-section"><code>[patch]</code> 部分</a></li>
<li><a href="reference/overriding-dependencies.zh.html#the-replace-section"><code>[replace]</code> 部分</a></li>
<li><a href="reference/overriding-dependencies.zh.html#paths-overrides"><code>paths</code> 覆盖</a></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>注意</strong>: 还可以看看 <a href="reference/specifying-dependencies.zh.html#multiple-locations">多来源</a>，去指定一个依赖，覆盖单个依赖来源。</p>
</blockquote>
<h3 id="testing-a-bugfix"><a class="header" href="#testing-a-bugfix">Testing a bugfix</a></h3>
<p>假设你正在使用<a href="https://crates.io/crates/uuid"><code>uuid</code> crate</a>，但是当你正在研究它时，你会发现一个错误。但是，你很有进取心，所以你决定尝试修复这个 bug! 最初你的清单看起来像:</p>
<pre><code class="language-toml">[package]
name = &quot;my-library&quot;
version = &quot;0.1.0&quot;

[dependencies]
uuid = &quot;1.0&quot;
</code></pre>
<p>我们要做的第一件事是克隆<a href="https://github.com/rust-lang-nursery/uuid"><code>uuid</code>存储库</a>，到本地:</p>
<pre><code class="language-console">$ git clone https://github.com/uuid-rs/uuid
</code></pre>
<p>接下来，我们将编辑<code>my-library</code>-Cargo.toml，为:</p>
<pre><code class="language-toml">[patch.crates-io]
uuid = { path = &quot;../path/to/uuid&quot; }
</code></pre>
<p>在这里，我们宣布我们是*修补(patch)*来源<code>crates-io</code>，其有一个新的依赖，这将有效地添加本地版本的<code>uuid</code>到 crates.io 注册表，指向本地包。</p>
<p>接下来，我们需要确保我们的锁(lock)文件已更新为，新版本的<code>uuid</code>。自此，我们的包使用本地的副本，而不是 crates.io 中的副本。<code>[patch]</code>工作方式是，它将从<code>../path/to/uuid</code>加载依赖，然后每当 crates.io 查询<code>uuid</code>的版本时，它 <em>也</em> 会返回本地版本.</p>
<p>这意味着，本地签出的版本号很重要，会影响是否使用该 patch。我们的清单宣布<code>uuid = &quot;1.0&quot;</code>，这意味着，我们只会解析<code>&gt;= 1.0.0， &lt; 2.0.0</code>，还有 Cargo 的贪婪解析算法，也意味着我们将解析到该范围内的最大版本。通常情况下，这并不重要，因为 git 存储库的版本已经比之更大，或与 crates.io 上发布的最大版本相匹配，但重要的是，要记住这一点!</p>
<p>无论如何，现在需要做的就是:</p>
<pre><code class="language-console">$ cargo build
   Compiling uuid v1.0.0 (.../uuid)
   Compiling my-library v0.1.0 (.../my-library)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>就是这样! 您现在正在使用本地版本<code>uuid</code>，来构建你的程序(注意，构建输出中，括号中的路径)。如果，您没有看到构建本地路径版本，那么您可能需要运行<code>cargo update -p uuid --precise $version</code>，这里<code>$version</code>是本地签出版本的<code>uuid</code>副本。</p>
<p>一旦，你修复了你最初发现的错误，你要做的下一件事就是将其作为拉取请求，提交给<code>uuid</code>箱子本身。一旦，你完成了这部分，你也可以更新下<code>[patch]</code>部分。<code>[patch]</code>里面的内容列表就像是<code>[dependencies]</code>部分，所以，一旦你的拉动请求合并，你就可以改变你的<code>path</code>依赖:</p>
<pre><code class="language-toml">[patch.crates-io]
uuid = { git = 'https://github.com/rust-lang-nursery/uuid' }
</code></pre>
<h3 id="working-with-an-unpublished-minor-version"><a class="header" href="#working-with-an-unpublished-minor-version">Working with an unpublished minor version</a></h3>
<blockquote>
<p>与 一个未发布的次要版本，一起工作</p>
</blockquote>
<p>现在，让我们稍微改变一下，从 bug fix ，变成要添加功能。在努力<code>my-library</code>的同时，你发现需要<code>uuid</code>箱的一个全新的功能。而您已实现<code>uuid</code>此功能，并在<code>[patch]</code>上面进行本地测试，并提交了拉取请求。让我们来看看在实际发布之前，你如何继续使用和测试它。</p>
<p>我们也说当前版本的<code>uuid</code>，在 crates.io 上是<code>1.0.0</code>版本，但从提交那时起，git 存储库的主分支已更新为<code>1.0.1</code>。此分支包含您之前提交的新功能。要使用此存储库，我们将编辑我们的<code>Cargo.toml</code>，看起来像</p>
<pre><code class="language-toml">[package]
name = &quot;my-library&quot;
version = &quot;0.1.0&quot;

[dependencies]
uuid = &quot;1.0.1&quot;

[patch.crates-io]
uuid = { git = 'https://github.com/uuid-rs/uuid' }
</code></pre>
<p>注意，我们对本地<code>uuid</code>的依赖已更新为<code>1.0.1</code>，因为，这是我们在箱子发布后实际需要的东西。但是，这个版本在 crates.io 上不存在，所以，我们提供了<code>[patch]</code>部分，来特指。</p>
<p>现在，当我们的库被构建时，它将<code>uuid</code>从 git 存储库取出，并解析到存储库中的 1.0.1 ，而不是尝试从 crates.io 下载版本。一旦 1.0.1 发布在 crates.io 上，那<code>[patch]</code>部分就可以删除了。</p>
<p>值得注意的是，<code>[patch]</code>是<em>连带关系</em>。假设您在更大的包中，使用<code>my-library</code>，例如:</p>
<pre><code class="language-toml">[package]
name = &quot;my-binary&quot;
version = &quot;0.1.0&quot;

[dependencies]
my-library = { git = 'https://example.com/git/my-library' }
uuid = &quot;1.0&quot;

[patch.crates-io]
uuid = { git = 'https://github.com/uuid-rs/uuid' }
</code></pre>
<p>记住这<code>[patch]</code>是 <em>连带关系</em>，但只能在<strong>顶层</strong>，所以，我们的<code>my-library</code>用户不得不重复写入<code>[patch]</code>部分(如有必要的话)。不过，在这里，新的<code>uuid</code>箱子会适用对<code>uuid</code>的依赖和<code>my-library -&gt; uuid</code>的依赖，两个依赖<strong>都</strong>指定了。该<code>uuid</code>箱 将被解析为整个 crate 关系图 的 1.0.1 版本，并且它是将从 git 存储库中 pull 而来。</p>
<h4 id="overriding-repository-url"><a class="header" href="#overriding-repository-url">Overriding repository URL</a></h4>
<blockquote>
<p>覆盖 注册表 URL</p>
</blockquote>
<p>如果要覆盖的依赖项，不是加载自<code>crates.io</code>，你将不得不改变一下你的<code>[patch]</code>使用方式:</p>
<pre><code class="language-toml">[patch.&quot;https://github.com/your/repository&quot;]
my-library = { path = &quot;../my-library/path&quot; }
</code></pre>
<p>就是这样!</p>
<h3 id="prepublishing-a-breaking-change"><a class="header" href="#prepublishing-a-breaking-change">Prepublishing a breaking change</a></h3>
<blockquote>
<p>预发布一个重要变化</p>
</blockquote>
<p>让我们来看看。若要使用一个新的主要版本的箱子，其通常伴随着重大变化。而要坚持使用我们以前的箱，这意味着，我们将创建 2.0.0 版本<code>uuid</code>箱。在我们提交了所有上游更改后，我们可以更新我们的<code>my-library</code>清单，看起来像:</p>
<pre><code class="language-toml">[dependencies]
uuid = &quot;2.0&quot;

[patch.crates-io]
uuid = { git = &quot;https://github.com/rust-lang-nursery/uuid&quot;, branch = &quot;2.0.0&quot; }
</code></pre>
<p>就是这样! 与前面的示例一样，2.0.0 版本实际上，并不存在于 crates.io 上，但我们仍然可以通过<code>[patch]</code>部分使用。作为一个思考练习，让我们再看看<code>my-binary</code>(被使用)的再次表现:</p>
<pre><code class="language-toml">[package]
name = &quot;my-binary&quot;
version = &quot;0.1.0&quot;

[dependencies]
my-library = { git = 'https://example.com/git/my-library' }
uuid = &quot;1.0&quot;

[patch.crates-io]
uuid = { git = 'https://github.com/uuid-rs/uuid', branch = '2.0.0' }
</code></pre>
<p>请注意，这实际上，将解析为两个版本的<code>uuid</code>箱。该<code>my-binary</code>箱子将继续使用 1.x.y 系列的<code>uuid</code>箱子，但是<code>my-library</code>箱 会使用 2.0.0 版本<code>uuid</code>。这将允许您通过依赖关系图逐步推出对包的更改，而无需一次性更新所有内容。</p>
<h3 id="using-patch-with-multiple-versions"><a class="header" href="#using-patch-with-multiple-versions">Using <code>[patch]</code> with multiple versions</a></h3>
<p>你能使用同一个箱子的不同版本。是的， <code>package</code> 能帮它们重命名。例如， <code>serde</code> 的<code>1.*</code> 有个问题修复，而<code>2.0.0</code>则是，使用它的原型。那么，我们的配置如下：</p>
<pre><code class="language-toml">[patch.crates-io]
serde = { git = 'https://github.com/serde-rs/serde' }
serde2 = { git = 'https://github.com/example/serde', package = 'serde', branch = 'v2' }
</code></pre>
<p>The first <code>serde = ...</code> 指明从 git 存储库中，拿到 <code>1.*</code>版本 (修复版) and the second <code>serde2 = ...</code> 指明从 git 存储库的 <code>v2</code> 分支中， 拿到<code>serde</code> package。我们假设，
这个分支上的 <code>Cargo.toml</code> 是为 <code>2.0.0</code> 的。</p>
<p>注意： <code>serde2</code>上的<code>package</code> 其实是忽视的。只是便于我们好区分。</p>
<h3 id="the-patch-section"><a class="header" href="#the-patch-section">The <code>[patch]</code> section</a></h3>
<p><code>Cargo.toml</code>的<code>[patch]</code> 覆盖依赖。语法上，与
<a href="reference/specifying-dependencies.zh.html"><code>[dependencies]</code></a> 接近:</p>
<pre><code class="language-toml">[patch.crates-io]
foo = { git = 'https://github.com/example/foo' }
bar = { path = 'my/local/bar' }

[dependencies.baz]
git = 'https://github.com/example/baz'

[patch.'https://github.com/example/baz']
baz = { git = 'https://github.com/example/patched-baz', branch = 'my-branch' }
</code></pre>
<p>The <code>[patch]</code> 由类似 dependencies 的子表格组成。
<code>[patch]</code>每个 key 之后，跟着 修补的 URL, 或是存储库的名字。 其中 <code>crates-io</code> 会用来覆盖覆盖默认的
<a href="https://crates.io/">crates.io</a>。 第一个 <code>[patch]</code> 就展示了覆盖
<a href="https://crates.io/">crates.io</a>, 而第二个 <code>[patch]</code> 展示了覆盖 git。</p>
<p>在这些表格的格式规范，就与<code>[dependencies]</code>的类似。上面的示例，会对修改 <code>crates-io</code> 的来源 (e.g.
crates.io itself) ，也就是 <code>foo</code> 和 <code>bar</code> 。 还会修改 <code>https://github.com/example/baz</code> 来源，将其变为 <code>my-branch</code></p>
<p>来源，可以指向不存在的版本, 自然也指向存在的版本。如果，来源是指向自己的某个版本，就会被替换。</p>
<h3 id="the-replace-section"><a class="header" href="#the-replace-section">The <code>[replace]</code> section</a></h3>
<blockquote>
<p><strong>Note</strong>: <code>[replace]</code> is deprecated. You should use the
<a href="reference/overriding-dependencies.zh.html#the-patch-section"><code>[patch]</code></a> table instead.</p>
</blockquote>
<p>This section of Cargo.toml can be used to override dependencies with other
copies. The syntax is similar to the <code>[dependencies]</code> section:</p>
<pre><code class="language-toml">[replace]
&quot;foo:0.1.0&quot; = { git = 'https://github.com/example/foo' }
&quot;bar:1.0.2&quot; = { path = 'my/local/bar' }
</code></pre>
<p><code>[replace]</code> 下的每个 key 都是 <a href="reference/pkgid-spec.zh.html">package ID
规范的</a>，可以任意替换 (版本是写的)。也与 <code>[dependencies]</code>的定义类似。除了，你还可以不指定 feature。注意，名称与版本都需要，才能覆盖 (e.g., git or a local path).</p>
<h3 id="paths-overrides"><a class="header" href="#paths-overrides"><code>paths</code> overrides</a></h3>
<blockquote>
<p>覆盖 本地依赖项</p>
</blockquote>
<p>有时你只是暂时在一个箱子上工作，而你不想修改<code>Cargo.toml</code>中像上诉的<code>[patch]</code>部分。对于这个用例，Cargo 提供了更为有限的覆盖版本<strong>路径覆盖</strong>.</p>
<p>路径覆盖是通过<code>.cargo/config</code>指定，而不是<code>Cargo.toml</code>，你可以寻找<a href="reference/./config.zh.html">有关此配置的更多文档</a>。在<code>.cargo/config</code>内，你要指定的是一个名为<code>paths</code>字段:</p>
<pre><code class="language-toml">paths = [&quot;/path/to/uuid&quot;]
</code></pre>
<p>该数组应填充包含<code>Cargo.toml</code>的目录。在这种情况下，我们只是添加<code>uuid</code>，所以它将是唯一一个被覆盖的。此路径可以是包含该路径的绝对路径或相对<code>.cargo</code>文件夹的路径.</p>
<p>路径覆盖，比<code>[patch]</code>部分的限制更严格，但是，路径覆盖不能改变依赖图的结构。而当使用路径替换时，前一组依赖项必须完全匹配新的<code>Cargo.toml</code>规格。如此，就意味着路径覆盖不能用于向箱添加依赖项的测试，而换成<code>[patch]</code>在该种情况下使用。因此，路径覆盖的使用，通常会与快速 bug fix 分隔开来，而不是大更新分开。</p>
<p>注意:使用本地配置覆盖路径，仅适用于已发布到<a href="https://crates.io/">crates.io</a>的包。您无法使用此功能告诉 Cargo 如何查找本地未发布的箱。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="the-manifest-format"><a class="header" href="#the-manifest-format">The Manifest Format</a></h2>
<blockquote>
<p>清单格式</p>
</blockquote>
<p>每个包的这个<code>Cargo.toml</code>文件称为<em>清单</em>. 每个清单文件由一个或多个部分(表格)组成.</p>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<ul>
<li><a href="reference/manifest.zh.html#the-package-section"><code>[package]</code> 部分</a></li>
<li><a href="reference/manifest.zh.html#dependency-sections">依赖项 部分</a></li>
<li><a href="reference/manifest.zh.html#the-profile-sections"><code>[profile.*]</code> 部分</a></li>
<li><a href="reference/manifest.zh.html#the-features-section"><code>[features]</code> 部分</a></li>
<li><a href="reference/manifest.zh.html#the-workspace-section"><code>[workspace]</code> 部分</a></li>
<li><a href="reference/manifest.zh.html#the-project-layout">项目布局</a></li>
<li><a href="reference/manifest.zh.html#examples">Rust 示例</a></li>
<li><a href="reference/manifest.zh.html#tests">Rust 测试</a></li>
<li><a href="reference/manifest.zh.html#configuring-a-target">配置一个 target</a></li>
<li><a href="reference/manifest.zh.html#the-patch-section"><code>[patch]</code> 部分</a></li>
<li><a href="reference/manifest.zh.html#the-replace-section"><code>[replace]</code> 部分</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h3 id="the-package-section"><a class="header" href="#the-package-section">The <code>[package]</code> section</a></h3>
<blockquote>
<p><code>[package]</code>部分</p>
</blockquote>
<p><code>Cargo.toml</code>的第一部分是<code>[package]</code>.</p>
<pre><code class="language-toml">[package]
name = &quot;hello_world&quot; # the name of the package
version = &quot;0.1.0&quot;    # the current version, obeying semver
authors = [&quot;Alice &lt;a@example.com&gt;&quot;, &quot;Bob &lt;b@example.com&gt;&quot;]
</code></pre>
<p>所有这三个字段都是必要性的.</p>
<h4 id="the-version-field"><a class="header" href="#the-version-field">The <code>version</code> field</a></h4>
<blockquote>
<p><code>version</code> 字段</p>
</blockquote>
<p>Cargo 烘烤的概念是<a href="http://semver.org/">语义版本控制</a>，所以确保你遵循一些基本规则:</p>
<ul>
<li>在您达到 1.0.0 之前，任何事情都会发生，但是如果您进行了重大变化的更新，则增加次要(minor)版本。在 Rust 语言中，重大变化包括，向结构添加字段，或增加变量到枚举。</li>
<li>在 1.0.0 之后，只在增加主要(major)版本时进行重大变化。不要破坏建筑.</li>
<li>在 1.0.0 之后，不要在补丁级别(patch)的版本添加任何新的公共 API(没有任何新的<code>pub</code>)。如果添加<code>pub</code>结构、特性、字段、类型、函数、方法或其他任何东东，则总是增加次要版本。</li>
<li>使用具有三个数字部分的版本号，如 1.0.0，而不是 1.0。</li>
</ul>
<h4 id="the-edition-field-optional"><a class="header" href="#the-edition-field-optional">The <code>edition</code> field (optional)</a></h4>
<blockquote>
<p><code>edition</code> 字段 (可选)</p>
</blockquote>
<p>您可以在<code>Cargo.toml</code>中的<code>edition</code>字段，选择一个特定的 Rust 版本，用于您的包。 如果没有指定版本,它将默认为 2015。</p>
<pre><code class="language-toml">[package]
# ...
edition = '2018'
</code></pre>
<p>这个<code>edition</code>字段会影响到您的包编译的版本。若是通过<code>cargo new</code>得来的项目，Cargo 将始终让<code>edition</code>字段设置为最新版本。设置<code>[package]</code>下的<code>edition</code>字段将影响包中的所有目标/箱，包括测试套件、基准、二进制文件、示例等。</p>
<h4 id="the-build-field-optional"><a class="header" href="#the-build-field-optional">The <code>build</code> field (optional)</a></h4>
<blockquote>
<p><code>build</code> 字段 (可选)</p>
</blockquote>
<p>此字段指定包根目录中的文件，该文件是<a href="reference/./build-scripts.zh.html">构建脚本</a>，用于生成本机代码。可以在构建脚本<a href="reference/./build-scripts.zh.html">指导</a>中找到更多信息..</p>
<pre><code class="language-toml">[package]
# ...
build = &quot;build.rs&quot;
</code></pre>
<h4 id="the-links-field-optional"><a class="header" href="#the-links-field-optional">The <code>links</code> field (optional)</a></h4>
<blockquote>
<p><code>links</code> 字段 (可选)</p>
</blockquote>
<p>此字段指定，要链接到的本机库名，更多信息可以在构建脚本指南的<a href="reference/./build-scripts.zh.html#the-links-manifest-key"><code>links</code></a>部分.</p>
<pre><code class="language-toml">[package]
# ...
links = &quot;foo&quot;
build = &quot;build.rs&quot;
</code></pre>
<h4 id="the-documentation-field-optional"><a class="header" href="#the-documentation-field-optional">The <code>documentation</code> field (optional)</a></h4>
<blockquote>
<p><code>documentation</code> 字段 (可选)</p>
</blockquote>
<p>此字段指定托管箱(crate)文档的网站的 URL。如果清单文件中没有指定 URL，<a href="https://crates.io/">crates.io</a>自动将你的箱子连接到相应的箱子的<a href="https://docs.rs/">docs.rs</a>页.</p>
<p>来自特定主机的文档链接被列入黑名单。如果已知主机不承载文档，并且可能具有恶意意图，例如广告跟踪网络，则主机被添加到黑名单中。下列主机的 URL 就被列入黑名单:</p>
<ul>
<li>rust-ci.org</li>
</ul>
<p>来自黑名单主机的文档 URL 将不会出现在 crates.io 上，并且可能被 docs.rs 链接替换。</p>
<h4 id="the-exclude-and-include-fields-optional"><a class="header" href="#the-exclude-and-include-fields-optional">The <code>exclude</code> and <code>include</code> fields (optional)</a></h4>
<blockquote>
<p><code>exclude</code> 和 <code>include</code> 字段 (可选)</p>
</blockquote>
<p>出于打包和重建包的目的，您可以显式地指定一组<a href="https://docs.rs/glob/0.2.11/glob/struct.Pattern.md">globs</a>模式，匹配项应被忽略或包含。如<code>exclude</code>字段标识了在发布包时，不包括的一组文件，以及检测何时重建包时，应该忽略的文件，而<code>include</code>就是显式指定一定包含的文件。</p>
<p>如果一个 VCS 被用于一个包，则<code>exclude</code>字段将被植入 VCS 的忽略设置(例如 Git 的<code>.gitignore</code>)。</p>
<pre><code class="language-toml">[package]
# ...
exclude = [&quot;build/**/*.o&quot;, &quot;doc/**/*.md&quot;]
</code></pre>
<pre><code class="language-toml">[package]
# ...
include = [&quot;src/**/*&quot;, &quot;Cargo.toml&quot;]
</code></pre>
<p>选项是相互排斥的: <code>include</code>设置覆盖<code>exclude</code>。 注意<code>include</code>必须是文件的详尽列表，否则可能不包括必要的源文件。</p>
<h4 id="migrating-to-gitignore-like-pattern-matching"><a class="header" href="#migrating-to-gitignore-like-pattern-matching">Migrating to <code>gitignore</code>-like pattern matching</a></h4>
<blockquote>
<p>转移成 类<code>gitignore</code> 模式匹配</p>
</blockquote>
<p>这些配置的当前解释实现都基于 UNIX Globs，如<a href="https://crates.io/crates/glob"><code>glob</code>箱</a>。 若是我们想要 Cargo 的<code>include</code>和<code>exclude</code>尽可能配置为类似于<code>gitignore</code>。可看看<a href="https://git-scm.com/docs/gitignore">这个<code>gitignore</code>规范</a>，其也是基于 Globs 的，但是还有许多其他的特性，这些特性使模式编写更容易，控制也更多。因此，我们正在迁移这些配置规则的解释实现，以使用<a href="https://crates.io/crates/ignore"><code>ignore</code>箱</a>，并认真对待<code>gitignore</code>文件的每一条行规则。见<a href="https://github.com/rust-lang/cargo/issues/4268">跟踪问题</a>有关迁移的更多细节。</p>
<h4 id="the-publish-field-optional"><a class="header" href="#the-publish-field-optional">The <code>publish</code> field (optional)</a></h4>
<blockquote>
<p><code>publish</code> 字段 (可选)</p>
</blockquote>
<p>这个<code>publish</code>字段通过错误，防止将包(crate)，发布到包注册中心(如<em>crates.io</em>)。</p>
<pre><code class="language-toml">[package]
# ...
publish = false
</code></pre>
<h4 id="the-workspace-field-optional"><a class="header" href="#the-workspace-field-optional">The <code>workspace</code> field (optional)</a></h4>
<blockquote>
<p><code>workspace</code> 字段 (可选)</p>
</blockquote>
<p>这个<code>workspace</code>字段可用于配置此包将属于的工作区。如果没有指定，这将被推断为文件系统中第一个 Cargo.toml 的<code>[workspace]</code>。</p>
<pre><code class="language-toml">[package]
# ...
workspace = &quot;path/to/workspace/root&quot;
</code></pre>
<p>有关更多信息，请参见下面的工作区(workspace)表格的文档.</p>
<h4 id="package-metadata"><a class="header" href="#package-metadata">Package metadata</a></h4>
<blockquote>
<p>包 元信息</p>
</blockquote>
<p><code>[package]</code>部分会接受许多可选的元数据字段:</p>
<pre><code class="language-toml">[package]
# ...

# 关于包的简短介绍. 这不会以任何格式呈现
# 到 crates.io (又名 这不是markdown).
description = &quot;...&quot;

# 这些URL指向有关包的更多信息 这些是
# 旨在成为相关数据的网页入口， 不一定兼容
# VCS工具(类似的)等.
documentation = &quot;...&quot;
homepage = &quot;...&quot;
repository = &quot;...&quot;

# 这指向包根目录下的文件 (与 `Cargo.toml` 相对的).
# 该文件的内容会存储，并在注册表中编入索引。
# crates.io 将渲染此文件，并将结果放在包的页面上.
readme = &quot;...&quot;

# 这是一个，最多五个描述此箱的关键字的列表. 关键词
# 可以在 crates.io 上搜索, 和你可以选择任何单词
# 帮助别人找到这个箱子。
keywords = [&quot;...&quot;, &quot;...&quot;]

# 这是此箱子最适合的(最多五个)类别的列表.
# 类别是 crates.io/category_slugs 上可用的固定列表, 和
# 他们必须完全匹配.
categories = [&quot;...&quot;, &quot;...&quot;]

# 这是此包的SPDX 2.1许可证表达式.  目前
# crates.io将根据白名单的已知许可证和SPDX许可证列表2.4中的异常标识符，
# 验证提供的许可证。目前不支持括号。
#
# 使用AND和OR的许可证表达式
# 运算符以获得更明确的语义。
license = &quot;...&quot;

# 如果程序包使用非标准许可证, 则可以指定此 key
# 代替上述 key 和 必须指向相对于此清单的文件
# (类似于 readme key).
license-file = &quot;...&quot;

# 要在crates.io上显示的徽章规范，的可选项。
#
#  - 与当前可用的构建状态有关的徽章是
#   Appveyor, CircleCI, GitLab, 和 TravisCI.
# - 与代码测试覆盖有关的可用徽章是 Codecov 和
#   Coveralls.
# - 还有基于 isitmaintained.com的维护相关徽章
#   其中说明了问题解决时间，未决问题的百分比和未来
#   维护意图。
#
# 若要求一个`repository` key, 就表示一个`user/repo` 格式的存储库
[badges]

# Appveyor: `repository` 是必须的. `branch` 是可选的; 默认为 `master`
# `service` 是可选的; 有效值是 `github` (默认), `bitbucket`, 和
# `gitlab`; `id` 是可选的; 如果你想改用，可以指定appveyor 项目ID.
# `project_name` 是可选的; 使用在 repository
# 名称 与 appveyor 项目名称 不同的情况.
appveyor = { repository = &quot;...&quot;, branch = &quot;master&quot;, service = &quot;github&quot; }

# Circle CI: `repository` 是必须的. `branch` 是可选的; 默认为 `master`
circle-ci = { repository = &quot;...&quot;, branch = &quot;master&quot; }

# GitLab: `repository` 是必须的. `branch` 是可选的; 默认为 `master`
gitlab = { repository = &quot;...&quot;, branch = &quot;master&quot; }

# Travis CI: `repository`为 &quot;&lt;user&gt;/&lt;project&gt;&quot;格式 是必须的.
# `branch` 是可选的; 默认为 `master`
travis-ci = { repository = &quot;...&quot;, branch = &quot;master&quot; }

# Codecov: `repository` 是必须的. `branch` 是可选的; 默认为 `master`
# `service` 是可选的; 有效值是 `github` (默认), `bitbucket`, 和
# `gitlab`.
codecov = { repository = &quot;...&quot;, branch = &quot;master&quot;, service = &quot;github&quot; }

# Coveralls: `repository` 是必须的. `branch` 是可选的; 默认为 `master`
# `service` 是可选的; 有效值是 `github` (默认) 和 `bitbucket`.
coveralls = { repository = &quot;...&quot;, branch = &quot;master&quot;, service = &quot;github&quot; }

# 是否保持解决时间: `repository` 是必须的.
is-it-maintained-issue-resolution = { repository = &quot;...&quot; }

# 它是否保持未解决问题的百分比: `repository` 是必须的.
is-it-maintained-open-issues = { repository = &quot;...&quot; }

# Maintenance: `status` 是必须的. 可用的选项是 `actively-developed`,
# `passively-maintained`, `as-is`, `experimental`, `looking-for-maintainer`,
# `deprecated`, 和 默认为 `none`, 不会在 crates.io 显示徽章.
maintenance = { status = &quot;...&quot; }
</code></pre>
<p>这个<a href="https://crates.io">crates.io</a>注册中心将呈现描述、显示许可证、链接到三个 URL 并根据关键字进行分类。这些字段为注册表的用户提供有用的信息，并且还影响箱子的搜索排名。在发布箱的’展示栏’，省略任何东西都是非常令人沮丧的。</p>
<p>SPDX 2.1 许可证表达式被记录在案<a href="https://spdx.org/spdx-specification-21-web-version#h.jxpfx0ykyb60">在这里</a>。 许可证列表的当前版本可用的，<a href="https://spdx.org/licenses/">在这里</a>，版本 2.4 是可用的，<a href="https://github.com/spdx/license-list-data/tree/v2.4">在这里</a>.</p>
<h4 id="the-metadata-table-optional"><a class="header" href="#the-metadata-table-optional">The <code>metadata</code> table (optional)</a></h4>
<blockquote>
<p><code>metadata</code> 表格 (可选)</p>
</blockquote>
<p>默认情况下，Cargo 将对<code>Cargo.toml</code>不使用的字段发出警告，协助检测错别字等。就像这个<code>package.metadata</code>表格，但是，完全不写了的话， Cargo 将不会被警告。这个表格可在<code>Cargo.toml</code>，用于将包配置存储好。 例如:</p>
<pre><code class="language-toml">[package]
name = &quot;...&quot;
# ...

# 当要生成一个 Android APK，这个元信息会被使用, 例如.
[package.metadata.android]
package-name = &quot;my-awesome-android-app&quot;
assets = &quot;path/to/static&quot;
</code></pre>
<h3 id="dependency-sections"><a class="header" href="#dependency-sections">Dependency sections</a></h3>
<blockquote>
<p>依赖 部分</p>
</blockquote>
<p>见<a href="reference/./specifying-dependencies.zh.html">指定依赖-那页</a>有关<code>[dependencies]</code>，<code>[dev-dependencies]</code>，<code>[build-dependencies]</code>和特定目标的<code>[target.*.dependencies]</code>部分的信息。</p>
<h3 id="the-profile-sections"><a class="header" href="#the-profile-sections">The <code>[profile.*]</code> sections</a></h3>
<blockquote>
<p><code>[profile.*]</code> 部分</p>
</blockquote>
<p>Cargo 支持了，可通过顶层 配置文件(profile) 调用 rustc 的自定义配置。任何清单都可以声明一个配置文件，但是实际上只读取顶级包的配置文件。所有依赖项的配置文件都将被重写，这样做是为了让顶级包能够控制，其依赖项如何编译的。</p>
<p>目前有四个受支持的配置文件名称，它们都具有相同的配置。下面列出了可用的配置，以及每个配置文件的默认设置.</p>
<pre><code class="language-toml"># 此为 开发配置文件, 给 `cargo build` 所使用.
[profile.dev]
opt-level = 0      # 控制编译器构建的`--opt-level`。
                   # 0-1适合调试。 2是良好优化的。最大为 3。
                   # 's' 企图优化大小, 'z' 则 进一步优化大小.
debug = true       # (u32 or bool) 包括调试信息（调试符号）.
                   # 相当于 `-C debuginfo=2` 编译器 标志.
rpath = false      # 控制 编译器 是否应该设置加载器路径.
                   # 若为 true, 传递 `-C rpath` 标志 给 编译器.
lto = false        # 链接时间优化通常会减少二进制文件和静态库的大小
                   # 但会增加编译时间.
                   # 若是 true, 传递 `-C lto` 标志 给 编译器, 和 若是一个
                   # 字符串值 像 'thin' ，那会传递 `-C lto=thin`
                   # 给 编译器
debug-assertions = true # 控制是否启用调试断言
                   # (e.g. debug_assert!() 和 算术溢出检查)
codegen-units = 16 # if &gt; 1 并行代码生成，以改善
                   # 编译时间, 但阻止了些优化.
                   # 传递 `-C codegen-units`.
panic = 'unwind'   # 恐慌策略 (`-C panic=...`), 也可以是 'abort'
incremental = true # 是否启用增量编译
overflow-checks = true # 使用溢出检查进行整数运算。
                   # 传递 `-C overflow-checks=...`标志 给 compiler.

# 发布(release)的配置文件, 用于 `cargo build --release` (和 依赖项的
# `cargo test --release`,  包括本地 library 或 binary).
[profile.release]
opt-level = 3
debug = false
rpath = false
lto = false
debug-assertions = false
codegen-units = 16
panic = 'unwind'
incremental = false
overflow-checks = false

# 测试的配置文件, 用于 `cargo test` (对于 `cargo test --release`，可看
# `release` 和 `bench` 配置文件).
[profile.test]
opt-level = 0
debug = 2
rpath = false
lto = false
debug-assertions = true
codegen-units = 16
panic = 'unwind'
incremental = true
overflow-checks = true

# 基准的配置文件, 用于`cargo bench` (和 要测试的目标 和
# 单元测试的 `cargo test --release`).
[profile.bench]
opt-level = 3
debug = false
rpath = false
lto = false
debug-assertions = false
codegen-units = 16
panic = 'unwind'
incremental = false
overflow-checks = false
</code></pre>
<h3 id="the-features-section"><a class="header" href="#the-features-section">The <code>[features]</code> section</a></h3>
<blockquote>
<p><code>[features]</code> 部分</p>
</blockquote>
<p>Cargo 支持特性，允许表达:</p>
<ul>
<li>条件编译选项(通过<code>cfg</code>属性);</li>
<li>可选的依赖项，增强了包，但不是必需的;还有</li>
<li>可选依赖项的簇，如<code>postgres</code>，其中就包括<code>postgres</code>包<code>postgres-macros</code>包，以及可能的其他包(如开发时的模拟库、调试工具等)。</li>
</ul>
<p>包的特性也可以是可选的依赖项，也可以是一组其他特性。指定特性的格式是:</p>
<pre><code class="language-toml">[package]
name = &quot;awesome&quot;

[features]
# 默认的可选包集。大多数人都想使用这些
# 包, 但它们是严格可选的。请注意，`session`不是包
# 而是此清单中列出的另一个功能。
default = [&quot;jquery&quot;, &quot;uglifier&quot;, &quot;session&quot;]

# 没有依赖关系的特性，主要用于条件编译，
# 像 `#[cfg(feature = &quot;go-faster&quot;)]`.
go-faster = []

# `secure-password` 特性 需要 bcrypt 包. 这种别名
将允许人们以更高级别的方式讨论该 特性 和 允许
# 此软件包将在未来为该特性添加更多要求.
secure-password = [&quot;bcrypt&quot;]

# 特性可用于重新导出其他包的特性. `awesome`包的 `session`
# 特性将确保 cookie/session 也是可用的
session = [&quot;cookie/session&quot;]

[dependencies]
# 这些包是强制性的，是该软件包发行版的核心。
cookie = &quot;1.2.0&quot;
oauth = &quot;1.1.0&quot;
route-recognizer = &quot;=2.1.0&quot;

# 所以可选依赖项的列表, 其中一些是上面的
# `features`. 它们可以通过应用程序选择加入。
jquery = { version = &quot;1.0.2&quot;, optional = true }
uglifier = { version = &quot;1.5.3&quot;, optional = true }
bcrypt = { version = &quot;*&quot;, optional = true }
civet = { version = &quot;*&quot;, optional = true }
</code></pre>
<p>使用<code>awesome</code>包:</p>
<pre><code class="language-toml">[dependencies.awesome]
version = &quot;1.3.5&quot;
default-features = false # 不包括默认功能，和可选,
                         # 任君选 个性化特性
features = [&quot;secure-password&quot;, &quot;civet&quot;]
</code></pre>
<h4 id="rules"><a class="header" href="#rules">Rules</a></h4>
<blockquote>
<p>规则</p>
</blockquote>
<p>特性的使用遵循一些规则:</p>
<ul>
<li>特性名称不能与清单中的其他包名称冲突。这是因为他们被选择加入<code>features = [...]</code>，而它只有一个命名空间。</li>
<li>除此<code>default</code>特性之外，所有的特性都是可选的。若要退出默认功能，请使用<code>default-features = false</code>，任君选择个人特性.</li>
<li>特性群组不允许周期性地相互依赖.</li>
<li>开发 依赖项不能是可选的.</li>
<li>特性群组只能引用可选的依赖项.</li>
<li>当选择一个特性时，Cargo 将调用具有<code>--cfg feature=&quot;${feature_name}&quot;</code>的<code>rustc</code>。如果包含一个特性群组，那么它将包括所有单独的特性。这可以通过<code>#[cfg(feature = &quot;foo&quot;)]</code>在代码中进行测试..</li>
</ul>
<p>主要注意的是，显露的特性，实际上不激活任何可选的依赖项。这就允许包在不需要新的依赖项的情况下，于内部启用/禁用特性。</p>
<h4 id="usage-in-end-products"><a class="header" href="#usage-in-end-products">Usage in end products</a></h4>
<blockquote>
<p>生产终点的用法</p>
</blockquote>
<p>该特性的一个主要用例是在最终产品中，指定可选特性。例如，Servo 包可能希望包含可选特性，人们可以在构建时，启用或禁用它。</p>
<p>在这种情况下，Servo 将在<code>Cargo.toml</code>描述特性，且用命令行标志来启用这些特性:</p>
<pre><code class="language-console">$ cargo build --release --features &quot;shumway pdf&quot;
</code></pre>
<p>可以使用<code>--no-default-features</code>，排除默认特性。</p>
<h4 id="usage-in-packages"><a class="header" href="#usage-in-packages">Usage in packages</a></h4>
<blockquote>
<p>包(库)的用法</p>
</blockquote>
<p>在大多数情况下，在库中<em>可选依赖</em>的概念，最好将其表示为顶级应用程序所依赖的单独包。</p>
<p>然而，像 Iron 或 Piston 这样的高级软件包会需要排布多个软件包以便于安装。当前的 Cargo 系统允许它们将一些强制依赖项，整合到一个包中，以便于安装。</p>
<p>在某些情况下，包可能希望为可选依赖项，提供额外的管理:</p>
<ul>
<li>将多个低层可选依赖项，组合到一个单独的高级特性中;</li>
<li>由包用户指定推荐(或建议)要包括的包;</li>
<li>包括特性(类似<code>secure-password</code>在激励示例中)，这只在可选的依赖项可用时才能工作，并且很难实现为单独的包(例如，设计一个与 OpenSSL 完全解耦的 IO 包可能过于困难，那这时，就可通过包含单独的包来选择相关特性)。</li>
</ul>
<p>在几乎所有情况下，在设计牢固的高级包之外，使用这些特性都是反模式的。如果某个特性是可选的，那么它几乎可以肯定地表示为单独的包。</p>
<h3 id="the-workspace-section"><a class="header" href="#the-workspace-section">The <code>[workspace]</code> section</a></h3>
<blockquote>
<p><code>[workspace]</code> 部分</p>
</blockquote>
<p>包可以定义一个工作区，它是一组箱，所有箱将共享相同<code>Cargo.lock</code>和输出目录。这个<code>[workspace]</code>表格可以定义为:</p>
<pre><code class="language-toml">[workspace]

# 可选字段，从路径依赖推断（如果不存在）。
# 此处必须给出，包含的其他非路径依赖。
# 特别是, 对于 一个虚拟清单，所有成员都要列出来。
members = [&quot;path/to/member1&quot;, &quot;path/to/member2&quot;, &quot;path/to/member3/*&quot;]

# 可选字段, 如果不存在则为空
exclude = [&quot;path1&quot;, &quot;path/to/dir2&quot;]
</code></pre>
<p>工作区作为 Cargo 的<a href="https://github.com/rust-lang/rfcs/blob/master/text/1525-cargo-workspace.md">RFC 1525</a>一部分被添加到 Cargo 中，并具有许多属性:</p>
<ul>
<li>工作区可以包含多个箱，其中一个是<em>根箱</em>.</li>
<li>这个<em>根箱</em>的<code>Cargo.toml</code>包含<code>[workspace]</code>表格，但不要求必有其他配置.</li>
<li>每当编译工作区中的任何箱时，输出被放置在<em>工作区根</em>。 即紧挨着<em>根箱</em>的<code>Cargo.toml</code>.</li>
<li>工作区中所有箱的那个锁定文件驻留在<em>工作区根</em>.</li>
<li>在<code>Cargo.toml</code>的<code>[patch]</code>，<code>[replace]</code>和<code>[profile.*]</code>部分，只认<em>根箱</em>的清单，而忽略成员箱的。</li>
</ul>
<p>这个工作区的<em>根箱</em>，由其清单中存在的<code>[workspace]</code>指定，并负责定义整个工作区。所有驻留在工作区目录中的<code>path</code>依赖项都变成成员。您可以通过<code>members</code>字段将附加包添加到工作区中。请注意，显式列出的工作区成员，也在工作区中包含了它们的路径依赖项。有时候，一个包可能有很多工作区成员，并且都保持最新会很麻烦。</p>
<p>路径依赖也可以使用<a href="https://docs.rs/glob/0.2.11/glob/struct.Pattern.md">globs</a>匹配多个路径。
最后，<code>exclude</code>字段 可以用于将工作路径中的路径列入黑名单。如果根本不希望某些路径依赖项存在于工作区中，那么这非常有用.</p>
<p>这个<code>package.workspace</code>清单字段(如上所述)用于成员箱中，以指向工作区的根箱。如果省略此字段，则推断它是文件系统(向上的父目录)中，清单包含<code>[workspace]</code>的第一个箱。</p>
<p>箱可以指定<code>package.workspace</code>或指定<code>[workspace]</code>。 也就是说，箱不能同时作为工作区中的根箱(包含<code>[workspace]</code>)，和另一个工作区的成员箱(包含<code>package.workspace</code>)</p>
<p>大多数时间工作区都不需要处理。因<code>cargo new</code>和<code>cargo init</code>将自动处理工作区配置。</p>
<h4 id="virtual-manifest"><a class="header" href="#virtual-manifest">Virtual Manifest</a></h4>
<blockquote>
<p>虚拟清单</p>
</blockquote>
<p>在工作区清单中，如果<code>package</code>表格存在，则工作区根箱将被视为普通包和工作区。如果<code>package</code>表格不存在工作区清单中，那它被称为<em>虚拟清单</em>。</p>
<h4 id="package-selection"><a class="header" href="#package-selection">Package selection</a></h4>
<blockquote>
<p>Package 部分</p>
</blockquote>
<p>在工作区中，与包相关的 Cargo 命令，如<code>cargo build</code>，会应用<code>-p</code> / <code>--package</code>或<code>--all</code>命令行参数选定的包。当未指定时，可选<code>default-members</code>配置被使用:</p>
<pre><code class="language-toml">[workspace]
members = [&quot;path/to/member1&quot;, &quot;path/to/member2&quot;, &quot;path/to/member3/*&quot;]
default-members = [&quot;path/to/member2&quot;, &quot;path/to/member3/foo&quot;]
</code></pre>
<p><code>default-members</code>指定时，必会扩展到子集的<code>members</code>中.</p>
<p>若是<code>default-members</code>未指定，如果它是包，则默认为根清单，或者若是虚拟工作区，就为每个成员的清单(如同<code>--all</code>在命令行上).</p>
<h3 id="the-project-layout"><a class="header" href="#the-project-layout">The project layout</a></h3>
<blockquote>
<p>项目布局</p>
</blockquote>
<p>如果包是可执行文件，则将主源文件命名为<code>src/main.rs</code>。 如果它是一个库，请命名主源文件<code>src/lib.rs</code>。</p>
<p>Cargo 也将处理位于<code>src/bin/*.rs</code>任何文件作为可执行文件。如果可执行文件包含不止一个源文件，则可以使用<code>src/bin</code>目录下，又一个包含<code>main.rs</code>文件的目录，而该目录将被视为具有父目录名称的可执行文件。但是，一旦添加了<code>[[bin]]</code>部分<a href="reference/manifest.zh.html#configuring-a-target">见下文</a>，Cargo 将不再自动建立<code>src/bin/*.rs</code>文件。 相反，你必须创建一个<code>[[bin]]</code>部分，给出你想要生成的每个文件。</p>
<!-- HERE -->
<p>您的包可以(可选地)包含命名为<code>examples</code>，<code>tests</code>和<code>benches</code>文件夹，Cargo 将分别将其视为包含示例、集成测试和基准。类似于<code>bin</code>目标，它们可以由单个文件或拥有<code>main.rs</code>文件的目录组成。</p>
<pre><code>▾ src/           # 包含源文件的目录
  lib.rs         # 库和包的主要入口点
  main.rs        # 包生成可执行文件的主要入口点
  ▾ bin/         # （可选）包含其他可执行文件的目录
    *.rs
  ▾ */           # （可选）包含多文件可执行文件的目录
    main.rs
▾ examples/      # （可选）示例
  *.rs
  ▾ */           # （可选）包含多文件示例的目录
    main.rs
▾ tests/         # （可选）集成测试
  *.rs
  ▾ */           # （可选）包含多文件测试的目录
    main.rs
▾ benches/       # （可选）基准
  *.rs
  ▾ */           # （可选）包含多文件基准的目录
    main.rs
</code></pre>
<p>为了在创建文件和文件夹之后，为包构造代码，应该记住使用 Rust 的模块系统，您可以在这本<a href="https://doc.rust-lang.org/book/crates-and-modules.md">书</a>找到。</p>
<blockquote>
<p>(译)：<a href="https://kaisery.github.io/trpl-zh-cn/ch07-00-packages-crates-and-modules.html">中文</a></p>
</blockquote>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<blockquote>
<p>示例</p>
</blockquote>
<p>位于<code>examples</code>下方的文件，是库提供的功能示例用法。编译时，它们被放置在<code>target/examples</code>目录。</p>
<p>它们可以编译为可执行文件(用<code>main()</code>函数)或，库。和可通过使用<code>extern crate &lt;library-name&gt;</code>导入库。 当您运行测试以保护它们免遭篡改时，它们会被编译。</p>
<p>可以使用命令<code>cargo run --example &lt;example-name&gt;</code>运行单个可执行示例.</p>
<p>指定<code>crate-type</code>将示例编译为库(有关箱类型的附加信息可在<a href="https://doc.rust-lang.org/reference/linkage.html">Rust 参考</a>找到):</p>
<pre><code class="language-toml">[[example]]
name = &quot;foo&quot;
crate-type = [&quot;staticlib&quot;]
</code></pre>
<p>可以使用命令<code>cargo build --example &lt;example-name&gt;</code>构建单个库实例.</p>
<h3 id="tests"><a class="header" href="#tests">Tests</a></h3>
<blockquote>
<p>测试</p>
</blockquote>
<p>当你运行<code>cargo test</code>，Cargo 会:</p>
<ul>
<li>编译并运行库的单元测试，这些测试位于<code>lib.rs</code>(当然，任何标记为<code>#[cfg(test)]</code>部分将考虑为同个阶段);</li>
<li>编译并运行嵌入到文档区块内部的库的文档测试;</li>
<li>编译并运行您库的<a href="reference/manifest.zh.html#integration-tests">集成测试</a>和</li>
<li>编译你库的例子.</li>
</ul>
<h4 id="integration-tests"><a class="header" href="#integration-tests">Integration tests</a></h4>
<blockquote>
<p>集成测试</p>
</blockquote>
<p>在<code>tests/*.rs</code>的每个文件是一个集成测试。当你运行<code>cargo test</code>，Cargo 将编译每个文件作为一个单独的箱子。箱可以通过使用<code>extern crate &lt;library-name&gt;</code>链接(导入)您的库，就像其他导入项一样。</p>
<p>Cargo 不会自动编译<code>tests</code>子目录内的文件，但是，集成测试可以像往常一样从这些目录导入模块。例如，如果希望多个集成测试共享一些代码，可以将共享代码放入<code>tests/common/mod.rs</code>，然后为每个测试文件添加<code>mod common;</code>。</p>
<h3 id="configuring-a-target"><a class="header" href="#configuring-a-target">Configuring a target</a></h3>
<blockquote>
<p>配置为一个目标</p>
</blockquote>
<p>所有的<code>[[bin]]</code>，<code>[lib]</code>，<code>[[bench]]</code>，<code>[[test]]</code>和<code>[[example]]</code>部分都支持类似的配置，用于指定应该如何构建目标。双括号<code>[[bin]]</code>部分，是<a href="https://github.com/toml-lang/toml#array-of-tables">TOML</a>格式的数组。这意味着你可以在您的箱中写多个<code>[[bin]]</code>，这样就会生成几个可执行文件。</p>
<p>下面的例子使用<code>[lib]</code>，但它也适用于所有其他部分。除非另有说明，下面所有列出的值都是对应选项的<strong>默认值</strong>。</p>
<pre><code class="language-toml">[package]
# ...

[lib]
# 生成目标与库的名称. 本该默认是
# 包名, 替换所有破折号
# 为 下划线. (Rust `extern crate` 声明会参考该名;
# 因此，该值必须是可用的有效Rust标识符.)
name = &quot;foo&quot;

# 该字段，指向 crate 的入口(位置), 路径相对于 `Cargo.toml`.
path = &quot;src/lib.rs&quot;

# 一个给目标启用单元测试 的 标志. 会被 `cargo test`使用.
test = true

# 一个给目标启用文档测试 的 标志. 只与库相关
# , 不会影响其他部分。会被
# `cargo test`使用.
doctest = true

# 一个给目标启用基准 的 标志. 会被 `cargo bench`使用.
bench = true

# 一个给目标启用文档 的 标志. 会被 `cargo doc`使用.
doc = true

# 若该目标为 编译器扩展, 那要把该字段设为 true
# ，以让 Cargo 正确编译和，可用于所有依赖项.
plugin = false

# 若该目标为 &quot;macros 1.1&quot; 程序宏, 那要把该字段设为 true
proc-macro = false

# 若设为 false, `cargo test` 会为 rustc 省略 `--test` 标志, 这
# 阻止它生成测试工具 这在二进制存在，
# 构建管理测试运行器本身的情况下，有用.
harness = true

# 若设置了，那 目标会使用一个与`[package]`配置不同的版本
# , 也许是，编译一个库
2018年版本或，编译单元测试的2015年版本. 默认情况下
# 所有目标都使用`[package]`中指定的版本进行编译。
edition = '2015'
</code></pre>
<p>这个<code>[package]</code>还包括可选的<code>autobins</code>,<code>autoexamples</code>,<code>autotests</code>和<code>autobenches</code>，来明确 进入/退出 自动发现特定的目标种类。</p>
<h4 id="the-required-features-field-optional"><a class="header" href="#the-required-features-field-optional">The <code>required-features</code> field (optional)</a></h4>
<blockquote>
<p><code>required-features</code> 字段 (可选)</p>
</blockquote>
<p>这个<code>required-features</code>字段指定目标需要构建的特性。如果未选择任何所需的特性，则将跳过目标。这只与<code>[[bin]]</code>，<code>[[bench]]</code>，<code>[[test]]</code>和<code>[[example]]</code>部分有影响，它没有影响<code>[lib]</code>。</p>
<pre><code class="language-toml">[features]
# ...
postgres = []
sqlite = []
tools = []

[[bin]]
# ...
required-features = [&quot;postgres&quot;, &quot;tools&quot;]
</code></pre>
<h4 id="building-dynamic-or-static-libraries"><a class="header" href="#building-dynamic-or-static-libraries">Building dynamic or static libraries</a></h4>
<blockquote>
<p>构建 动态 或 静态 库</p>
</blockquote>
<p>如果您的包生成一个库，则可以通过在<code>Cargo.toml</code>显式地指明构建的库类型:</p>
<pre><code class="language-toml"># ...

[lib]
name = &quot;...&quot;
crate-type = [&quot;dylib&quot;] # 也能是 `staticlib`
</code></pre>
<p>可用的选项是<code>dylib</code>，<code>rlib</code>，<code>staticlib</code>，<code>cdylib</code>和<code>proc-macro</code>。 您应该只在包中使用一次此选项。Cargo 总是根据(包括的)包的要求来编译包(依赖项)。</p>
<p>您可以阅读<a href="https://doc.rust-lang.org/reference/linkage.html">Rust 参考手册</a>中更多关于不同的箱类型</p>
<h3 id="the-patch-section-1"><a class="header" href="#the-patch-section-1">The <code>[patch]</code> Section</a></h3>
<blockquote>
<p><code>[patch]</code> 部分</p>
</blockquote>
<p>这部分可以用来<a href="reference/./specifying-dependencies.zh.html#overriding-dependencies">重写其他副本的依赖项</a>。语法类似于<code>[dependencies]</code>部分:</p>
<pre><code class="language-toml">[patch.crates-io]
foo = { git = 'https://github.com/example/foo' }
bar = { path = 'my/local/bar' }

[dependencies.baz]
git = 'https://github.com/example/baz'

[patch.'https://github.com/example/baz']
baz = { git = 'https://github.com/example/patched-baz', branch = 'my-branch' }
</code></pre>
<p>这个<code>[patch]</code>表格由，类似依赖表格的子表组成。<code>[patch]</code>后的每个字段是正在修补的源 URL，或者<code>crates-io</code>(如果你正在修改<a href="https://crates.io">HTTPS://CRATESIO</a>注册表)。在上面的例子中，<code>crates-io</code>可以用 Git URL 替换，例如<code>https://github.com/rust-lang-nursery/log</code>；第二个示例中的<code>[patch]</code>部分使用此来指定一个名为<code>baz</code>的源。</p>
<p>这些表格中的每个项都是一个正常的依赖关系规范，与<code>[dependencies]</code>清单的部分一样。<code>[patch]</code>部分中列出的依赖项，被解析并用于在指定的 URL 上对源进行补丁。上面的清单片段补丁<code>crates-io</code>源(例如 crates.io 本身)的<code>foo</code>箱和<code>bar</code>箱。它也用一个来自其他地方的<code>my-branch</code>分支修补了<code>https://github.com/example/baz</code>源。</p>
<p>可以用不存在的箱版本来修补源，也可以用已经存在的箱版本来修补源。如果用源中已经存在的箱版本对源进行修补，则会替换源的原始箱。</p>
<p>有关重写依赖关系的更多信息，可阅读本文档的<a href="reference/./specifying-dependencies.zh.html#overriding-dependencies">重写依赖项</a>章节和对于这一特性的<a href="https://github.com/rust-lang/rfcs/pull/1969">RFC 1969</a>技术规范说明。</p>
<h3 id="the-replace-section-1"><a class="header" href="#the-replace-section-1">The <code>[replace]</code> Section</a></h3>
<blockquote>
<p><code>[replace]</code> 部分</p>
</blockquote>
<p>这部分可以用来<a href="reference/./specifying-dependencies.zh.html#overriding-dependencies">重写其他副本的依赖项</a>。语法类似于<code>[dependencies]</code>部分:</p>
<pre><code class="language-toml">[replace]
&quot;foo:0.1.0&quot; = { git = 'https://github.com/example/foo' }
&quot;bar:1.0.2&quot; = { path = 'my/local/bar' }
</code></pre>
<p><code>[replace]</code>表格的每个字段都是<a href="reference/./pkgid-spec.zh.html">包标识规范</a>，它任意选择依赖图中的节点来重写。每个字段值与`[dependencies]指定依赖关系的语法是一样，除了不能指定特性。注意，当覆盖一个箱时，覆盖它的副本必须具有相同的名称和版本，但它可以来自不同的源(例如，git 或本地路径).</p>
<p>有关重写依赖关系的更多信息，可阅读本文档的<a href="reference/./specifying-dependencies.zh.html#overriding-dependencies">重写依赖项</a>章节。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cargo-targets"><a class="header" href="#cargo-targets">Cargo Targets</a></h2>
<p><em>目标(Target)</em> 在 Cargo 中，是指代你的 crate 想成为的目标，它可以是<a href="reference/cargo-targets.zh.html#library">library</a>, <a href="reference/cargo-targets.zh.html#binaries">binary</a>, <a href="reference/cargo-targets.zh.html#examples">example</a>, <a href="reference/cargo-targets.zh.html#tests">test</a>和<a href="reference/cargo-targets.zh.html#benchmarks">benchmark</a>。可以在<code>Cargo.toml</code>中，明确 target 列表。当然，常常能根据（常规的）代码库目录，<a href="reference/cargo-targets.zh.html#target-auto-discovery">自动推断</a>由<a href="reference/../guide/project-layout.zh.html">directory layout</a>。</p>
<p>下面是有关<a href="reference/cargo-targets.zh.html#configuring-a-target">配置目标</a>的详细信息。</p>
<h3 id="library"><a class="header" href="#library">Library</a></h3>
<p>Cargo 目标定义了一个<code>库”，可以被其他库和可执行文件使用和链接。文件名默认为</code>src/lib.rs<code>，库的名称默认为包的名称。一个包只能有一个库。库的设置可以是在</code>Cargo.toml<code>的</code>[lib]`下，<a href="reference/cargo-targets.zh.html#configuring-a-target">自定义</a>.</p>
<pre><code class="language-toml">#  Cargo.toml 示例
[lib]
crate-type = [&quot;cdylib&quot;]
bench = false
</code></pre>
<h3 id="binaries"><a class="header" href="#binaries">Binaries</a></h3>
<p>二进制目标是编译后，可以运行的可执行程序。默认的二进制文件名是<code>src/main.rs</code>，默认为包的名称。其他二进制文件存储在<a href="reference/../guide/project-layout.zh.html"><code>src/bin/</code>
目录</a>。库的设置可以是在<code>Cargo.toml</code>的<code>[[bin]]</code>下，<a href="reference/cargo-targets.zh.html#configuring-a-target">自定义</a>.</p>
<p>二进制文件可以使用 自身 Library 的公共 API。它们还链接定义于<code>Cargo.toml</code>中的<a href="reference/specifying-dependencies.zh.html"><code>[dependencies]</code></a>。</p>
<p>您可以使用<a href="reference/../commands/cargo-run.zh.html"><code>cargo run</code></a>带上<code>--bin &lt;bin-name&gt;</code>选项。这个目标，可以让<a href="reference/../commands/cargo-install.zh.html"><code>cargo install</code></a>使用，将可执行文件复制到公共位置。</p>
<pre><code class="language-toml"># 示例 Cargo.toml.
[[bin]]
name = &quot;cool-tool&quot;
test = false
bench = false

[[bin]]
name = &quot;frobnicator&quot;
required-features = [&quot;frobnicate&quot;]
</code></pre>
<h3 id="examples-1"><a class="header" href="#examples-1">Examples</a></h3>
<p><a href="reference/../guide/project-layout.zh.html"><code>examples</code> 目录</a>下，是该库提供的使用示例。在编译时，它们被放置在<a href="reference/../guide/build-cache.zh.html"><code>target/debug/examples</code> 目录</a>。</p>
<p>示例可以使用包库的公共 API。它们还与<a href="reference/specifying-dependencies.zh.html"><code>[dependencies]</code></a>和<a href="reference/specifying-dependencies.zh.html#development-dependencies"><code>[dev-dependencies]</code></a>定义于<code>Cargo.toml</code>。</p>
<p>默认情况下，示例是可执行二进制文件（带有<code>main()</code>函数）。您可以指定<a href="reference/cargo-targets.zh.html#the-crate-type-field"><code>crate-type</code> 字段</a>，将示例编译为库，如下：</p>
<pre><code class="language-toml">[[example]]
name = &quot;foo&quot;
crate-type = [&quot;staticlib&quot;]
</code></pre>
<p>您可以使用<a href="reference/../commands/cargo-run.zh.html"><code>cargo run</code></a>带上<code>--example &lt;example-name&gt;</code>选项，运行单个示例。可以用<a href="reference/../commands/cargo-build.zh.html"><code>cargo build</code></a>和<code>--example &lt;example-name&gt;</code>选项，构建示例。可以用<a href="reference/../commands/cargo-install.zh.html"><code>cargo install</code></a>和<code>--example &lt;example-name&gt;</code>选项，将可执行二进制文件复制到公共位置。默认情况下，<a href="reference/../commands/cargo-test.zh.html"><code>cargo test</code></a>的执行，会让 example 被编译，以此保护它们不被腐蚀。如果，你有<code>#[test]</code>函数在你运行的 example 里，设置<a href="reference/cargo-targets.zh.html#the-test-field"><code>test</code>
字段</a>到<code>true</code>。</p>
<h3 id="tests-1"><a class="header" href="#tests-1">Tests</a></h3>
<p>Cargo 项目中，有两种类型的测试：</p>
<ul>
<li><em>单元测试</em> 就是带有<a href="reference/../../reference/attributes/testing.html#the-test-attribute"><code>#[test]</code>
属性</a>的函数（或是启用<a href="reference/cargo-targets.zh.html#the-test-field"><code>test</code> 字段</a>的)。这些测试可以访问目标内的私有 API。</li>
<li><em>集成测试</em> 就是一个单独的可执行二进制文件，也包含<code>#[test]</code>函数，该函数与项目的库链接，并可以访问其<em>公有</em> API。</li>
</ul>
<p>测试是由<a href="reference/../commands/cargo-test.zh.html"><code>cargo test</code></a>命令执行。默认情况下，Cargo 和<code>rustc</code>使用<a href="reference/../../rustc/tests/index.html">libtest harness</a> —— 负责收集用<a href="reference/../../reference/attributes/testing.html#the-test-attribute"><code>#[test]</code> 属性</a>，再并行执行，报告每个测试的成功和失败。如果您想使用不同测试策略，研究下<a href="reference/cargo-targets.zh.html#the-harness-field"> <code>harness</code>
字段</a>。</p>
<h4 id="integration-tests-1"><a class="header" href="#integration-tests-1">Integration tests</a></h4>
<p><a href="reference/../guide/project-layout.zh.html"><code>tests</code> 目录</a>是集成测试。<a href="reference/../commands/cargo-test.zh.html"><code>cargo test</code></a>的时候，Cargo 将把这些文件编译成一个单独的箱子，并执行它们。</p>
<p>集成测试可以使用包库的公共 API。它们还与<a href="reference/specifying-dependencies.zh.html"><code>[dependencies]</code></a>和<a href="reference/specifying-dependencies.zh.html#development-dependencies"><code>[dev-dependencies]</code></a>链接。</p>
<p>如果希望在多个集成测试之间共享代码，可以将其放在单独的模块中，例如<code>tests/common/mod.rs</code>，然后在每个测试，用<code>mod common;</code>导入。</p>
<p>每个集成测试的结果都是一个单独的可执行二进制文件，并且，<a href="reference/../commands/cargo-test.zh.html"><code>cargo test</code></a> 是连续运行它们。在某些情况下，这可能效率低下，因为编译可能需要更长的时间，并且在运行测试时，可能无法充分利用多个 CPU。如果您有很多集成测试，您可能需要考虑创建一个单一的集成测试，并将测试分成多个模块。libtest harness 将自动找到所有<code>#[test]</code>函数，再并行运行它们。您还可以将模块名称传递给<a href="reference/../commands/cargo-test.zh.html"><code>cargo test</code></a> —— 仅在该模块内运行测试。</p>
<p>如果有集成测试，二进制目标会自动生成。这能让集成测试，执行二进制文件来练习和测试其行为。这个<code>CARGO_BIN_EXE_&lt;name&gt;</code> <a href="reference/environment-variables.zh.html#environment-variables-cargo-sets-for-crates">environment variable</a>在构建集成测试时，会被设置，这样它就可以使用<a href="reference/../../std/macro.env.html"><code>env</code> macro</a>，找到可执行文件。</p>
<h3 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h3>
<p>基准测试<a href="reference/../commands/cargo-bench.zh.html"><code>cargo bench</code></a>命令提供了一种方式 —— 测试你代码性能。它与<a href="reference/cargo-targets.zh.html#tests">tests</a>的梳理流程类似，每个基准函数都用<code>#[bench]</code>属性与测试类似：</p>
<ul>
<li>基准放在<a href="reference/../guide/project-layout.zh.html"><code>benches</code> 目录</a>.</li>
<li>库和二进制文件中，定义的基准函数可以访问 <em>私有</em> API。<code>benches</code>目录下的基准，可以使用 <em>公有</em> API。</li>
<li><a href="reference/cargo-targets.zh.html#the-bench-field"><code>bench</code> 字段</a>定义默认情况下，以哪些目标为基准。</li>
<li><a href="reference/cargo-targets.zh.html#the-harness-field"><code>harness</code> 字段</a>禁用内置 harness。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：<a href="reference/../../unstable-book/library-features/test.html"><code>#[bench]</code>
属性</a>目前不稳定，仅在<a href="reference/../../book/appendix-07-nightly-rust.html">nightly channel</a>。<a href="https://crates.io/keywords/benchmark">crates.io</a>也有些包，可能有助于在稳定通道上，运行基准测试，例如<a href="https://crates.io/crates/criterion">Criterion</a>。</p>
</blockquote>
<h3 id="configuring-a-target-1"><a class="header" href="#configuring-a-target-1">Configuring a target</a></h3>
<p><code>Cargo.toml</code>下的<code>[lib]</code>, <code>[[bin]]</code>, <code>[[example]]</code>, <code>[[test]]</code>和<code>[[bench]]</code>，支持类似的配置，去构建目标。双括号部分，如<code>[[bin]]</code>是<a href="https://toml.io/en/v1.0.0-rc.3#array-of-tables">TOML 语法下的数组表格</a>，这意味着，你可以写多个<code>[[bin]]</code>，制作几个可执行文件。而<code>[lib]</code>只能指定一个库。</p>
<p>以下是每个目标的 TOML 设置概述，每个字段将在下面详细描述。</p>
<pre><code class="language-toml">[lib]
name = &quot;foo&quot;           # The name of the target.
path = &quot;src/lib.rs&quot;    # The source file of the target.
test = true            # Is tested by default.
doctest = true         # Documentation examples are tested by default.
bench = true           # Is benchmarked by default.
doc = true             # Is documented by default.
plugin = false         # Used as a compiler plugin (deprecated).
proc-macro = false     # Set to `true` for a proc-macro library.
harness = true         # Use libtest harness.
edition = &quot;2015&quot;       # The edition of the target.
crate-type = [&quot;lib&quot;]   # The crate types to generate.
required-features = [] # Features required to build this target (N/A for lib).
</code></pre>
<h4 id="the-name-field"><a class="header" href="#the-name-field">The <code>name</code> field</a></h4>
<p>这个<code>name</code>字段指定目标的名称，该名称对应于将生成工件的文件名。对于库，这是依赖项用来引用它的箱子名称。</p>
<p>对于<code>[lib]</code>和默认的二进制文件(<code>src/main.rs</code>)，默认为包的名称，任何破折号都替换为下划线。其他<a href="reference/cargo-targets.zh.html#target-auto-discovery">自动识别</a>的目标，默认为目录或文件名。</p>
<p>这是必需的。</p>
<h4 id="the-path-field"><a class="header" href="#the-path-field">The <code>path</code> field</a></h4>
<p>这个<code>path</code>字段，指定箱子的来源，路径相对于<code>Cargo.toml</code>文件</p>
<p>如果未指定，则基于目标名称<a href="reference/cargo-targets.zh.html#target-auto-discovery">推断路径</a>。</p>
<h4 id="the-test-field"><a class="header" href="#the-test-field">The <code>test</code> field</a></h4>
<p>这个<code>test</code>字段表明默认情况下，是否测试目标<a href="reference/../commands/cargo-test.zh.html"><code>cargo test</code></a>。lib, bins, 和 tests 默认值为<code>true</code>。</p>
<blockquote>
<p><strong>注意</strong>：默认情况下，<a href="reference/../commands/cargo-test.zh.html"><code>cargo test</code></a>是构建 example 的，以确保它们继续编译，但不会测试。设<code>test = true</code>的话，我们就将它构建为一个测试，并运行示例中，任何<a href="reference/../../reference/attributes/testing.html#the-test-attribute"><code>#[test]</code></a>定义的函数。</p>
</blockquote>
<h4 id="the-doctest-field"><a class="header" href="#the-doctest-field">The <code>doctest</code> field</a></h4>
<p>这个<code>doctest</code>字段表明：默认情况下，[文档示例]是否由<a href="reference/../commands/cargo-test.zh.html"><code>cargo test</code></a>测试。这只与 libraries 有关，对其他部分没有影响。library 默认值是<code>true</code>。</p>
<h4 id="the-bench-field"><a class="header" href="#the-bench-field">The <code>bench</code> field</a></h4>
<p>这个<code>bench</code>字段表明，默认情况下，<a href="reference/../commands/cargo-bench.zh.html"><code>cargo bench</code></a>是否对目标进行基准测试、lib, bins, 和 benchmarks 默认值为<code>true</code> 。</p>
<h4 id="the-doc-field"><a class="header" href="#the-doc-field">The <code>doc</code> field</a></h4>
<p>这个<code>doc</code>字段表明，默认情况下，目标是否包含在由<a href="reference/../commands/cargo-doc.zh.html"><code>cargo doc</code></a>生成的文档中。默认值是<code>true</code>用于库和二进制文件。</p>
<blockquote>
<p><strong>注意</strong>：如果二进制文件的名称与库目标相同，则将跳过该二进制文件。</p>
</blockquote>
<h4 id="the-plugin-field"><a class="header" href="#the-plugin-field">The <code>plugin</code> field</a></h4>
<p>此字段用于<code>rustc</code>使用的插件，已弃用。</p>
<h4 id="the-proc-macro-field"><a class="header" href="#the-proc-macro-field">The <code>proc-macro</code> field</a></h4>
<p>这个<code>proc-macro</code>字段，表示该库是一个<a href="reference/%5Breference%5D%5Bproc-macro-reference%5D">procedural macro</a>。这只适用于<code>[lib]</code>目标</p>
<h4 id="the-harness-field"><a class="header" href="#the-harness-field">The <code>harness</code> field</a></h4>
<p>这个<code>harness</code>字段表示，将[<code>--test</code>]传递给<code>rustc</code>，它将自动包含 libtest 库，libtest 库是用于收集和运行，标记为<a href="reference/../../reference/attributes/testing.html#the-test-attribute"><code>#[test]</code> 属性</a>或者使用<code>#[bench]</code>属性的(函数)，所有目标默认值是<code>true</code>。</p>
<p>如果，设置为<code>false</code>，则您负责定义<code>main()</code>函数，来运行测试和基准测试。</p>
<p>测试那些<a href="reference/../../reference/conditional-compilation.html#test"><code>cfg(test)</code> 条件语句</a>，无论 harness 是否启用。</p>
<h4 id="the-edition-field"><a class="header" href="#the-edition-field">The <code>edition</code> field</a></h4>
<p>这个<code>edition</code>字段定义，目标将使用<a href="reference/../../edition-guide/index.html">Rust edition</a>。如果未指定，则默认为<code>[package]</code>下的<a href="reference/manifest.zh.html#the-edition-field"><code>edition</code> 字段</a>。此字段通常不应设置，仅适用于高级场景，例如，将大型软件包增量转换为新版本。</p>
<h4 id="the-crate-type-field"><a class="header" href="#the-crate-type-field">The <code>crate-type</code> field</a></h4>
<p>这个<code>crate-type</code>字段定义，由目标生成的<a href="reference/../../reference/linkage.html">crate types</a>。它是一个字符串数组，允许您为单个目标指定多个箱子类型。这只能为库和示例指定。二进制文件、测试和基准测试始终是<code>bin</code>箱子类型。默认设置为：</p>
<table><thead><tr><th>目标</th><th>箱子类型</th></tr></thead><tbody>
<tr><td>普通 library</td><td><code>&quot;lib&quot;</code></td></tr>
<tr><td>Proc-macro library</td><td><code>&quot;proc-macro&quot;</code></td></tr>
<tr><td>Example</td><td><code>&quot;bin&quot;</code></td></tr>
</tbody></table>
<p>可用的选项包括，<code>bin</code>, <code>lib</code>, <code>rlib</code>, <code>dylib</code>, <code>cdylib</code>, <code>staticlib</code>和<code>proc-macro</code>。你可以在<a href="reference/../../reference/linkage.html">Rust Reference Manual</a>上，阅读更多关于不同箱子类型的信息。</p>
<h4 id="the-required-features-field"><a class="header" href="#the-required-features-field">The <code>required-features</code> field</a></h4>
<p>这个<code>required-features</code>字段，需要的<a href="reference/features.zh.html">features</a>。如果未启用任何**必需的（required）**功能，则将跳过这个目标。这只与<code>[[bin]]</code>, <code>[[bench]]</code>, <code>[[test]]</code>和<code>[[example]]</code>有关系，但是，它对<code>[lib]</code>没有影响。</p>
<pre><code class="language-toml">[features]
# ...
postgres = []
sqlite = []
tools = []

[[bin]]
name = &quot;my-pg-tool&quot;
required-features = [&quot;postgres&quot;, &quot;tools&quot;]
</code></pre>
<h3 id="target-auto-discovery"><a class="header" href="#target-auto-discovery">Target auto-discovery</a></h3>
<p>默认情况下，Cargo 会根据<a href="reference/../guide/project-layout.zh.html">文件系统的布局</a>。目标配置表，例如<code>[lib]</code>, <code>[[bin]]</code>, <code>[[test]]</code>, <code>[[bench]]</code>或<code>[[example]]</code>，可用于添加，不遵循标准布局的其他目标。</p>
<p>可以禁用自动目标发现，以便只生成手动配置的目标。若是<code>[package]</code>下的<code>autobins</code>, <code>autoexamples</code>, <code>autotests</code>或<code>autobenches</code>设为<code>false</code>，将禁用自动发现(auto-discovery)。</p>
<pre><code class="language-toml">[package]
# ...
autobins = false
autoexamples = false
autotests = false
autobenches = false
</code></pre>
<p>只有在特殊情况下，才需要禁用自动发现。例如，如果你有一个 library，你想要一个命名<code>bin</code>的<em>module</em>，这将带来一个问题 —— Cargo 通常会尝试编译<code>bin</code>目录作为可执行文件。以下是此场景的示例布局：</p>
<pre><code class="language-text">├── Cargo.toml
└── src
    ├── lib.rs
    └── bin
        └── mod.rs
</code></pre>
<p>防止 Cargo 推断<code>src/bin/mod.rs</code>为可执行文件，在<code>Cargo.toml</code>里面设置<code>autobins = false</code>，就可以禁用自动发现，如下：</p>
<pre><code class="language-toml">[package]
# …
autobins = false
</code></pre>
<blockquote>
<p><strong>注意</strong>：对于 2015 edition 的软件包 —— 如果在<code>Cargo.toml</code>中，手动定义了至少一个目标，那么自动发现的默认设置为<code>false</code>。从 2018 版开始，默认值始终为<code>true</code>。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="workspaces"><a class="header" href="#workspaces">Workspaces</a></h2>
<p>A.<em>工作空间</em>是一个或多个包的集合，这些包共享公共依赖项解析（具有共享的<code>Cargo.lock</code>)，输出目录，以及各种设置，如配置文件。属于工作区的包称为<em>工作区成员</em>.工作区有两种风格：根包或虚拟清单。</p>
<h3 id="root-package"><a class="header" href="#root-package">Root package</a></h3>
<p>可以通过添加<a href="reference/workspaces.zh.html#the-workspace-section"><code>[workspace]</code>
section</a>到<code>Cargo.toml</code>。这可以添加到<code>Cargo.toml</code>这已经定义了一个<code>[package]</code>，在这种情况下，包是<em>根包</em>工作空间的一部分。这个<em>工作区根目录</em>是工作区所在的目录<code>Cargo.toml</code>位于。</p>
<h3 id="virtual-manifest-1"><a class="header" href="#virtual-manifest-1">Virtual manifest</a></h3>
<p>或者，一个<code>Cargo.toml</code>可以使用<code>[workspace]</code>部分，但没有<a href="reference/manifest.html#the-package-section"><code>[package]</code> section</a>.这叫做<em>虚拟舱单</em>。如果没有“主”包，或者希望将所有包组织在单独的目录中，这通常很有用。</p>
<h3 id="key-features"><a class="header" href="#key-features">Key features</a></h3>
<p>工作区的关键点是：</p>
<ul>
<li>所有包共享一个公共<code>Cargo.lock</code>位于<em>工作区根目录</em>.</li>
<li>所有包共享一个公共<a href="reference/../guide/build-cache.html">output directory</a>，默认为名为<code>target</code>在<em>工作区根目录</em>.</li>
<li>这个<a href="reference/overriding-dependencies.html#the-patch-section"><code>[patch]</code></a>, <a href="reference/overriding-dependencies.html#the-replace-section"><code>[replace]</code></a>和<a href="reference/profiles.html"><code>[profile.*]</code></a>章节<code>Cargo.toml</code>只有在<em>根</em>而在成员箱子的清单中被忽略。</li>
</ul>
<h3 id="the-workspace-section-1"><a class="header" href="#the-workspace-section-1">The <code>[workspace]</code> section</a></h3>
<p>这个<code>[workspace]</code>入座<code>Cargo.toml</code>定义哪些包是工作区的成员：</p>
<pre><code class="language-toml">[workspace]
members = [&quot;member1&quot;, &quot;path/to/member2&quot;, &quot;crates/*&quot;]
exclude = [&quot;crates/foo&quot;, &quot;path/to/other&quot;]
</code></pre>
<p>全部的<a href="reference/specifying-dependencies.html#specifying-path-dependencies"><code>path</code> dependencies</a>驻留在工作区目录中的用户将自动成为成员。其他成员可以与<code>members</code>键，它应该是一个字符串数组，其中包含<code>Cargo.toml</code>文件夹。</p>
<p>这个<code>members</code>列表还支持<a href="https://docs.rs/glob/0.3.0/glob/struct.Pattern.html">globs</a>要匹配多个路径，请使用典型的文件名glob模式，如<code>*</code>和<code>?</code>.</p>
<p>这个<code>exclude</code>键可用于防止路径包含在工作区中。如果一些路径依赖项根本不希望出现在工作区中，或者使用glob模式，并且希望删除目录，那么这将非常有用。</p>
<p>空的<code>[workspace]</code>表可以与<code>[package]</code>使用包及其所有路径依赖关系方便地创建工作区。</p>
<h3 id="workspace-selection"><a class="header" href="#workspace-selection">Workspace selection</a></h3>
<p>在工作区的子目录中时，Cargo会自动在父目录中搜索<code>Cargo.toml</code>向<code>[workspace]</code>定义以确定要使用的工作空间。这个<a href="reference/manifest.html#the-workspace-field"><code>package.workspace</code></a>可以在成员箱子中使用清单键指向工作区的根，以覆盖此自动搜索。如果成员不在工作区根目录的子目录中，手动设置可能会很有用。</p>
<h3 id="package-selection-1"><a class="header" href="#package-selection-1">Package selection</a></h3>
<p>在工作区中，与包相关的Cargo命令<a href="reference/../commands/cargo-build.html"><code>cargo build</code></a>可以使用<code>-p</code> / <code>--package</code>或<code>--workspace</code>命令行标志，用于确定要对哪些包进行操作。如果未指定这两个标志，Cargo将使用当前工作目录中的包。如果当前目录是虚拟工作区，它将应用于所有成员（就像<code>--workspace</code>已在命令行上指定）。</p>
<p>可选的<code>default-members</code>可以指定键来设置在工作区根目录中且未使用包选择标志时要操作的成员：</p>
<pre><code class="language-toml">[workspace]
members = [&quot;path/to/member1&quot;, &quot;path/to/member2&quot;, &quot;path/to/member3/*&quot;]
default-members = [&quot;path/to/member2&quot;, &quot;path/to/member3/foo&quot;]
</code></pre>
<p>如有规定，<code>default-members</code>必须扩展到<code>members</code>.</p>
<h3 id="the-workspacemetadata-table"><a class="header" href="#the-workspacemetadata-table">The <code>workspace.metadata</code> table</a></h3>
<p>这个<code>workspace.metadata</code>表被Cargo忽略，不会被警告。本节可用于希望在中存储工作区配置的工具<code>Cargo.toml</code>.例如：</p>
<pre><code class="language-toml">[workspace]
members = [&quot;member1&quot;, &quot;member2&quot;]

[workspace.metadata.webcontents]
root = &quot;path/to/webproject&quot;
tool = [&quot;npm&quot;, &quot;run&quot;, &quot;build&quot;]
# ...
</code></pre>
<p>在软件包级别，有一组类似的表<a href="reference/manifest.html#the-metadata-table"><code>package.metadata</code></a>。虽然cargo没有为这两个表格的内容指定格式，但建议外部工具可能希望以一致的方式使用它们，例如参考表中的数据<code>workspace.metadata</code>如果数据丢失<code>package.metadata</code>，如果这对所讨论的工具有意义。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="features"><a class="header" href="#features">Features</a></h2>
<p>Cargo“特征”提供了一种表达<a href="reference/../../reference/conditional-compilation.html">conditional compilation</a>和<a href="reference/features.zh.html#optional-dependencies">optional dependencies</a>.一个包在<code>[features]</code>表格<code>Cargo.toml</code>，每个功能都可以启用或禁用。可以在命令行上使用以下标志启用正在生成的包的功能：<code>--features</code>。可以在中的依赖项声明中启用依赖项功能<code>Cargo.toml</code>.</p>
<p>另见<a href="reference/features-examples.html">Features Examples</a>第二章介绍了如何使用功能的一些示例。</p>
<h3 id="the-features-section-1"><a class="header" href="#the-features-section-1">The <code>[features]</code> section</a></h3>
<p>特征定义在<code>[features]</code>入座<code>Cargo.toml</code>。每个功能都指定了它启用的其他功能或可选依赖项的数组。以下示例说明了如何将功能用于二维图像处理库，其中可以选择包括对不同图像格式的支持：</p>
<pre><code class="language-toml">[features]
# Defines a feature named `webp` that does not enable any other features.
webp = []
</code></pre>
<p>定义了此功能后，<a href="reference/../../reference/conditional-compilation.html"><code>cfg</code> expressions</a>可用于在编译时有条件地包含代码以支持请求的功能。例如，内部<code>lib.rs</code>一揽子计划的内容可能包括：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This conditionally includes a module which implements WEBP support.
#[cfg(feature = &quot;webp&quot;)]
pub mod webp;
<span class="boring">}
</span></code></pre></pre>
<p>使用<code>rustc</code> <a href="reference/../../rustc/command-line-arguments.html#option-cfg"><code>--cfg</code> flag</a>，代码可以通过<a href="reference/../../reference/conditional-compilation.html#the-cfg-attribute"><code>cfg</code> attribute</a>或者<a href="reference/../../std/macro.cfg.html"><code>cfg</code> macro</a>.</p>
<p>功能可以列出要启用的其他功能。例如，ICO图像格式可以包含BMP和PNG图像，因此当它被启用时，应该确保其他功能也被启用：</p>
<pre><code class="language-toml">[features]
bmp = []
png = []
ico = [&quot;bmp&quot;, &quot;png&quot;]
webp = []
</code></pre>
<p>功能名称可能包括来自<a href="https://unicode.org/reports/tr31/">Unicode XID standard</a>（其中包括大多数字母），并允许以<code>_</code>或数字<code>0</code>通过<code>9</code>，并且在第一个字符之后还可以包含<code>-</code>, <code>+</code>或<code>.</code>.</p>
<blockquote>
<p><strong>笔记</strong>: <a href="https://crates.io/">crates.io</a>对功能名称语法施加额外的约束，这些约束必须是<a href="reference/../../std/primitive.char.html#method.is_ascii_alphanumeric">ASCII alphanumeric</a>角色或<code>_</code>, <code>-</code>或<code>+</code>.</p>
</blockquote>
<h3 id="the-default-feature"><a class="header" href="#the-default-feature">The <code>default</code> feature</a></h3>
<p>默认情况下，除非明确启用，否则所有功能都将被禁用。可以通过指定<code>default</code>特色：</p>
<pre><code class="language-toml">[features]
default = [&quot;ico&quot;, &quot;webp&quot;]
bmp = []
png = []
ico = [&quot;bmp&quot;, &quot;png&quot;]
webp = []
</code></pre>
<p>构建包时<code>default</code>功能已启用，从而启用列出的功能。这种行为可以通过以下方式改变：</p>
<ul>
<li>这个<code>--no-default-features</code> <a href="reference/features.zh.html#command-line-feature-options">command-line
flag</a>禁用软件包的默认功能。</li>
<li>这个<code>default-features = false</code>选项可以在<a href="reference/features.zh.html#dependency-features">dependency
declaration</a>.</li>
</ul>
<blockquote>
<p><strong>笔记</strong>：在选择默认功能集时要小心。默认功能是一种方便，可以更轻松地使用软件包，而不必强迫用户仔细选择要启用哪些功能以供通用，但也有一些缺点。依赖项自动启用默认功能，除非<code>default-features = false</code>是指定的。这会导致难以确保未启用默认功能，尤其是对于依赖关系图中多次出现的依赖关系。每个包裹都必须确保<code>default-features = false</code>指定以避免启用它们。</p>
<p>另一个问题是，它可能是一个<a href="reference/features.zh.html#semver-compatibility">SemVer incompatible
change</a>从默认设置中删除某个功能，因此您应该确信将保留这些功能。</p>
</blockquote>
<h3 id="optional-dependencies"><a class="header" href="#optional-dependencies">Optional dependencies</a></h3>
<p>依赖项可以标记为“可选”，这意味着默认情况下不会编译它们。例如，假设我们的2D图像处理库使用一个外部包来处理GIF图像。这可以这样表达：</p>
<pre><code class="language-toml">[dependencies]
gif = { version = &quot;0.11.1&quot;, optional = true }
</code></pre>
<p>可选依赖项隐式定义与依赖项同名的功能。这意味着同样的<code>cfg(feature = &quot;gif&quot;)</code>可以在代码中使用语法，并且可以像以下功能一样启用依赖项：<code>--features gif</code>（见<a href="reference/features.zh.html#command-line-feature-options">Command-line feature
options</a>下面）。</p>
<blockquote>
<p><strong>笔记</strong>：中的一个功能<code>[feature]</code>表不能使用与依赖项相同的名称。在夜间频道上，可以通过<a href="reference/unstable.html#namespaced-features">namespaced
features</a>.</p>
</blockquote>
<p>明确定义的功能也可以启用可选的依赖项。只需在功能列表中包含可选依赖项的名称。例如，假设为了支持AVIF图像格式，我们的库需要启用另外两个依赖项：</p>
<pre><code class="language-toml">[dependencies]
ravif = { version = &quot;0.6.3&quot;, optional = true }
rgb = { version = &quot;0.8.25&quot;, optional = true }

[features]
avif = [&quot;ravif&quot;, &quot;rgb&quot;]
</code></pre>
<p>在本例中<code>avif</code>特性将启用列出的两个依赖项。</p>
<blockquote>
<p><strong>笔记</strong>：可选包含依赖项的另一种方法是使用<a href="reference/specifying-dependencies.html#platform-specific-dependencies">platform-specific dependencies</a>.这些功能不是使用功能，而是基于目标平台的条件。</p>
</blockquote>
<h3 id="dependency-features"><a class="header" href="#dependency-features">Dependency features</a></h3>
<p>依赖项的功能可以在依赖项声明中启用。这个<code>features</code>键指示要启用的功能：</p>
<pre><code class="language-toml">[dependencies]
# Enables the `derive` feature of serde.
serde = { version = &quot;1.0.118&quot;, features = [&quot;derive&quot;] }
</code></pre>
<p>这个<a href="reference/features.zh.html#the-default-feature"><code>default</code> features</a>可以使用禁用<code>default-features = false</code>:</p>
<pre><code class="language-toml">[dependencies]
flate2 = { version = &quot;1.0.3&quot;, default-features = false, features = [&quot;zlib&quot;] }
</code></pre>
<blockquote>
<p><strong>笔记</strong>：这可能无法确保禁用默认功能。如果另一个依赖项包括<code>flate2</code>没有具体说明<code>default-features = false</code>，则会启用默认功能。查看<a href="reference/features.zh.html#feature-unification">feature
unification</a>下面是更多细节。</p>
</blockquote>
<p>还可以在中启用依赖项的功能<code>[features]</code>桌子语法是<code>&quot;package-name/feature-name&quot;</code>.例如：</p>
<pre><code class="language-toml">[dependencies]
jpeg-decoder = { version = &quot;0.1.20&quot;, default-features = false }

[features]
# Enables parallel processing support by enabling the &quot;rayon&quot; feature of jpeg-decoder.
parallel = [&quot;jpeg-decoder/rayon&quot;]
</code></pre>
<blockquote>
<p><strong>笔记</strong>当前位置<code>&quot;package-name/feature-name&quot;</code>语法还将启用<code>package-name</code>如果是可选的依赖项。在夜间频道上，可以通过<a href="reference/unstable.html#weak-dependency-features">weak
dependency features</a>.</p>
</blockquote>
<h3 id="command-line-feature-options"><a class="header" href="#command-line-feature-options">Command-line feature options</a></h3>
<p>以下命令行标志可用于控制启用了哪些功能：</p>
<ul>
<li>
<p><code>--features</code> <em>特征</em>：启用列出的功能。多个要素可以用逗号或空格分隔。如果使用空格，请确保在从外壳（例如<code>--features &quot;foo bar&quot;</code>).如果在一个系统中构建多个包<a href="reference/workspaces.html">workspace</a>这个<code>package-name/feature-name</code>语法可用于指定特定工作区成员的功能。</p>
</li>
<li>
<p><code>--all-features</code>：激活命令行上选定的所有软件包的所有功能。</p>
</li>
<li>
<p><code>--no-default-features</code>：不激活<a href="reference/features.zh.html#the-default-feature"><code>default</code>
feature</a>所选软件包的名称。</p>
</li>
</ul>
<h3 id="feature-unification"><a class="header" href="#feature-unification">Feature unification</a></h3>
<p>功能对于定义它们的包来说是独一无二的。在包上启用功能不会在其他包上启用同名功能。</p>
<p>当一个依赖项被多个包使用时，Cargo在构建它时将使用该依赖项上启用的所有功能的并集。这有助于确保只使用依赖项的一个副本。看到了吗<a href="reference/resolver.html#features">features section</a>有关详细信息，请参阅解析器文档。</p>
<p>例如，让我们看看<a href="https://crates.io/crates/winapi"><code>winapi</code></a>使用<a href="https://github.com/retep998/winapi-rs/blob/0.3.9/Cargo.toml#L25-L431">large
number</a>有很多特点。如果你的包裹依赖于一个包裹<code>foo</code>它支持的“fileapi”和“handleapi”功能<code>winapi</code>，以及另一种依赖关系<code>bar</code>它启用了的“std”和“winnt”功能<code>winapi</code>然后<code>winapi</code>将在启用所有这四个功能的情况下构建。</p>
<p><img src="reference/../images/winapi-features.svg" alt="winapi features example" /></p>
<p>这样做的一个结果是，功能应该<em>添加剂</em>.也就是说，启用功能不应禁用功能，而且启用任何功能组合通常应该是安全的。功能不应引入<a href="reference/features.zh.html#semver-compatibility">SemVer-incompatible change</a>.</p>
<p>例如，如果您希望可选地支持<a href="reference/../../reference/names/preludes.html#the-no_std-attribute"><code>no_std</code></a>环境，<strong>不要</strong>使用<code>no_std</code>特色相反，使用<code>std</code>特色<em>使能够</em>
<code>std</code>.例如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![no_std]

<span class="boring">fn main() {
</span>#[cfg(feature = &quot;std&quot;)]
extern crate std;

#[cfg(feature = &quot;std&quot;)]
pub fn function_that_requires_std() {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="mutually-exclusive-features"><a class="header" href="#mutually-exclusive-features">Mutually exclusive features</a></h4>
<p>在极少数情况下，功能可能相互不兼容。如果可能的话，应该避免这种情况，因为它需要协调依赖关系图中包的所有使用，以避免将它们一起启用。如果不可能，请考虑添加编译错误来检测此场景。例如：</p>
<pre><code class="language-rust ignore">#[cfg(all(feature = &quot;foo&quot;, feature = &quot;bar&quot;))]
compile_error!(&quot;feature \&quot;foo\&quot; and feature \&quot;bar\&quot; cannot be enabled at the same time&quot;);
</code></pre>
<p>不要使用互斥的特征，考虑其他选项：</p>
<ul>
<li>将功能拆分为单独的包。</li>
<li>当发生冲突时，<a href="reference/features-examples.html#feature-precedence">choose one feature over
another</a>这个<a href="https://crates.io/crates/cfg-if"><code>cfg-if</code></a>软件包可以帮助编写更复杂的代码<code>cfg</code>表达。</li>
<li>设计代码以允许同时启用这些功能，并使用运行时选项来控制所使用的功能。例如，使用配置文件、命令行参数或环境变量来选择要启用的行为。</li>
</ul>
<h4 id="inspecting-resolved-features"><a class="header" href="#inspecting-resolved-features">Inspecting resolved features</a></h4>
<p>在复杂的依赖关系图中，有时很难理解如何在不同的软件包上启用不同的功能。这个<a href="reference/../commands/cargo-tree.html"><code>cargo tree</code></a>命令提供了几个选项来帮助检查和可视化哪些功能已启用。一些可供尝试的选项：</p>
<ul>
<li><code>cargo tree -e features</code>：这将在依赖关系图中显示功能。每个功能将显示哪个软件包启用了它。</li>
<li><code>cargo tree -f &quot;{p} {f}&quot;</code>：这是一个更紧凑的视图，显示每个软件包上启用的功能的逗号分隔列表。</li>
<li><code>cargo tree -e features -i foo</code>：这将反转树，显示功能如何流入给定的包“foo”。这可能很有用，因为查看整个图表可能会非常大，而且会让人不知所措。当您试图找出在特定软件包上启用了哪些功能以及为什么启用时，请使用此选项。请参见本文底部的示例<a href="reference/../commands/cargo-tree.html"><code>cargo tree</code></a>关于如何阅读这一页。</li>
</ul>
<h3 id="feature-resolver-version-2"><a class="header" href="#feature-resolver-version-2">Feature resolver version 2</a></h3>
<p>可以使用指定不同的功能分解程序<code>resolver</code>现场<code>Cargo.toml</code>，就像这样：</p>
<pre><code class="language-toml">[package]
name = &quot;my-package&quot;
version = &quot;1.0.0&quot;
resolver = &quot;2&quot;
</code></pre>
<p>看到了吗<a href="reference/resolver.html#resolver-versions">resolver versions</a>有关指定冲突解决程序版本的详细信息，请参见第节。</p>
<p>版本<code>&quot;2&quot;</code>在一些不需要统一特性的情况下，解析器可以避免统一特性。具体情况见下表<a href="reference/resolver.html#feature-resolver-version-2">resolver chapter</a>，但简而言之，它避免在以下情况下统一：</p>
<ul>
<li>在上启用的功能<a href="reference/specifying-dependencies.html#platform-specific-dependencies">platform-specific dependencies</a>对于当前未构建的目标，将忽略。</li>
<li><a href="reference/specifying-dependencies.html#build-dependencies">Build-dependencies</a>proc宏与普通依赖项不共享功能。</li>
<li><a href="reference/specifying-dependencies.html#development-dependencies">Dev-dependencies</a>除非构建了需要的目标（如测试或示例），否则不要激活功能。</li>
</ul>
<p>在某些情况下，避免统一是必要的。例如，如果生成依赖项启用<code>std</code>特性，并且相同的依赖项用作<code>no_std</code>环境，使能<code>std</code>会破坏建筑。</p>
<p>然而，一个缺点是，这可能会增加构建时间，因为依赖项被构建了多次（每个都有不同的功能）。使用该版本时<code>&quot;2&quot;</code>解析器，建议检查多次生成的依赖项，以减少总体生成时间。如果不是<em>必修的</em>要构建具有不同特性的复制包，请考虑将特性添加到<code>features</code>列表中的<a href="reference/features.zh.html#dependency-features">dependency
declaration</a>因此，复制品最终具有相同的特性（因此Cargo只构建一次）。您可以使用<a href="reference/../commands/cargo-tree.html"><code>cargo tree --duplicates</code></a>命令它将显示多次构建的包；查找列出的任何具有相同版本的条目。查看<a href="reference/features.zh.html#inspecting-resolved-features">Inspecting resolved
features</a>获取有关已解析功能的更多信息。对于生成依赖项，如果使用<code>--target</code>标记，因为在该场景中，生成依赖项总是与正常依赖项分开生成。</p>
<h4 id="resolver-version-2-command-line-flags"><a class="header" href="#resolver-version-2-command-line-flags">Resolver version 2 command-line flags</a></h4>
<p>这个<code>resolver = &quot;2&quot;</code>设置也会更改<code>--features</code>和<code>--no-default-features</code> <a href="reference/features.zh.html#command-line-feature-options">command-line options</a>.</p>
<p>有版本<code>&quot;1&quot;</code>，则只能在当前工作目录中为包启用功能。例如，在包含包的工作区中<code>foo</code>和<code>bar</code>，并且您位于包的目录中<code>foo</code>，然后执行命令<code>cargo build -p bar --features bar-feat</code>，这将失败，因为<code>--features</code>仅允许在上启用功能的标志<code>foo</code>.</p>
<p>具有<code>resolver = &quot;2&quot;</code>，features标志允许为在命令行上选择的任何软件包启用功能<code>-p</code>和<code>--workspace</code>选项。例如：</p>
<pre><code class="language-sh"># This command is allowed with resolver = &quot;2&quot;, regardless of which directory
# you are in.
cargo build -p foo -p bar --features foo-feat,bar-feat

# This explicit equivalent works with any resolver version:
cargo build -p foo -p bar --features foo/foo-feat,bar/bar-feat
</code></pre>
<p>此外<code>resolver = &quot;1&quot;</code>这个<code>--no-default-features</code>flag仅禁用当前目录中包的默认功能。对于版本“2”，它将禁用所有工作区成员的默认功能。</p>
<h3 id="build-scripts"><a class="header" href="#build-scripts">Build scripts</a></h3>
<p><a href="reference/build-scripts.html">Build scripts</a>可以通过检查<code>CARGO_FEATURE_&lt;name&gt;</code>环境变量，在哪里<code>&lt;name&gt;</code>功能名称是否已转换为大写和小写<code>-</code>皈依<code>_</code>.</p>
<h3 id="required-features"><a class="header" href="#required-features">Required features</a></h3>
<p>这个<a href="reference/cargo-targets.html#the-required-features-field"><code>required-features</code> field</a>可用于禁用特定的<a href="reference/cargo-targets.html">Cargo
targets</a>如果功能未启用。有关更多详细信息，请参阅链接文档。</p>
<h3 id="semver-compatibility"><a class="header" href="#semver-compatibility">SemVer compatibility</a></h3>
<p>启用功能不应引入SemVer不兼容的更改。例如，该功能不应以可能破坏现有用途的方式更改现有API。有关哪些更改兼容的更多详细信息，请参阅<a href="reference/semver.html">SemVer Compatibility chapter</a>.</p>
<p>添加和删除功能定义和可选依赖项时应小心，因为这些有时可能是向后不兼容的更改。更多详细信息请参见<a href="reference/semver.html#cargo">Cargo section</a>在SemVer兼容性章节中。简而言之，遵循以下规则：</p>
<ul>
<li>在小版本中，通常可以安全地执行以下操作：
<ul>
<li>添加一个<a href="reference/semver.html#cargo-feature-add">new feature</a>或<a href="reference/semver.html#cargo-dep-add">optional dependency</a>.</li>
<li><a href="reference/semver.html#cargo-change-dep-feature">Change the features used on a dependency</a>.</li>
</ul>
</li>
<li>通常应注意以下几点：<strong>不</strong>在小版本中完成：
<ul>
<li><a href="reference/semver.html#cargo-feature-remove">Remove a feature</a>或<a href="reference/semver.html#cargo-remove-opt-dep">optional dependency</a>.</li>
<li><a href="reference/semver.html#item-remove">Moving existing public code behind a feature</a>.</li>
<li><a href="reference/semver.html#cargo-feature-remove-another">Remove a feature from a feature list</a>.</li>
</ul>
</li>
</ul>
<p>有关注意事项和示例，请参见链接。</p>
<h3 id="feature-documentation-and-discovery"><a class="header" href="#feature-documentation-and-discovery">Feature documentation and discovery</a></h3>
<p>我们鼓励您记录软件包中提供的功能。这可以通过添加<a href="reference/../../rustdoc/how-to-write-documentation.html">doc comments</a>在顶部<code>lib.rs</code>.作为示例，请参见<a href="https://github.com/rust-lang/regex/blob/1.4.2/src/lib.rs#L488-L583">regex crate source</a>，渲染时可以在<a href="https://docs.rs/regex/1.4.2/regex/#crate-features">docs.rs</a>如果您有其他文档，例如用户指南，请考虑在那里添加文档（例如，参见<a href="https://serde.rs/feature-flags.html">serde.rs</a>如果您有一个二进制项目，请考虑在项目的自述文件或其他文档中记录特性（例如，参见<a href="https://github.com/mozilla/sccache/blob/0.2.13/README.md#build-requirements">sccache</a>).</p>
<p>清楚地记录这些特性可以设定对被认为“不稳定”或不应该使用的特性的期望。例如，如果存在可选依赖项，但不希望用户将该可选依赖项明确列为功能，请将其从文档列表中排除。</p>
<p>发表于<a href="https://docs.rs/">docs.rs</a>可以在中使用元数据<code>Cargo.toml</code>控制在生成文档时启用哪些功能。查看<a href="https://docs.rs/about/metadata">docs.rs metadata documentation</a>更多细节。</p>
<blockquote>
<p><strong>笔记</strong>：Rustdoc实验性地支持注释文档，以指示使用某些API需要哪些功能。看到了吗<a href="reference/../../unstable-book/language-features/doc-cfg.html"><code>doc_cfg</code></a>有关更多详细信息，请参阅文档。例如<a href="https://docs.rs/syn/1.0.54/syn/#modules"><code>syn</code>
documentation</a>，您可以看到彩色框，其中注明了使用它所需的功能。</p>
</blockquote>
<h4 id="discovering-features"><a class="header" href="#discovering-features">Discovering features</a></h4>
<p>当特性被记录在库API中时，用户可以更容易地发现哪些特性可用以及它们的用途。如果软件包的功能文档不可用，可以查看<code>Cargo.toml</code>文件，但有时很难找到它。箱子页面<a href="https://crates.io/">crates.io</a>有到源存储库的链接（如果可用）。像这样的工具<a href="reference/../commands/cargo-vendor.html"><code>cargo vendor</code></a>或<a href="https://crates.io/crates/cargo-clone-crate">cargo-clone-crate</a>可以用来下载源代码并检查它。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="features-examples"><a class="header" href="#features-examples">Features Examples</a></h2>
<p>下面展示了一些实际的功能示例。</p>
<h3 id="minimizing-build-times-and-file-sizes"><a class="header" href="#minimizing-build-times-and-file-sizes">Minimizing build times and file sizes</a></h3>
<p>有些软件包使用特性，因此如果未启用这些特性，它会减小机箱的大小并缩短编译时间。例如：</p>
<ul>
<li><a href="https://crates.io/crates/syn"><code>syn</code></a>是一种用于解析锈迹代码的流行箱子。由于它非常流行，因此有助于减少编译时间，因为它会影响很多项目。它有一个<a href="https://docs.rs/syn/1.0.54/syn/#optional-features">clearly documented list</a>可用于最小化其包含的代码量的功能。</li>
<li><a href="https://crates.io/crates/regex"><code>regex</code></a>有一个<a href="https://github.com/rust-lang/regex/blob/1.4.2/Cargo.toml#L33-L101">several features</a>那是<a href="https://docs.rs/regex/1.4.2/regex/#crate-features">well
documented</a>.删除Unicode支持可以减少生成的文件大小，因为它可以删除一些大型表。</li>
<li><a href="https://crates.io/crates/winapi"><code>winapi</code></a>有<a href="https://github.com/retep998/winapi-rs/blob/0.3.9/Cargo.toml#L25-L431">a large number</a>限制其支持的Windows API绑定的功能。</li>
<li><a href="https://crates.io/crates/web-sys"><code>web-sys</code></a>另一个例子与<code>winapi</code>这提供了一个<a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/crates/web-sys/Cargo.toml#L32-L1395">huge
surface area</a>受使用功能限制的API绑定。</li>
</ul>
<h3 id="extending-behavior"><a class="header" href="#extending-behavior">Extending behavior</a></h3>
<p>这个<a href="https://crates.io/crates/serde_json"><code>serde_json</code></a>包裹上有一个<a href="https://github.com/serde-rs/json/blob/v1.0.60/Cargo.toml#L53-L56"><code>preserve_order</code> feature</a>哪一个<a href="https://github.com/serde-rs/json/blob/v1.0.60/src/map.rs#L23-L26">changes the behavior</a>JSON映射，以保留键插入的顺序。请注意，它启用了可选的依赖项<a href="https://crates.io/crates/indexmap"><code>indexmap</code></a>实施新的行为。</p>
<p>当改变这样的行为时，要小心确保这些改变是正确的<a href="reference/features.html#semver-compatibility">SemVer compatible</a>。也就是说，启用该功能不应破坏通常在关闭该功能的情况下生成的代码。</p>
<h3 id="no_std-support"><a class="header" href="#no_std-support"><code>no_std</code> support</a></h3>
<p>有些软件包希望同时支持这两种功能<a href="reference/../../reference/names/preludes.html#the-no_std-attribute"><code>no_std</code></a>和<code>std</code>环境。这对于支持嵌入式和资源受限的平台很有用，但仍然允许扩展支持完整标准库的平台的功能。</p>
<p>这个<a href="https://crates.io/crates/wasm-bindgen"><code>wasm-bindgen</code></a>包定义了<a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/Cargo.toml#L25"><code>std</code> feature</a>就是<a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/Cargo.toml#L23">enabled by default</a>.在图书馆的顶层<a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/src/lib.rs#L8">unconditionally enables the <code>no_std</code> attribute</a>.这确保<code>std</code>还有<a href="reference/../../std/prelude/index.html"><code>std</code> prelude</a>不自动在范围内。然后，在代码的各个地方(<a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/src/lib.rs#L270-L273">example1</a>, <a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/src/lib.rs#L67-L75">example2</a>)，它使用<code>#[cfg(feature = &quot;std&quot;)]</code>属性有条件地启用需要的额外功能<code>std</code>.</p>
<h3 id="re-exporting-dependency-features"><a class="header" href="#re-exporting-dependency-features">Re-exporting dependency features</a></h3>
<p>可以方便地从依赖项重新导出功能。这允许依赖于箱子的用户控制这些特性，而无需直接指定这些依赖项。例如[<code>regex</code>]<a href="https://github.com/rust-lang/regex/blob/1.4.2/Cargo.toml#L65-L89">re-exports the features</a>从<a href="https://github.com/rust-lang/regex/blob/1.4.2/regex-syntax/Cargo.toml#L17-L32"><code>regex_syntax</code></a>包裹用户<code>regex</code>不需要知道<code>regex_syntax</code>但他们仍然可以访问它包含的功能。</p>
<h3 id="vendoring-of-c-libraries"><a class="header" href="#vendoring-of-c-libraries">Vendoring of C libraries</a></h3>
<p>有些软件包提供到通用C库的绑定（有时称为<a href="reference/build-scripts.html#-sys-packages">“sys” crates</a>)。有时，这些软件包让您可以选择使用系统上安装的C库，或者从源代码构建它。例如<a href="https://crates.io/crates/openssl"><code>openssl</code></a>包裹上有一个<a href="https://github.com/sfackler/rust-openssl/blob/openssl-v0.10.31/openssl/Cargo.toml#L19"><code>vendored</code> feature</a>这使得相应的<code>vendored</code>特点<a href="https://crates.io/crates/openssl-sys"><code>openssl-sys</code></a>这个<code>openssl-sys</code>构建脚本有一些<a href="https://github.com/sfackler/rust-openssl/blob/openssl-v0.10.31/openssl-sys/build/main.rs#L47-L54">conditional logic</a>这导致它从OpenSSL源代码的本地副本构建，而不是使用系统中的版本。</p>
<p>这个<a href="https://crates.io/crates/curl-sys"><code>curl-sys</code></a>包是<a href="https://github.com/alexcrichton/curl-rust/blob/0.4.34/curl-sys/Cargo.toml#L49"><code>static-curl</code>
feature</a>使其从源代码构建libcurl。请注意，它还有一个<a href="https://github.com/alexcrichton/curl-rust/blob/0.4.34/curl-sys/Cargo.toml#L52"><code>force-system-lib-on-osx</code></a>迫使它的特征<a href="https://github.com/alexcrichton/curl-rust/blob/0.4.34/curl-sys/build.rs#L15-L20">to use the system libcurl</a>，覆盖静态卷曲设置。</p>
<h3 id="feature-precedence"><a class="header" href="#feature-precedence">Feature precedence</a></h3>
<p>有些软件包可能具有相互排斥的功能。处理这一问题的一个选择是选择一个特性而不是另一个。这个<a href="https://crates.io/crates/log"><code>log</code></a>包就是一个例子。是的<a href="https://github.com/rust-lang/log/blob/0.4.11/Cargo.toml#L29-L42">several features</a>用于在编译时选择所述的最大日志记录级别<a href="https://docs.rs/log/0.4.11/log/#compile-time-filters">here</a>.它使用<a href="https://crates.io/crates/cfg-if"><code>cfg-if</code></a>到<a href="https://github.com/rust-lang/log/blob/0.4.11/src/lib.rs#L1422-L1448">choose a
precedence</a>。如果启用了多个功能，则与较低级别相比，更高的“最大”级别将更受欢迎。</p>
<h3 id="proc-macro-companion-package"><a class="header" href="#proc-macro-companion-package">Proc-macro companion package</a></h3>
<p>有些软件包有一个与之密切相关的proc宏。但是，并非所有用户都需要使用proc宏。通过将proc宏设置为可选依赖项，可以方便地选择是否包含它。这很有帮助，因为有时proc宏版本必须与父包保持同步，并且您不希望强制用户必须指定这两个依赖项并保持它们同步。</p>
<p>例如<a href="https://crates.io/crates/serde"><code>serde</code></a>它有一个<a href="https://github.com/serde-rs/serde/blob/v1.0.118/serde/Cargo.toml#L34-L35"><code>derive</code></a>使<a href="https://crates.io/crates/serde_derive"><code>serde_derive</code></a>过程宏。这个<code>serde_derive</code>箱子被紧紧地绑在一起<code>serde</code>，所以它使用<a href="https://github.com/serde-rs/serde/blob/v1.0.118/serde/Cargo.toml#L17">equals version
requirement</a>以确保它们保持同步。</p>
<h3 id="nightly-only-features"><a class="header" href="#nightly-only-features">Nightly-only features</a></h3>
<p>一些软件包想要尝试API或语言功能，这些功能只在Rust上可用<a href="reference/../../book/appendix-07-nightly-rust.html">nightly channel</a>.但是，他们可能不想要求用户也使用夜间频道。例如<a href="https://crates.io/crates/wasm-bindgen"><code>wasm-bindgen</code></a>它有一个<a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/Cargo.toml#L27"><code>nightly</code> feature</a>这使得<a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/src/closure.rs#L257-L269">extended API</a>使用<a href="reference/../../std/marker/trait.Unsize.html"><code>Unsize</code></a>在撰写本文时，只在夜间频道提供的标记特征。</p>
<p>请注意，在它使用的箱子的底部<a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/src/lib.rs#L11"><code>cfg_attr</code> to enable the nightly
feature</a>.记住<a href="reference/../../unstable-book/index.html"><code>feature</code> attribute</a>与Cargo特性无关，用于选择实验性语言特性。</p>
<p>这个<a href="https://github.com/rust-random/rand/blob/0.7.3/Cargo.toml#L40"><code>simd_support</code> feature</a>关于<a href="https://crates.io/crates/rand"><code>rand</code></a>package是另一个例子，它依赖于只在夜间频道上构建的依赖项。</p>
<h3 id="experimental-features"><a class="header" href="#experimental-features">Experimental features</a></h3>
<p>有些软件包有新的功能，他们可能想试用，而不必保证这些API的稳定性。这些特性通常被记录为实验性的，因此将来可能会改变或中断，即使是在一个小版本中。例如<a href="https://crates.io/crates/async-std"><code>async-std</code></a>包，它有一个<a href="https://github.com/async-rs/async-std/blob/v1.8.0/Cargo.toml#L38-L42"><code>unstable</code> feature</a>哪一个<a href="https://github.com/async-rs/async-std/blob/v1.8.0/src/macros.rs#L46">gates
new APIs</a>人们可以选择使用，但可能还没有完全准备好被依赖。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="profiles"><a class="header" href="#profiles">Profiles</a></h2>
<p>配置文件提供了一种改变编译器设置的方法，从而影响优化和调试符号等内容。</p>
<p>Cargo有4个内置配置文件：<code>dev</code>, <code>release</code>, <code>test</code>和<code>bench</code>。如果未在命令行上指定配置文件，则会根据正在运行的命令自动选择配置文件。除了内置配置文件外，还可以指定自定义用户定义的配置文件。</p>
<p>配置文件设置可以在中更改<a href="reference/manifest.html"><code>Cargo.toml</code></a>和<code>[profile]</code>桌子在每个命名的配置文件中，可以使用如下键/值对更改各个设置：</p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1               # Use slightly better optimizations.
overflow-checks = false     # Disable integer overflow checks.
</code></pre>
<p>Cargo只查看<code>Cargo.toml</code>在工作区的根目录下显示。依赖项中定义的配置文件设置将被忽略。</p>
<p>此外，配置文件可以从<a href="reference/config.html">config</a>释义在配置文件或环境变量中指定配置文件将覆盖<code>Cargo.toml</code>.</p>
<h3 id="profile-settings"><a class="header" href="#profile-settings">Profile settings</a></h3>
<p>以下是可在配置文件中控制的设置列表。</p>
<h4 id="opt-level"><a class="header" href="#opt-level">opt-level</a></h4>
<p>这个<code>opt-level</code>设置控制<a href="reference/../../rustc/codegen-options/index.html#opt-level"><code>-C opt-level</code> flag</a>它控制着优化的水平。更高的优化级别可能会以更长的编译时间为代价生成更快的运行时代码。更高级别也可能会更改和重新排列编译后的代码，这可能会使其更难与调试器一起使用。</p>
<p>有效选项包括：</p>
<ul>
<li><code>0</code>：没有优化</li>
<li><code>1</code>：基本优化</li>
<li><code>2</code>：一些优化</li>
<li><code>3</code>：所有优化</li>
<li><code>&quot;s&quot;</code>：优化二进制大小</li>
<li><code>&quot;z&quot;</code>：优化二进制大小，但也关闭循环矢量化。</li>
</ul>
<p>建议尝试不同的级别，为项目找到合适的平衡点。可能会有令人惊讶的结果，比如<code>3</code>慢于<code>2</code>，或<code>&quot;s&quot;</code>和<code>&quot;z&quot;</code>水平不一定更小。随着时间的推移，您可能还希望重新评估您的设置，使其成为新版本的<code>rustc</code>改变优化行为。</p>
<p>另见<a href="reference/../../rustc/profile-guided-optimization.html">Profile Guided Optimization</a>获取更高级的优化技术。</p>
<h4 id="debug"><a class="header" href="#debug">debug</a></h4>
<p>这个<code>debug</code>设置控制<a href="reference/../../rustc/codegen-options/index.html#debuginfo"><code>-C debuginfo</code> flag</a>它控制编译的二进制文件中包含的调试信息量。</p>
<p>有效选项包括：</p>
<ul>
<li><code>0</code>或<code>false</code>：完全没有调试信息</li>
<li><code>1</code>：仅限行表</li>
<li><code>2</code>或<code>true</code>：完整调试信息</li>
</ul>
<p>您可能还希望配置<a href="reference/profiles.zh.html#split-debuginfo"><code>split-debuginfo</code></a>根据您的需要选择。</p>
<h4 id="split-debuginfo"><a class="header" href="#split-debuginfo">split-debuginfo</a></h4>
<p>这个<code>split-debuginfo</code>设置控制<a href="reference/../../rustc/codegen-options/index.html#split-debuginfo"><code>-C split-debuginfo</code> flag</a>它控制调试信息（如果生成）是放在可执行文件本身还是与之相邻。</p>
<p>此选项是一个字符串，可接受的值与<a href="reference/../../rustc/codegen-options/index.html#split-debuginfo">compiler accepts</a>。此选项的默认值为<code>unpacked</code>在macOS上，用于启用调试信息的配置文件。否则，此选项的默认值为<a href="reference/../../rustc/codegen-options/index.html#split-debuginfo">documented with rustc</a>而且是特定于平台的。有些选项仅在<a href="reference/../../book/appendix-07-nightly-rust.html">nightly channel</a>.一旦再次进行测试，并且对DWARF的支持稳定，Cargo默认值可能会在未来发生变化。</p>
<h4 id="debug-assertions"><a class="header" href="#debug-assertions">debug-assertions</a></h4>
<p>这个<code>debug-assertions</code>设置控制<a href="reference/../../rustc/codegen-options/index.html#debug-assertions"><code>-C debug-assertions</code> flag</a>哪个转弯<code>cfg(debug_assertions)</code> <a href="reference/../../reference/conditional-compilation.html#debug_assertions">conditional compilation</a>开或关。调试断言旨在包括仅在调试/开发版本中可用的运行时验证。在发布版本中，这些可能过于昂贵或不受欢迎。调试断言支持<a href="reference/../../std/macro.debug_assert.html"><code>debug_assert!</code> macro</a>在标准库中。</p>
<p>有效选项包括：</p>
<ul>
<li><code>true</code>：启用</li>
<li><code>false</code>：禁用</li>
</ul>
<h4 id="overflow-checks"><a class="header" href="#overflow-checks">overflow-checks</a></h4>
<p>这个<code>overflow-checks</code>设置控制<a href="reference/../../rustc/codegen-options/index.html#overflow-checks"><code>-C overflow-checks</code> flag</a>它控制着<a href="reference/../../reference/expressions/operator-expr.html#overflow">runtime integer overflow</a>。当启用溢出检查时，溢出将发生死机。</p>
<p>有效选项包括：</p>
<ul>
<li><code>true</code>：启用</li>
<li><code>false</code>：禁用</li>
</ul>
<h4 id="lto"><a class="header" href="#lto">lto</a></h4>
<p>这个<code>lto</code>设置控制<a href="reference/../../rustc/codegen-options/index.html#lto"><code>-C lto</code> flag</a>控制LLVM的<a href="https://llvm.org/docs/LinkTimeOptimization.html">link
time optimizations</a>.LTO可以使用整个程序分析，以更长的链接时间为代价，生成更好的优化代码。</p>
<p>有效选项包括：</p>
<ul>
<li><code>false</code>：执行“精简本地LTO”，仅在本地箱子上的所有箱子上执行“精简”LTO<a href="reference/profiles.zh.html#codegen-units">codegen units</a>.如果codegen单位为1或1，则不执行LTO<a href="reference/profiles.zh.html#opt-level">opt-level</a>是0。</li>
<li><code>true</code>或<code>&quot;fat&quot;</code>：执行“fat”LTO，尝试对依赖关系图中的所有箱子执行优化。</li>
<li><code>&quot;thin&quot;</code>：表演<a href="http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html">“thin” LTO</a>。这与“fat”类似，但运行时间大大缩短，同时仍能获得类似于“fat”的性能提升。</li>
<li><code>&quot;off&quot;</code>：禁用LTO。</li>
</ul>
<p>另见<a href="reference/../../rustc/codegen-options/index.html#linker-plugin-lto"><code>-C linker-plugin-lto</code></a> <code>rustc</code>跨语言LTO的标志。</p>
<h4 id="panic"><a class="header" href="#panic">panic</a></h4>
<p>这个<code>panic</code>设置控制<a href="reference/../../rustc/codegen-options/index.html#panic"><code>-C panic</code> flag</a>它控制着使用哪种恐慌策略。</p>
<p>有效选项包括：</p>
<ul>
<li><code>&quot;unwind&quot;</code>：惊慌失措时，松开堆叠。</li>
<li><code>&quot;abort&quot;</code>：恐慌时终止进程。</li>
</ul>
<p>当设置为<code>&quot;unwind&quot;</code>，实际值取决于目标平台的默认值。例如，NVPTX平台不支持退绕，所以它总是使用<code>&quot;abort&quot;</code>.</p>
<p>测试、基准测试、构建脚本和过程宏忽略了<code>panic</code>背景这个<code>rustc</code>测试线束目前需要<code>unwind</code>行为看到了吗<a href="reference/unstable.html#panic-abort-tests"><code>panic-abort-tests</code></a>不稳定的标志，使<code>abort</code>行为</p>
<p>此外，当使用<code>abort</code>策略和构建测试时，所有依赖项也将被迫与<code>unwind</code>策略</p>
<h4 id="incremental"><a class="header" href="#incremental">incremental</a></h4>
<p>这个<code>incremental</code>设置控制<a href="reference/../../rustc/codegen-options/index.html#incremental"><code>-C incremental</code> flag</a>它控制是否启用增量编译。增量编译原因<code>rustc</code>将其他信息保存到磁盘，以便在重新编译箱子时重复使用，从而缩短重新编译时间。附加信息存储在<code>target</code>目录</p>
<p>有效选项包括：</p>
<ul>
<li><code>true</code>：启用</li>
<li><code>false</code>：禁用</li>
</ul>
<p>增量编译仅用于工作区成员和“路径”依赖项。</p>
<p>增量值可以用<code>CARGO_INCREMENTAL</code>
<a href="reference/environment-variables.html">environment variable</a>或者<a href="reference/config.html#buildincremental"><code>build.incremental</code></a>配置变量。</p>
<h4 id="codegen-units"><a class="header" href="#codegen-units">codegen-units</a></h4>
<p>这个<code>codegen-units</code>设置控制<a href="reference/../../rustc/codegen-options/index.html#codegen-units"><code>-C codegen-units</code> flag</a>控制一个箱子将被分成多少个“代码生成单元”。更多的代码生成单元允许并行处理更多的箱子，这可能会减少编译时间，但可能会生成较慢的代码。</p>
<p>此选项接受大于0的整数。</p>
<p>默认值为256<a href="reference/profiles.zh.html#incremental">incremental</a>构建，16个用于非增量构建。</p>
<h4 id="rpath"><a class="header" href="#rpath">rpath</a></h4>
<p>这个<code>rpath</code>设置控制<a href="reference/../../rustc/codegen-options/index.html#rpath"><code>-C rpath</code> flag</a>它控制着是否<a href="https://en.wikipedia.org/wiki/Rpath"><code>rpath</code></a>已启用。</p>
<h3 id="default-profiles"><a class="header" href="#default-profiles">Default profiles</a></h3>
<h4 id="dev"><a class="header" href="#dev">dev</a></h4>
<p>这个<code>dev</code>配置文件用于正常的开发和调试。这是构建命令的默认设置，如<a href="reference/../commands/cargo-build.html"><code>cargo build</code></a>.</p>
<p>默认设置为<code>dev</code>个人资料包括：</p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0
debug = true
split-debuginfo = '...'  # Platform-specific.
debug-assertions = true
overflow-checks = true
lto = false
panic = 'unwind'
incremental = true
codegen-units = 256
rpath = false
</code></pre>
<h4 id="release"><a class="header" href="#release">release</a></h4>
<p>这个<code>release</code>概要文件旨在用于发布和生产中使用的优化工件。当<code>--release</code>将使用标志，并且是的默认值<a href="reference/../commands/cargo-install.html"><code>cargo install</code></a>.</p>
<p>默认设置为<code>release</code>个人资料包括：</p>
<pre><code class="language-toml">[profile.release]
opt-level = 3
debug = false
split-debuginfo = '...'  # Platform-specific.
debug-assertions = false
overflow-checks = false
lto = false
panic = 'unwind'
incremental = false
codegen-units = 16
rpath = false
</code></pre>
<h4 id="test"><a class="header" href="#test">test</a></h4>
<p>这个<code>test</code>profile是用户使用的默认配置文件<a href="reference/../commands/cargo-test.html"><code>cargo test</code></a>这个<code>test</code>配置文件从<a href="reference/profiles.zh.html#dev"><code>dev</code></a>轮廓</p>
<h4 id="bench"><a class="header" href="#bench">bench</a></h4>
<p>这个<code>bench</code>profile是用户使用的默认配置文件<a href="reference/../commands/cargo-bench.html"><code>cargo bench</code></a>这个<code>bench</code>配置文件从<a href="reference/profiles.zh.html#release"><code>release</code></a>轮廓</p>
<h4 id="build-dependencies-1"><a class="header" href="#build-dependencies-1">Build Dependencies</a></h4>
<p>默认情况下，所有配置文件都不会优化生成依赖项（生成脚本、过程宏及其依赖项）。生成替代的默认设置为：</p>
<pre><code class="language-toml">[profile.dev.build-override]
opt-level = 0
codegen-units = 256

[profile.release.build-override]
opt-level = 0
codegen-units = 256
</code></pre>
<p>生成依赖项以其他方式继承正在使用的活动配置文件中的设置，如中所述<a href="reference/profiles.zh.html#profile-selection">Profile selection</a>.</p>
<h3 id="custom-profiles"><a class="header" href="#custom-profiles">Custom profiles</a></h3>
<p>除了内置配置文件外，还可以定义其他自定义配置文件。这些对于设置多个工作流和构建模式可能很有用。定义自定义配置文件时，必须指定<code>inherits</code>键指定未指定设置时自定义配置文件从哪个配置文件继承设置。</p>
<p>例如，假设您想要比较一个普通的发布版本和一个具有<a href="reference/profiles.zh.html#lto">LTO</a>在优化中，可以指定如下内容：<code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[profile.release-lto]
inherits = &quot;release&quot;
lto = true
</code></pre>
<p>这个<code>--profile</code>然后可以使用标志选择此自定义配置文件：</p>
<pre><code class="language-console">cargo build --profile release-lto
</code></pre>
<p>每个概要文件的输出将被放置在与中的概要文件同名的目录中<a href="reference/../guide/build-cache.html"><code>target</code> directory</a>.如上例所示，输出将进入<code>target/release-lto</code>目录</p>
<h3 id="profile-selection"><a class="header" href="#profile-selection">Profile selection</a></h3>
<p>使用的配置文件取决于命令，命令行标志如<code>--release</code>或<code>--profile</code>，以及包裹（如果是<a href="reference/profiles.zh.html#overrides">overrides</a>)。如果未指定任何配置文件，则默认配置文件为：</p>
<table><thead><tr><th>命令</th><th>默认配置文件</th></tr></thead><tbody>
<tr><td><a href="reference/../commands/cargo-run.html"><code>cargo run</code></a>, <a href="reference/../commands/cargo-build.html"><code>cargo build</code></a>,<br><a href="reference/../commands/cargo-check.html"><code>cargo check</code></a>, <a href="reference/../commands/cargo-rustc.html"><code>cargo rustc</code></a></td><td><a href="reference/profiles.zh.html#dev"><code>dev</code> profile</a></td></tr>
<tr><td><a href="reference/../commands/cargo-test.html"><code>cargo test</code></a></td><td><a href="reference/profiles.zh.html#test"><code>test</code> profile</a></td></tr>
<tr><td><a href="reference/../commands/cargo-bench.html"><code>cargo bench</code></a></td><td><a href="reference/profiles.zh.html#bench"><code>bench</code> profile</a></td></tr>
<tr><td><a href="reference/../commands/cargo-install.html"><code>cargo install</code></a></td><td><a href="reference/profiles.zh.html#release"><code>release</code> profile</a></td></tr>
</tbody></table>
<p>您可以使用<code>--profile=NAME</code>将使用给定配置文件的选项。这个<code>--release</code>国旗相当于<code>--profile=release</code>.</p>
<p>所选配置文件适用于所有Cargo目标，包括<a href="reference/./cargo-targets.html#library">library</a>, <a href="reference/./cargo-targets.html#binaries">binary</a>,  <a href="reference/./cargo-targets.html#examples">example</a>,  <a href="reference/./cargo-targets.html#tests">test</a>和<a href="reference/./cargo-targets.html#benchmarks">benchmark</a>.</p>
<p>可以使用指定特定包的配置文件<a href="reference/profiles.zh.html#overrides">overrides</a>，如下所述。</p>
<h3 id="overrides"><a class="header" href="#overrides">Overrides</a></h3>
<p>可以覆盖特定软件包和构建时箱子的配置文件设置。要覆盖特定软件包的设置，请使用<code>package</code>表更改命名包的设置：</p>
<pre><code class="language-toml"># The `foo` package will use the -Copt-level=3 flag.
[profile.dev.package.foo]
opt-level = 3
</code></pre>
<p>包名实际上是一个<a href="reference/pkgid-spec.html">Package ID Spec</a>，因此您可以使用以下语法将包的各个版本作为目标：<code>[profile.dev.package.&quot;foo:2.1.0&quot;]</code>.</p>
<p>要覆盖所有依赖项（但不是任何工作区成员）的设置，请使用<code>&quot;*&quot;</code>软件包名称：</p>
<pre><code class="language-toml"># Set the default for dependencies.
[profile.dev.package.&quot;*&quot;]
opt-level = 2
</code></pre>
<p>要覆盖生成脚本、过程宏及其依赖项的设置，请使用<code>build-override</code>表：</p>
<pre><code class="language-toml"># Set the settings for build scripts and proc-macros.
[profile.dev.build-override]
opt-level = 3
</code></pre>
<blockquote>
<p>注意：当一个依赖项既是普通依赖项又是构建依赖项时，Cargo将在以下情况下尝试只构建一次<code>--target</code>未指定。使用时<code>build-override</code>，依赖项可能需要生成两次，一次作为正常依赖项，一次使用重写的生成设置。这可能会增加初始构建时间。</p>
</blockquote>
<p>使用值的优先顺序如下（第一场比赛获胜）：</p>
<ol>
<li><code>[profile.dev.package.name]</code>-一个命名的包。</li>
<li><code>[profile.dev.package.&quot;*&quot;]</code>-对于任何非工作区成员。</li>
<li><code>[profile.dev.build-override]</code>-仅适用于生成脚本、过程宏及其依赖项。</li>
<li><code>[profile.dev]</code>-设置在<code>Cargo.toml</code>.</li>
<li>Cargo中内置的默认值。</li>
</ol>
<p>覆盖不能指定<code>panic</code>, <code>lto</code>或<code>rpath</code>设置。</p>
<h4 id="overrides-and-generics"><a class="header" href="#overrides-and-generics">Overrides and generics</a></h4>
<p>实例化泛型代码的位置将影响用于该泛型代码的优化设置。当使用配置文件覆盖更改特定箱子的优化级别时，这可能会导致微妙的交互。如果试图提高定义泛型函数的依赖项的优化级别，则在本地箱子中使用这些泛型函数时可能无法进行优化。这是因为代码可能会在实例化的箱子中生成，因此可能会使用该箱子的优化设置。</p>
<p>例如<a href="https://crates.io/crates/nalgebra">nalgebra</a>是一个定义向量和矩阵的库，大量使用通用参数。如果您的本地代码定义了具体的nalgebra类型，比如<code>Vector4&lt;f64&gt;</code>并使用他们的方法，相应的nalgebra代码将被实例化并构建在您的箱子中。因此，如果您试图提高<code>nalgebra</code>使用配置文件覆盖可能不会带来更快的性能。</p>
<p>使问题进一步复杂化，<code>rustc</code>有一些优化，它将尝试在箱子之间共享单晶仿制药。如果opt级别为2或3，则箱子将不会使用其他箱子中的单形态仿制药，也不会出口本地定义的单形态产品与其他箱子共享。当尝试优化依赖关系来开发时，请考虑尝试OPT级1，它将应用一些优化，同时仍允许共享单态化项。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="配置"><a class="header" href="#配置">配置</a></h2>
<p>本文档将解释 Cargo 的配置系统如何工作，以及可用的字段或配置。有关通过其清单，来配置程序包的信息，请参阅<a href="reference/./manifest.zh.html">清单格式</a>.</p>
<h3 id="hierarchical-structure"><a class="header" href="#hierarchical-structure">Hierarchical structure</a></h3>
<p>分层策略</p>
<p>Cargo 允许特定包，具有本地配置以及全局配置，就像 git 一样。Cargo 将其扩展为分层策略。例如，如果在<code>/projects/foo/bar/baz</code>调用 Cargo，然后将按以下顺序，探测和统一配置文件:</p>
<ul>
<li><code>/projects/foo/bar/baz/.cargo/config</code></li>
<li><code>/projects/foo/bar/.cargo/config</code></li>
<li><code>/projects/foo/.cargo/config</code></li>
<li><code>/projects/.cargo/config</code></li>
<li><code>/.cargo/config</code></li>
<li><code>$HOME/.cargo/config</code></li>
</ul>
<p>使用此结构，您可以为每个包指定配置，甚至可以将其检入版本控制。您还可以在主目录中，使用指定默认值的配置文件。</p>
<h3 id="configuration-format"><a class="header" href="#configuration-format">Configuration format</a></h3>
<p>配置格式</p>
<p>所有配置目前都在<a href="https://github.com/toml-lang/toml">TOML 格式</a>(与 Cargo.toml 清单一样)，在字段(表格)内部使用简单的键值对，它们都被合并在一起。</p>
<h3 id="configuration-keys"><a class="header" href="#configuration-keys">Configuration keys</a></h3>
<p>配置字段</p>
<p>以下所有字段都是可选的，除非另有说明，否则它们的默认值将作为其值。</p>
<p>指定工具的键值可以给出，一个‘绝对路径，相对路径或无路径工具名称’。给定的绝对路径和无路径工具名称直接使用。相对路径，则解析相对于<code>.cargo</code>目录的父目录，配置文件就居住在里面。</p>
<pre><code class="language-bash"># 路径数组，指向本地将要覆盖依赖项的存储库.
# 更多信息，请看 指定 依赖项 指南.
paths = [&quot;/path/to/override&quot;]

[cargo-new]
# 这是你 放 name/email 的地方， 在一个新Cargo.toml中的
#`authors` 表格就会生成。若不存在， 那 `git` 会去调查， 若还是不
# 存在，那 `$USER` 和 `$EMAIL` 会被使用.
name = &quot;...&quot;
email = &quot;...&quot;

# 默认来说， `cargo new` 会初始化一个新的  Git repository. 该字段若设为 `hg` ，就是新建一个 Mercurial repository， 或 `none` 禁用此行为.
vcs = &quot;none&quot;

# 接下来的 部分， $triple 是 一些有效目标 triple的引用， 而不是一个字面量&quot;$triple&quot;的意思， 这个引用是无论何时都能应用编译的。
# 'cfg(...)' 是参考 类Rust `#[cfg]` 语法 (条件语句)
[target.$triple]
#  linker 可传递参数给 rustc (通过 `-C linker=`) 当 `$triple`
# 要被编译. 默认不传递东东
linker = &quot;..&quot;
# 一样，但这是传递给 rustc 关于 库压缩的参数 ，通过 `-C ar=`.
ar = &quot;..&quot;
# 若 提供了 一个 runner ， 编译`$triple`目标 会通过 执行 runner 执行文件来完成， 它会将真正的目标 作为第一参数.
# 这可运行 `cargo run`， `cargo test` 和 `cargo bench` 命令.
# 默认，编译目标是 直接执行的.
runner = &quot;..&quot;
# 自定义 全编译器，目标为 $triple
# 这些值会覆盖 build.rustflags
rustflags = [&quot;..&quot;, &quot;..&quot;]

[target.'cfg(...)']
# 与 $triple 配置类似， 但使用的是 `cfg` 语法.
# 若有几个 `cfg` 和 $triple 目标作为备用， 那 rustflags
# 会被串联起来. 该 `cfg` 语法仅能应用到 rustflags， 而不能是
# linker.
rustflags = [&quot;..&quot;, &quot;..&quot;]
# 与 $triple 配置类似 ， 但使用的是 `cfg` 语法.
# 若 一个或多个 `cfg`s， 和一个 a $triple 目标作为备用，那 该$triple将会被使用
# 若有几个 `cfg` 和 备用的， 那构建会 error
runner = &quot;..&quot;

# 关联到 注册表 的配置字段
[registry]
index = &quot;...&quot;   # 注册表索引的URL（默认为中央存储库）
token = &quot;...&quot;   # 访问令牌（在中央回购网站上找到）
default = &quot;...&quot; # 要使用的默认备用注册表（可以使用--registry覆盖）

[http]
proxy = &quot;host:port&quot; # 用于HTTP请求的HTTP代理（默认为none）
                    # libcurl格式，例如“socks5h://host:port”
timeout = 30        # 每个HTTP请求的超时，以秒为单位
cainfo = &quot;cert.pem&quot; # 证书颁发机构（CA）包的路径（可选）
check-revoke = true # 指示是否检查SSL证书是否已废除
low-speed-limit = 5 # 限速 字节/秒（10 = 默认值，0 = 禁用）
multiplexing = true # 是否在可能的情况下使用 HTTP/2多路复用

# 此设置可用于帮助调试Cargo所发生的HTTP请求
# 当设置为“true”时，将填充Cargo的正常调试日志记录
# 关于HTTP的信息，您可以使用
# `RUST_LOG=cargo::ops::registry=debug`提取（和`trace`可能会打印更多）。
#
# 在将这些日志发布到其他地方时要小心，因可能存在这样的
# header中，有一个你不想泄露的身份验证令牌的情况！务必
# 在发布之前简要查看日志。
debug = false

[build]
jobs = 1                  # 并行作业数，默认为CPU数
rustc = &quot;rustc&quot;           # rust编译器工具
rustdoc = &quot;rustdoc&quot;       # doc生成器工具
target = &quot;triple&quot;         # build为目标 triple（被`cargo install`忽略）
target-dir = &quot;target&quot;     # 放置所有生成的工件的路径
rustflags = [&quot;..&quot;, &quot;..&quot;]  # 自定义 传递给所有编译器调用 的参数
incremental = true        # 是否启用增量编译
dep-info-basedir = &quot;..&quot;   # depfiles中，目标的基本目录的完整路径

[term]
verbose = false        # Cargo否提供详细输出
color = 'auto'         # Cargo否着色输出

# 网络配置
[net]
retry = 2 # 失败 自动重试 次数
git-fetch-with-cli = false  # 若为 `true` 我们会使用 `git`命令行去 fetch git repos

# 别名 cargo 命令. 前 3 个aliases 是内置的. 如果你的命令 要求 整行命令，请使用 list 格式.
[alias]
b = &quot;build&quot;
t = &quot;test&quot;
r = &quot;run&quot;
rr = &quot;run --release&quot;
space_example = [&quot;run&quot;, &quot;--release&quot;, &quot;--&quot;, &quot;\&quot;command list\&quot;&quot;]
</code></pre>
<h3 id="environment-variables"><a class="header" href="#environment-variables">Environment variables</a></h3>
<p>环境变量</p>
<p>除了上面的 TOML 语法之外，还可以通过环境变量配置 Cargo。对于上方的<code>foo.bar</code>表格的每个配置字段，也可以用环境变量<code>CARGO_FOO_BAR</code>来定义值。比如说<code>build.jobs</code>字段，也可以通过<code>CARGO_BUILD_JOBS</code>定义。</p>
<p>环境变量将优先于 TOML 配置，并且当前仅支持由环境变量定义的整数，布尔和字符串字段，这意味着<a href="reference/./source-replacement.zh.html">来源更换</a>，能由表格表示，却不能通过环境变量配置。</p>
<p>除上述系统外，Cargo 还认可其他一些特定的<a href="reference/./environment-variables.zh.html">环境变量</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="environment-variables-1"><a class="header" href="#environment-variables-1">Environment Variables</a></h2>
<p>Cargo 设置，并读取许多环境变量，代码可以检测或覆盖这些环境变量。以下是 Cargo 与它们交互时，组织的变量列表:</p>
<h3 id="environment-variables-cargo-reads"><a class="header" href="#environment-variables-cargo-reads">Environment variables Cargo reads</a></h3>
<p>Cargo 会读取的环境变量</p>
<p>您可以重写这些环境变量来更改 Cargo 在系统中的行为:</p>
<table><thead><tr><th>名(ENV)</th><th>曰</th></tr></thead><tbody>
<tr><td><code>CARGO_HOME</code></td><td>Cargo 在本地缓存注册表索引和箱子的 git 版本。默认情况下，这些存储在<code>$HOME/.cargo</code>，但是这个变量重写了这个目录的位置。一旦箱被缓存，它就不会被清除命令删除。</td></tr>
<tr><td><code>CARGO_TARGET_DIR</code></td><td>相对于当前工作目录，放置所有生成的工件的位置.</td></tr>
<tr><td><code>RUSTC</code></td><td>Cargo 不运行<code>rustc</code>，而执行指定的编译器。</td></tr>
<tr><td><code>RUSTC_WRAPPER</code></td><td>Cargo 将执行这个指定的包装器，而不是简单地运行<code>rustc</code>。将 rustc 调用 作为其命令行参数传递，第一个参数是 rustc.</td></tr>
<tr><td><code>RUSTDOC</code></td><td>Cargo 将执行此指定的<code>rustdoc</code>实例，而不是<code>rustdoc</code>.</td></tr>
<tr><td><code>RUSTDOCFLAGS</code></td><td>空格分隔的自定义标志列表，用来传递给 Cargo 执行的所有<code>rustdoc</code>调用 。与<code>cargo rustdoc</code>不同，这对于传递一个参数给 <em>全部的</em> <code>rustdoc</code>实例是有用的。</td></tr>
<tr><td><code>RUSTFLAGS</code></td><td>自定义参数的空格分隔列表，用来传递给 Cargo 执行的所有编译器调用。与<code>cargo rustc</code>不同，这对于传递一个标志 <em>全部的</em> 编译实例是有用的。</td></tr>
<tr><td><code>CARGO_INCREMENTAL</code></td><td>如果设置为 1，则 Cargo 将强制在当前编译中启用增量编译，而当设置为 0，则强制禁用增量编译。如果这个 ENV 不存在，否则将使用 Cargo 默认值。</td></tr>
<tr><td><code>CARGO_CACHE_RUSTC_INFO</code></td><td>如果这个设置为 0，那么 Cargo 将不尝试缓存编译器版本信息.</td></tr>
</tbody></table>
<p>注意，Cargo 也会在<code>.cargo/config</code>配置中读取环境变量，如<a href="reference/./config.zh.html#environment-variables">那份文件</a></p>
<h3 id="environment-variables-cargo-sets-for-crates"><a class="header" href="#environment-variables-cargo-sets-for-crates">Environment variables Cargo sets for crates</a></h3>
<p>Cargo 为 crates 设置的环境变量</p>
<p>Cargo 在编译时，会将这些环境变量暴露在箱子中。请注意，这也适用于测试二进制文件。要在 RIST 程序中获得这些变量中的任何一个变量的值，请执行以下操作:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let version = env!(&quot;CARGO_PKG_VERSION&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><code>version</code>现在将包含了<code>CARGO_PKG_VERSION</code>值。</p>
<table><thead><tr><th>名</th><th>曰</th></tr></thead><tbody>
<tr><td><code>CARGO</code></td><td>执行构建的二进制<code>cargo</code>路径.</td></tr>
<tr><td><code>CARGO_MANIFEST_DIR</code></td><td>包含包的清单的目录.</td></tr>
<tr><td><code>CARGO_PKG_VERSION</code></td><td>您的包的完整版本.</td></tr>
<tr><td><code>CARGO_PKG_VERSION_MAJOR</code></td><td>你的软件包的主要版本.</td></tr>
<tr><td><code>CARGO_PKG_VERSION_MINOR</code></td><td>您的包的次要版本.</td></tr>
<tr><td><code>CARGO_PKG_VERSION_PATCH</code></td><td>包的补丁版本.</td></tr>
<tr><td><code>CARGO_PKG_VERSION_PRE</code></td><td>包的预发布版本.</td></tr>
<tr><td><code>CARGO_PKG_AUTHORS</code></td><td>从程序包的清单中，冒号分隔出作者列表.</td></tr>
<tr><td><code>CARGO_PKG_NAME</code></td><td>你的包的名字.</td></tr>
<tr><td><code>CARGO_PKG_DESCRIPTION</code></td><td>从包的清单中描述.</td></tr>
<tr><td><code>CARGO_PKG_HOMEPAGE</code></td><td>从包的清单中的主页.</td></tr>
<tr><td><code>CARGO_PKG_REPOSITORY</code></td><td>从包的清单中存储库.</td></tr>
<tr><td><code>OUT_DIR</code></td><td>如果包具有构建脚本，则将其设置为，构建脚本应该在其中放置其输出的文件夹。更多信息见下文.</td></tr>
</tbody></table>
<h3 id="environment-variables-cargo-sets-for-build-scripts"><a class="header" href="#environment-variables-cargo-sets-for-build-scripts">Environment variables Cargo sets for build scripts</a></h3>
<p>Cargo 为构建脚本设置的环境变量</p>
<p>当运行构建脚本时，Cargo 设置多个环境变量.因为编译生成脚本时还没有设置这些变量，所以上面的示例使用<code>env!</code>无法工作，而是在运行构建脚本时需要检索值:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::env;
let out_dir = env::var(&quot;OUT_DIR&quot;).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p><code>out_dir</code>现在将包含的价值<code>OUT_DIR</code>.</p>
<table><thead><tr><th>名</th><th>曰</th></tr></thead><tbody>
<tr><td><code>CARGO</code></td><td>执行构建的二进制<code>cargo</code>路径.</td></tr>
<tr><td><code>CARGO_MANIFEST_DIR</code></td><td>包含正在构建的包的清单的目录(包含构建脚本的包)。还要注意，这是生成脚本启动时，当前工作目录的值.</td></tr>
<tr><td><code>CARGO_MANIFEST_LINKS</code></td><td>清单<code>links</code>的值.</td></tr>
<tr><td><code>CARGO_FEATURE_&lt;name&gt;</code></td><td>对于正在构建的包的每个激活特性，此环境变量会让<code>&lt;name&gt;</code>功能名称存在，名称的<code>-</code>会转换成<code>_</code>.</td></tr>
<tr><td><code>CARGO_CFG_&lt;cfg&gt;</code></td><td>对正在构建包的每个<a href="https://doc.rust-lang.org/reference/attributes.md#conditional-compilation">配置选项</a>，此环境变量将包含配置的值，其中<code>&lt;cfg&gt;</code>就是配置的名称，并将<code>-</code>翻译成<code>_</code>. 如果设置了布尔配置，则存在布尔配置，否则不存在。具有多个值的配置被连接到单个变量，该变量用<code>，</code>分隔就好。</td></tr>
<tr><td><code>OUT_DIR</code></td><td>所有输出都应该放在这个文件夹。此文件夹位于正在构建的包的构建目录中，并且对于所讨论的包是唯一的。</td></tr>
<tr><td><code>TARGET</code></td><td>正在编译的目标三元组。该为这个三元组编译本机代码。关于目标三元组的更多信息在<a href="http://clang.llvm.org/docs/CrossCompilation.md#target-triple">clang 自身文档中</a>.</td></tr>
<tr><td><code>HOST</code></td><td>Rust 编译器的主机三元组.</td></tr>
<tr><td><code>NUM_JOBS</code></td><td>指定为顶层并行的并行性。这可以传递一个<code>-j</code>参数到系统(像<code>make</code>). 注意，在解释这个环境变量时应该小心。出于历史目的，仍然提供此功能，但是例如，最新版本的 Cargo 不需要运行<code>make -j</code>，因为它会自动。Cargo 自行实现[JooServer]，并且允许构建脚本继承这些信息，因此与 GNU 兼容的程序将使作业服务器已经具有适当配置的并行性。</td></tr>
<tr><td><code>OPT_LEVEL</code> ，<code>DEBUG</code></td><td>为了分析，当前正在构建的相应变量值.</td></tr>
<tr><td><code>PROFILE</code></td><td>发布版本用<code>release</code>，而<code>debug</code>用于其他构建.</td></tr>
<tr><td><code>DEP_&lt;name&gt;_&lt;key&gt;</code></td><td>有关此组环境变量的更多信息，请参阅<a href="reference/./build-scripts.zh.html#the-links-manifest-key"><code>links</code></a>.</td></tr>
<tr><td><code>RUSTC</code> ，<code>RUSTDOC</code></td><td>Cargo 已经决定使用的编译器和文档生成器，传递给构建脚本，以便构建脚本也可以使用它.</td></tr>
<tr><td><code>RUSTC_LINKER</code></td><td>如果指定了，Cargo 为了当前目标，决定使用的链接器(二进制文件)的路径。这个链接器可以通过编辑<code>.cargo/config</code>更改，欲了解更多信息，请参阅有关文档<a href="reference/./config.zh.html">Cargo 配置</a>。</td></tr>
</tbody></table>
<h3 id="environment-variables-cargo-sets-for-3rd-party-subcommands"><a class="header" href="#environment-variables-cargo-sets-for-3rd-party-subcommands">Environment variables Cargo sets for 3rd party subcommands</a></h3>
<p>Cargo 为 第三方子命令设置的环境变量</p>
<p>Cargo 将这个环境变量公开给第三方子命令(即，名为<code>cargo-foobar</code>放置在<code>$PATH</code>):</p>
<ul>
<li><code>CARGO</code> - 执行构建的二进制<code>cargo</code>路径。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="build-scripts-1"><a class="header" href="#build-scripts-1">Build Scripts</a></h2>
<blockquote>
<p>构建脚本</p>
</blockquote>
<p>一些包需要编译第三方非 Rust 代码，例如 C 库。其他的包需要链接到 C 库，当然这些库既可以位于系统上，也可以从源代码构建。其他人或许还需要功能工具，比如构建之前的代码生成(想想解析生成器)。</p>
<p>Cargo 并不打算替换为这些能良好优化任务的其他工具，但是它与<code>build</code>配置选项.</p>
<pre><code class="language-toml">[package]
# ...
build = &quot;build.rs&quot;
</code></pre>
<p>指定的<code>build</code>命令应执行的 Rust 文件(相对于包根)，将在包编译其他内容之前，被编译和调用，从而具备 Rust 代码所依赖的构建或生成的工件。默认情况下 Cargo 在包根文件中寻找<code>&quot;build.rs&quot;</code>(即使您没有给<code>build</code>字段指定值)使用<code>build = &quot;custom_build_name.rs&quot;</code>指定自定义生成名，或<code>build = false</code>禁用对构建脚本的自动检测。</p>
<p>Build 命令的一些用例是:</p>
<ul>
<li>构建一个捆绑的 C 库.</li>
<li>在主机系统上找到 C 库.</li>
<li>从规范中生成 Rust 模块.</li>
<li>为箱，执行所需的某平台特定配置.</li>
</ul>
<p>下面将详细介绍每一个用例，以给出构建命令如何工作的示例.</p>
<h3 id="inputs-to-the-build-script"><a class="header" href="#inputs-to-the-build-script">Inputs to the Build Script</a></h3>
<blockquote>
<p>输入到构建脚本</p>
</blockquote>
<p>当运行构建脚本时，存在许多构建脚本用到的输入，所有输入都以<a href="reference/./environment-variables.zh.html">环境变量</a>传入。</p>
<p>除了环境变量之外，构建脚本的当前目录是构建脚本包的源目录.</p>
<h3 id="outputs-of-the-build-script"><a class="header" href="#outputs-of-the-build-script">Outputs of the Build Script</a></h3>
<blockquote>
<p>构建脚本的输出</p>
</blockquote>
<p>由构建脚本打印到 stdout 的所有行都被写入像<code>target/debug/build/&lt;pkg&gt;/output</code>这样的文件(精确的位置可能取决于你的配置)。如果您希望直接在终端中看到这样的输出，那么使用非常详细<code>-vv</code>标志。注意，如果既不修改构建脚本也不修改包源文件，下一次的<code>-vv</code>调用将<strong>不</strong>打印重复输出到终端，因为没有执行新的构建。可执行<code>cargo clean</code>，如果希望确保输出始终显示在终端上，但要在每次 Cargo 调用之前执行。任何一行以<code>cargo:</code>开始的，直接由 Cargo 解释。行必须是<code>cargo:key=value</code>形式，就像下面的例子:</p>
<pre><code># specially recognized by Cargo
cargo:rustc-link-lib=static=foo
cargo:rustc-link-search=native=/path/to/foo
cargo:rustc-cfg=foo
cargo:rustc-env=FOO=bar
# arbitrary user-defined metadata
cargo:root=/path/to/foo
cargo:libdir=/path/to/foo/lib
cargo:include=/path/to/foo/include
</code></pre>
<p>另一方面，打印到 stderr 的行被写入像<code>target/debug/build/&lt;pkg&gt;/stderr</code>这样的文件，但不被 Cargo 解释。</p>
<p>Cargo 识别一些特殊的 key，其中一些影响箱的构造:</p>
<ul>
<li>
<p><code>rustc-link-lib=[KIND=]NAME</code>说明了，指定值是库名，且会作为<code>-l</code>标志传递给编译器。<code>KIND</code>可选为<code>static</code>，<code>dylib</code>(默认值)，或<code>framework</code>的其中之一，用<code>rustc --help</code>见更多细节。</p>
</li>
<li>
<p><code>rustc-link-search=[KIND=]PATH</code>说明了，指定值是库搜索路径，且会作为<code>-L</code>标志传递给编译器。<code>KIND</code>可选为<code>dependency</code>，<code>crate</code>，<code>native</code>，<code>framework</code>或<code>all</code>(默认值)的其中之一，使用<code>rustc --help</code>见更多细节.</p>
</li>
<li>
<p><code>rustc-flags=FLAGS</code>是传递给编译器的一组标志，仅支持<code>-l</code>和<code>-L</code>标志。</p>
</li>
<li>
<p><code>rustc-cfg=FEATURE</code>说明了，指定的特性，且会作为<code>--cfg</code>标志传递给编译器。这通常对检测，执行各种特征的编译时间，是有用的。</p>
</li>
<li>
<p><code>rustc-env=VAR=VALUE</code>说明了，指定的环境变量，且会被添加到编译器所在的环境中。然后，可以通过编译箱中的<code>env!</code>宏检索该值。这对于在箱的代码中嵌入额外的元数据很有用，比如 Git HEAD 的散列，或持续集成服务器的唯一标识符。</p>
</li>
<li>
<p><code>rerun-if-changed=PATH</code>是文件或目录的路径，说明了如果构建脚本发生更改(由文件上最近修改的时间戳检测到)，则应重新运行构建脚本。通常，如果箱根目录中的任何文件发生更改，则重新运行构建脚本，但这可用于将更改范围扩展到仅一小组文件。(如果这个路径指向一个目录，则不会遍历整个目录以进行更改——只对目录本身的时间戳进行更改(该时间戳对应于目录中的某些类型的更改，取决于平台)，将触发重新构建。要请求重新运行整个目录中的任何更改，请递归地为该目录打印一行，为该目录内的所有内容打印另一行。)请注意，如果构建脚本本身(或其依赖项之一)更改，则无条件地重新构建和重新运行该脚本，因此，<code>cargo:rerun-if-changed=build.rs</code>几乎总是冗余(除非您想要忽略除了<code>build.rs</code>，所有其他文件的变化)</p>
</li>
<li>
<p><code>rerun-if-env-changed=VAR</code>是环境变量的名称，说明了它指示如果环境变量的值发生变化，则应重新运行构建脚本。这基本上与<code>rerun-if-changed</code>是一样的，除了它与环境变量一起工作。注意，这里的环境变量用于全局环境变量，如<code>CC</code>这样的，对于 Cargo 所设的像<code>TARGET</code>，就不必使用它。还要注意，如果<code>rerun-if-env-changed</code>打印出来，然后 Cargo 将<em>只</em>在，那些环境变量发生变化，或者打印出<code>rerun-if-changed</code>改变的文件的情况下，才重新运行构建脚本。</p>
</li>
<li>
<p><code>warning=MESSAGE</code>是构建脚本运行完毕后，打印到主控制台的消息/警告只针对路径依赖项(即，您在本地工作的那些依赖项)显示，因此如， crates.io 的箱在默认情况下不会打印警告。</p>
</li>
</ul>
<p>其他哪些元素都是用户定义的元数据，这些元数据传递给了依赖的。关于这个的更多信息可以在<a href="reference/build-scripts.zh.html#the-links-manifest-key"><code>links</code></a>部分查看.</p>
<h3 id="build-dependencies-2"><a class="header" href="#build-dependencies-2">Build Dependencies</a></h3>
<blockquote>
<p>构建依赖</p>
</blockquote>
<p>构建脚本也可以依赖其他基于 Cargo 的箱。依赖关系通过清单的<code>build-dependencies</code>部分指定。</p>
<pre><code class="language-toml">[build-dependencies]
foo = { git = &quot;https://github.com/your-packages/foo&quot; }
</code></pre>
<p>构建脚本<strong>不</strong>可以访问<code>dependencies</code>或<code>dev-dependencies</code>部分列表中的依赖项(它们还没有建成!)，除非明确声明，否则包本身也不能使用所有构建依赖项。</p>
<h3 id="the-links-manifest-key"><a class="header" href="#the-links-manifest-key">The <code>links</code> Manifest Key</a></h3>
<blockquote>
<p><code>links</code> 清单 键</p>
</blockquote>
<p>除了清单键<code>build</code>，Cargo 也支持一个，要链接到本地库的名称声明，那就是<code>links</code>清单键:</p>
<pre><code class="language-toml">[package]
# ...
links = &quot;foo&quot;
build = &quot;build.rs&quot;
</code></pre>
<p>此清单说明了包会链接到本机库<code>libfoo</code>，并且它还具有定位和/或构建该本机库的构建脚本。Cargo 要求<code>build</code>如果有值，那<code>links</code>也要有值。</p>
<p>这个清单键的目的是，让 Cargo 了解包所具有的本地依赖项集合，并提供在包构建脚本之间，传递元数据的合适的系统.</p>
<p>首先，Cargo 要求一个包最多只有一个<code>links</code>值。换句话说，禁止两个包链接到同一个本机库。然而，这里也有<a href="reference/build-scripts.zh.html#a-sys-packages">约定位置</a>的方式，用来缓解这个问题。</p>
<p>如上面在输出格式中提到的，每个构建脚本可以以键-值对的形式生成一组任意的元数据。此元数据传递给<strong>依赖的</strong>包。例如，如果<code>libbar</code>依赖<code>libfoo</code>，当<code>libfoo</code>生成<code>key=value</code>作为其元数据的一部分，那<code>libbar</code>的构建脚本会有<code>DEP_FOO_KEY=value</code>环境变量。</p>
<p>注意，元数据只传递给直接依赖项，而不是把依赖项串起来。此元数据传递的动机，会在接下来，关联到系统库案例研究中概述。</p>
<h3 id="overriding-build-scripts"><a class="header" href="#overriding-build-scripts">Overriding Build Scripts</a></h3>
<blockquote>
<p>覆盖 构建脚本</p>
</blockquote>
<p>如果一个清单包含<code>links</code>关键字，那 Cargo 支持重写用自定义库指定的构建脚本。此功能的目的是防止完全运行有问题的构建脚本，而是提前提供下元数据。</p>
<p>要覆盖构建脚本，请将下列配置放在任何可接受的 Cargo 的<a href="reference/./config.zh.html">配置位置</a>中。</p>
<pre><code class="language-toml">[target.x86_64-unknown-linux-gnu.foo]
rustc-link-search = [&quot;/path/to/foo&quot;]
rustc-link-lib = [&quot;foo&quot;]
root = &quot;/path/to/foo&quot;
key = &quot;value&quot;
</code></pre>
<p>本节说明目标<code>x86_64-unknown-linux-gnu</code>，命名为<code>foo</code>的库，具有指定的元数据。此元数据与构建脚本时生成的元数据相同，提供了许多键/值对，其中<code>rustc-flags</code>，<code>rustc-link-search</code>和<code>rustc-link-lib</code>有点特殊.</p>
<p>使用此配置，如果一个包声明它链接到此<code>foo</code>，那构建脚本将<strong>不</strong>编译或运行，而会使用指定的元数据。</p>
<h3 id="case-study-code-generation"><a class="header" href="#case-study-code-generation">Case study: Code generation</a></h3>
<blockquote>
<p>案例学习: 代码生成</p>
</blockquote>
<p>由于各种原因，一些 Cargo 包在编译之前需要生成代码。这里我们将介绍一个简单的示例，该示例把，’生成库调用’作为构建脚本的一部分.</p>
<p>首先，让我们看一下这个包的目录结构:</p>
<pre><code>.
├── Cargo.toml
├── build.rs
└── src
    └── main.rs

1 directory, 3 files
</code></pre>
<p>在这里我们可以看到我们有一个<code>build.rs</code>构建脚本，和二进制文件<code>main.rs</code>。 接下来，让我们看一下清单:</p>
<pre><code class="language-toml"># Cargo.toml

[package]
name = &quot;hello-from-generated-code&quot;
version = &quot;0.1.0&quot;
authors = [&quot;you@example.com&quot;]
build = &quot;build.rs&quot;
</code></pre>
<p>在这里，我们可以看到，我们已经指定了一个构建脚本<code>build.rs</code>，我们将使用它来生成一些代码。让我们看看构建脚本里面有什么:</p>
<pre><pre class="playground"><code class="language-rust no_run">// build.rs

use std::env;
use std::fs::File;
use std::io::Write;
use std::path::Path;

fn main() {
    let out_dir = env::var(&quot;OUT_DIR&quot;).unwrap();
    let dest_path = Path::new(&amp;out_dir).join(&quot;hello.rs&quot;);
    let mut f = File::create(&amp;dest_path).unwrap();

    f.write_all(b&quot;
        pub fn message() -&gt; &amp;'static str {
            \&quot;Hello, World!\&quot;
        }
    &quot;).unwrap();
}
</code></pre></pre>
<p>这里有两点值得注意的地方:</p>
<ul>
<li>脚本使用<code>OUT_DIR</code>环境变量，以知道输出文件到哪里。它可以使用进程的当前工作目录，来查找输入文件应该到哪里，但是在这种情况下，我们是没有任何输入文件的。</li>
<li>一般来说，构建脚本不应该修改<code>OUT_DIR</code>目录外的任何文件。 乍看之下，似乎不错，但当您使用这种箱子作为依赖项时，它确会带来问题，因为<code>.cargo/registry</code>源中的<em>隐性的</em>常量应该是不变的。<code>cargo</code>在打包时不会允许这样的脚本。</li>
<li>这个脚本相对简单，只是写出一个小生成的文件。可以想象，其他更奇特的操作也可能发生，例如从 C 头文件或其他定义的语言生成 Rust 模块。</li>
</ul>
<p>接下来，我们来看看库本身:</p>
<pre><code class="language-rust ignore">// src/main.rs

include!(concat!(env!(&quot;OUT_DIR&quot;), &quot;/hello.rs&quot;));

fn main() {
    println!(&quot;{}&quot;, message());
}
</code></pre>
<p>这就是真正的魔法发生的地方。该库正在使用 rustc 定义的 <code>include!</code>宏，它又结合<code>concat!</code>与<code>env!</code>宏去包含生成文件(<code>hello.rs</code>)，从而进入箱的编译。</p>
<p>使用此处所示的结构，箱可以包括(include)构建脚本在内的，任何数量的生成文件。</p>
<h3 id="case-study-building-some-native-code"><a class="header" href="#case-study-building-some-native-code">Case study: Building some native code</a></h3>
<blockquote>
<p>案例学习: 构建一些原生代码</p>
</blockquote>
<p>有时需要建立一些本地 C 或 C++代码作为包的一部分。这是在用构建脚本到 Rust 箱本身之前，构建本机库的另一个极好用例。作为一个例子，我们将创建一个 Rust 库，它调用 C 来打印“Hello,World!“.</p>
<p>和上面一样，让我们先来看看包的布局:</p>
<pre><code>.
├── Cargo.toml
├── build.rs
└── src
    ├── hello.c
    └── main.rs

1 directory, 4 files
</code></pre>
<p>很像之前的吧! 下一步，清单如下:</p>
<pre><code class="language-toml"># Cargo.toml

[package]
name = &quot;hello-world-from-c&quot;
version = &quot;0.1.0&quot;
authors = [&quot;you@example.com&quot;]
build = &quot;build.rs&quot;
</code></pre>
<p>现在，我们不打算使用任何-构建的依赖项，所以现在让我们看一下构建脚本:</p>
<pre><pre class="playground"><code class="language-rust no_run">// build.rs

use std::process::Command;
use std::env;
use std::path::Path;

fn main() {
    let out_dir = env::var(&quot;OUT_DIR&quot;).unwrap();

    // 请注意，这种方法存在许多缺点，
    // 下个代码展示，会详细介绍如何提高这些命令的可移植性。
    Command::new(&quot;gcc&quot;).args(&amp;[&quot;src/hello.c&quot;, &quot;-c&quot;, &quot;-fPIC&quot;, &quot;-o&quot;])
                       .arg(&amp;format!(&quot;{}/hello.o&quot;, out_dir))
                       .status().unwrap();
    Command::new(&quot;ar&quot;).args(&amp;[&quot;crus&quot;, &quot;libhello.a&quot;, &quot;hello.o&quot;])
                      .current_dir(&amp;Path::new(&amp;out_dir))
                      .status().unwrap();

    println!(&quot;cargo:rustc-link-search=native={}&quot;, out_dir);
    println!(&quot;cargo:rustc-link-lib=static=hello&quot;);
}
</code></pre></pre>
<p>此构建脚本首先将 C 文件编译为对象文件(通过调用<code>gcc</code>)，然后将这个对象文件转换为静态库(通过调用<code>ar</code>)，最后一步是反馈给 Cargo ，以表示我们的输出在<code>out_dir</code>和通过<code>-l static=hello</code>标志，编译器应该将箱静态链接到<code>libhello.a</code>。</p>
<p>请注意，这种硬编码方法有许多缺点:</p>
<ul>
<li>这个<code>gcc</code>命令本身不是跨平台可移植的。如，在 Windows 平台不太可能<code>gcc</code>，甚至不是所有 UNIX 平台都可能有<code>gcc</code>。 这个<code>ar</code>命令也处于类似的情况。</li>
<li>这些命令不考虑跨编译。如果我们为 Android 这样的平台进行跨编译，<code>gcc</code>就不太可能产生一个可执行的 ARM.</li>
</ul>
<p>但不要害怕，这里<code>build-dependencies</code>就帮到你! Cargo 生态系统有许多包，为了使此类任务更加容易、可移植和标准化。构建脚本可以写成:</p>
<pre><code class="language-rust ignore">// build.rs

// 依赖于外部维护的`cc`包，管理
// 调用C编译器。
extern crate cc;

fn main() {
    cc::Build::new()
        .file(&quot;src/hello.c&quot;)
        .compile(&quot;hello&quot;);
}
</code></pre>
<p>添加<code>cc</code>箱，这样将构建，依赖<code>cc</code>就好啦，将下面的添加到您的<code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[build-dependencies]
cc = &quot;1.0&quot;
</code></pre>
<p>这个<a href="https://crates.io/crates/cc"><code>cc</code>箱</a>抽象了 C 代码构建，主要用于脚本需求范围:</p>
<ul>
<li>它调用适当的编译器(Windows 的 MSVC，<code>gcc</code>对 MinGW ，<code>cc</code>对 UNIX 平台等等).</li>
<li>通过向正在使用的编译器传递适当的标志，获取<code>TARGET</code>变量.</li>
<li>其他环境变量，如<code>OPT_LEVEL</code>，<code>DEBUG</code>等等，都是自动处理的.</li>
<li>stdout 输出和<code>OUT_DIR</code>位置也由<code>cc</code>库控制.</li>
</ul>
<p>在这里，我们可以开始看到，将尽可能多的功能移植到公共构建依赖项，而不是在所有构建脚本之间复制来复制去，的一些主要好处!</p>
<p>回到案例研究，让我们快速浏览一下<code>src</code>目录中的内容:</p>
<pre><code class="language-c">// src/hello.c

#include &lt;stdio.h&gt;

void hello() {
    printf(&quot;Hello, World!\n&quot;);
}
</code></pre>
<pre><code class="language-rust ignore">// src/main.rs

// 注意缺少`#[link]`属性。 我们选择，将责任委派给
// 构建脚本的链接，而不是硬编码
// 它在源文件中.
extern { fn hello(); }

fn main() {
    unsafe { hello(); }
}
</code></pre>
<p>然后，就好啦! 这就完成了使用构建脚本，从 Cargo 包构建一些 C 代码的示例。这也说明了为什么在许多情况下使，用构建依赖项非常重要，甚至更加简洁!</p>
<p>我们还看到了构建脚本使用箱，纯粹作为用于构建过程的依赖项，而不是在运行时，用作箱本身的依赖项的简要示例。</p>
<h3 id="case-study-linking-to-system-libraries"><a class="header" href="#case-study-linking-to-system-libraries">Case study: Linking to system libraries</a></h3>
<blockquote>
<p>案例学习: 链接到系统库</p>
</blockquote>
<p>这里的最后一个案例研究，将研究 Cargo 库如何链接到系统库，以及构建脚本如何支持这个用例。</p>
<p>通常，Rust 箱希望链接到系统上经常提供的本地库，以绑定其功能，或者只是将其用作实现细节的一部分。想以不管平台的方式执行这个操作，而这却是一个相当微妙的问题，再次说明下，构建脚本的目的是尽可能多地分配这些(微妙)内容，以便让消费者尽可能容易地使用它.</p>
<p>作为一个例子，让我们来看一个<a href="https://github.com/alexcrichton/git2-rs/tree/master/libgit2-sys">Cargo 本身的依赖</a>，<a href="https://github.com/libgit2/libgit2">libgit2</a>。这个 C 库其实有许多约束条件:</p>
<ul>
<li>它可选为依赖 Unix 上的 OpenSSL ，来实现 https 传输.</li>
<li>它可选为依赖所有平台上的 libssh2 ，来实现 ssh 传输.</li>
<li>默认情况下，它通常不安装在所有系统上.</li>
<li>它可以从源代码使用<code>cmake</code>构建.</li>
</ul>
<p>为了可视化这里发生的事情，让我们看一下，链接本机 C 库的相关 Cargo 包的清单。</p>
<pre><code class="language-toml">[package]
name = &quot;libgit2-sys&quot;
version = &quot;0.1.0&quot;
authors = [&quot;...&quot;]
links = &quot;git2&quot;
build = &quot;build.rs&quot;

[dependencies]
libssh2-sys = { git = &quot;https://github.com/alexcrichton/ssh2-rs&quot; }

[target.'cfg(unix)'.dependencies]
openssl-sys = { git = &quot;https://github.com/alexcrichton/openssl-sys&quot; }

# ...
</code></pre>
<p>正如上面的清单所显示的，我们指定了一个<code>build</code>脚本，但值得注意的是，该示例具有<code>links</code>项，说明该箱(<code>libgit2-sys</code>)链接到了这个本地库<code>git2</code>。</p>
<p>在这里，我们还看到，我们选择让 Rust 箱有一个无条件的，通过<code>libssh2-sys</code>箱依赖<code>libssh2</code>(ssh2-rs)，以及(有条件的)特定于平 unix 台的<code>openssl-sys</code>依赖(其他平台现在被漠视)。这似乎有点违反在 <em>Cargo 清单</em> 的 <em>C 依赖</em> 的明确性，但这实际上是这’地方’中使用 Cargo 的一种约定.</p>
<h3 id="-sys-packages"><a class="header" href="#-sys-packages"><code>*-sys</code> Packages</a></h3>
<blockquote>
<p><code>*-sys</code> 包们</p>
</blockquote>
<p>为了减轻对系统库的链接，crates.io 有一个包命名和功能的<em>惯例</em>。比如包名<code>foo-sys</code>，它应该提供两个主要功能:</p>
<ul>
<li>库箱应链接到本地库<code>libfoo</code>。 在源代码最后构建之前，这将经常探测当前的系统的<code>libfoo</code>。</li>
<li>库箱应提供在<code>libfoo</code>的<strong>声明</strong>函数，但是<strong>不</strong>绑定或高级抽象。</li>
</ul>
<p>一套<code>*-sys</code>包，提供了一组用于连接到本地库的公共依赖项。通过这种’本机库相关’的包约定，可以获得许多好处:</p>
<ul>
<li><code>foo-sys</code>的公共依赖，会减轻上面所说的，关于一个包的<code>links</code>的每个值规则。</li>
<li>一个公共依赖关系，更能发现<code>libfoo</code>本身的集中逻辑(或者从源代码构建它).</li>
<li>这些依赖关系很容易被重写.</li>
</ul>
<h3 id="building-libgit2"><a class="header" href="#building-libgit2">Building libgit2</a></h3>
<blockquote>
<p>构建 libgit2 吧</p>
</blockquote>
<p>现在我们已经整理了 libgit2 的依赖，我们需要实际编写下构建脚本。我们这里不讨论特定的代码片段，而只研究<code>libgit2-sys</code>构建脚本的高层细节。这并不是建议所有包都遵循这个策略，而仅概述一个特定的策略。</p>
<p>构建脚本应该做的第一步是查询 libgit2 是否已经安装在主机系统上。要做到这一点，我们将利用现有的工具<code>pkg-config</code>(当它可用时)。我们也会使用<code>build-dependencies</code>部分重构成<code>pkg-config</code>相关的所有代码(或者有人已经这样做了!)。</p>
<p>如果<code>pkg-config</code>找不到 libgit2，或者如果<code>pkg-config</code>只是没有安装，下一步就要从捆绑源代码构建 libgit2 (捆绑源码作为<code>libgit2-sys</code>本身的一部分)。然而，在这样做时有一些细微差别，我们需要加以考虑:</p>
<ul>
<li>
<p>libgit2 的构建系统，<code>cmake</code>需要能够找到 libgit2 可选依赖 libssh2 。而我们确信我们已经构建了它(因它是一个 Cargo 依赖项)，我们只需要传递这个信息。为此，我们利用元数据格式，在构建脚本之间传递信息。在这个例子中，打印出的 libssh2 包信息是<code>cargo:root=...</code>，它来告诉我们 libssh2 安装在哪里，然后我们可以通过<code>CMAKE_PREFIX_PATH</code>环境变量让 cmkae 知道。</p>
</li>
<li>
<p>我们需要处理下，编译 C 代码时的一些<code>CFLAGS</code>值(也要告诉<code>cmake</code>关于这个信息)。我们想传递的一些标志是 64 位的<code>-m64</code>，32 位的<code>-m32</code>，或<code>-fPIC</code>也适用于 64 位。</p>
</li>
<li>
<p>最后，我们调用<code>cmake</code>将所有输出放入环境变量<code>OUT_DIR</code>目录，然后打印必要的元数据，以指导 rustc 如何链接到 libgit2。</p>
</li>
</ul>
<p>这个构建脚本的大部分功能，很容易就重构为常见的依赖项，因此我们的构建脚本不像这个描述那样长烦! 实际上，通过构建依赖项，构建脚本应该非常简单。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="build-script-examples"><a class="header" href="#build-script-examples">Build Script Examples</a></h2>
<p>以下部分说明了编写构建脚本的一些示例。</p>
<p>一些常见的构建脚本功能可以通过<a href="https://crates.io/">crates.io</a>.查看<a href="https://crates.io/keywords/build-dependencies"><code>build-dependencies</code>
keyword</a>看看有什么可用的。以下是一些流行箱子的样本<sup class="footnote-reference"><a href="#†">1</a></sup>:</p>
<ul>
<li><a href="https://crates.io/crates/bindgen"><code>bindgen</code></a>-自动生成到C库的Rust FFI绑定。</li>
<li><a href="https://crates.io/crates/cc"><code>cc</code></a>-编译C/C++/assembly。</li>
<li><a href="https://crates.io/crates/pkg-config"><code>pkg-config</code></a>-使用<code>pkg-config</code>公用事业</li>
<li><a href="https://crates.io/crates/cmake"><code>cmake</code></a>-运行<code>cmake</code>构建工具来构建本机库。</li>
<li><a href="https://crates.io/crates/autocfg"><code>autocfg</code></a>, <a href="https://crates.io/crates/rustc_version"><code>rustc_version</code></a>, <a href="https://crates.io/crates/version_check"><code>version_check</code></a>-这些箱子提供了基于当前数据实现条件编译的方法<code>rustc</code>例如编译器的版本。</li>
</ul>
<p><sup class="footnote-reference"><a href="#†">1</a></sup>：此列表不是背书。评估你的依赖关系，看看哪个适合你的项目。</p>
<h3 id="code-generation"><a class="header" href="#code-generation">Code generation</a></h3>
<p>由于各种原因，一些Cargo包需要在编译之前生成代码。在这里，我们将浏览一个简单的示例，该示例生成一个库调用，作为构建脚本的一部分。</p>
<p>首先，让我们看看这个包的目录结构：</p>
<pre><code class="language-text">.
├── Cargo.toml
├── build.rs
└── src
    └── main.rs

1 directory, 3 files
</code></pre>
<p>在这里我们可以看到，我们有一个<code>build.rs</code>在中构建脚本和二进制文件<code>main.rs</code>.此程序包有一个基本清单：</p>
<pre><code class="language-toml"># Cargo.toml

[package]
name = &quot;hello-from-generated-code&quot;
version = &quot;0.1.0&quot;
</code></pre>
<p>让我们看看构建脚本中的内容：</p>
<pre><pre class="playground"><code class="language-rust no_run">// build.rs

use std::env;
use std::fs;
use std::path::Path;

fn main() {
    let out_dir = env::var_os(&quot;OUT_DIR&quot;).unwrap();
    let dest_path = Path::new(&amp;out_dir).join(&quot;hello.rs&quot;);
    fs::write(
        &amp;dest_path,
        &quot;pub fn message() -&gt; &amp;'static str {
            \&quot;Hello, World!\&quot;
        }
        &quot;
    ).unwrap();
    println!(&quot;cargo:rerun-if-changed=build.rs&quot;);
}
</code></pre></pre>
<p>这里有几点值得注意：</p>
<ul>
<li>脚本使用<code>OUT_DIR</code>环境变量来发现输出文件应该位于何处。它可以使用进程的当前工作目录来查找输入文件的位置，但在这种情况下，我们没有任何输入文件。</li>
<li>一般来说，构建脚本不应修改外部的任何文件<code>OUT_DIR</code>.乍一看似乎没什么问题，但当你把这种箱子当作依赖物使用时，确实会造成问题，因为有一个<em>含蓄的</em>来源于<code>.cargo/registry</code>应该是不变的。<code>cargo</code>打包时不允许使用此类脚本。</li>
<li>这个脚本相对简单，因为它只写出一个生成的小文件。人们可以想象，其他更奇特的操作可能会发生，比如从C头文件或其他语言定义生成一个Rust模块。</li>
<li>这个<a href="reference/build-scripts.html#rerun-if-changed"><code>rerun-if-changed</code> instruction</a>告诉Cargo，只有在生成脚本本身发生更改时，才需要重新运行生成脚本。如果没有这一行，如果包中的任何文件发生更改，Cargo将自动运行构建脚本。如果您的代码生成使用了一些输入文件，您可以在这里打印这些文件的列表。</li>
</ul>
<p>接下来，让我们来看看图书馆本身：</p>
<pre><code class="language-rust ignore">// src/main.rs

include!(concat!(env!(&quot;OUT_DIR&quot;), &quot;/hello.rs&quot;));

fn main() {
    println!(&quot;{}&quot;, message());
}
</code></pre>
<p>这才是真正神奇的地方。库正在使用rustc定义的<a href="reference/../../std/macro.include.html"><code>include!</code> macro</a>结合<a href="reference/../../std/macro.concat.html"><code>concat!</code></a>和<a href="reference/../../std/macro.env.html"><code>env!</code></a>宏来包含生成的文件(<code>hello.rs</code>)进入箱子的汇编。</p>
<p>使用这里显示的结构，箱子可以包含构建脚本本身生成的任意数量的文件。</p>
<h3 id="building-a-native-library"><a class="header" href="#building-a-native-library">Building a native library</a></h3>
<p>有时需要将一些本地C或C++代码作为包的一部分来构建。这是另一个利用构建脚本在Rust箱子本身之前构建本机库的优秀用例。例如，我们将创建一个Rust库，它调用C来打印“Hello，World！”。</p>
<p>像上面一样，让我们先看看包的布局：</p>
<pre><code class="language-text">.
├── Cargo.toml
├── build.rs
└── src
    ├── hello.c
    └── main.rs

1 directory, 4 files
</code></pre>
<p>和以前很相似！接下来是清单：</p>
<pre><code class="language-toml"># Cargo.toml

[package]
name = &quot;hello-world-from-c&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
</code></pre>
<p>现在我们不打算使用任何构建依赖项，所以现在让我们看看构建脚本：</p>
<pre><pre class="playground"><code class="language-rust no_run">// build.rs

use std::process::Command;
use std::env;
use std::path::Path;

fn main() {
    let out_dir = env::var(&quot;OUT_DIR&quot;).unwrap();

    // Note that there are a number of downsides to this approach, the comments
    // below detail how to improve the portability of these commands.
    Command::new(&quot;gcc&quot;).args(&amp;[&quot;src/hello.c&quot;, &quot;-c&quot;, &quot;-fPIC&quot;, &quot;-o&quot;])
                       .arg(&amp;format!(&quot;{}/hello.o&quot;, out_dir))
                       .status().unwrap();
    Command::new(&quot;ar&quot;).args(&amp;[&quot;crus&quot;, &quot;libhello.a&quot;, &quot;hello.o&quot;])
                      .current_dir(&amp;Path::new(&amp;out_dir))
                      .status().unwrap();

    println!(&quot;cargo:rustc-link-search=native={}&quot;, out_dir);
    println!(&quot;cargo:rustc-link-lib=static=hello&quot;);
    println!(&quot;cargo:rerun-if-changed=src/hello.c&quot;);
}
</code></pre></pre>
<p>这个构建脚本首先将C文件编译成一个对象文件（通过调用<code>gcc</code>)然后将该对象文件转换为静态库（通过调用<code>ar</code>).最后一步是向Cargo公司反馈，告知我们的产品处于良好状态<code>out_dir</code>编译器应该将箱子链接到<code>libhello.a</code>通过<code>-l static=hello</code>选项</p>
<p>请注意，这种硬编码方法有许多缺点：</p>
<ul>
<li>这个<code>gcc</code>命令本身不能跨平台移植。例如，Windows平台不太可能<code>gcc</code>，甚至不是所有Unix平台都有<code>gcc</code>这个<code>ar</code>指挥部也处于类似的情况。</li>
<li>这些命令不考虑交叉编译。如果我们为Android这样的平台进行交叉编译，那么<code>gcc</code>将生成一个ARM可执行文件。</li>
</ul>
<p>不过，不用担心，这就是<code>build-dependencies</code>进来会有帮助的！Cargo生态系统有许多软件包，使这类任务变得更容易、便携和标准化。让我们试试这个<a href="https://crates.io/crates/cc"><code>cc</code>
crate</a>从…起<a href="https://crates.io/">crates.io</a>.首先，将其添加到<code>build-dependencies</code>在里面<code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[build-dependencies]
cc = &quot;1.0&quot;
</code></pre>
<p>然后重写构建脚本以使用此箱子：</p>
<pre><code class="language-rust ignore">// build.rs

fn main() {
    cc::Build::new()
        .file(&quot;src/hello.c&quot;)
        .compile(&quot;hello&quot;);
    println!(&quot;cargo:rerun-if-changed=src/hello.c&quot;);
}
</code></pre>
<p>这个<a href="https://crates.io/crates/cc"><code>cc</code> crate</a>对C代码的一系列构建脚本需求进行了抽象：</p>
<ul>
<li>它调用适当的编译器（MSVC for windows，<code>gcc</code>对明哥来说，<code>cc</code>用于Unix平台等）。</li>
<li>这需要时间<code>TARGET</code>通过向正在使用的编译器传递适当的标志，将变量考虑在内。</li>
<li>其他环境变量，例如<code>OPT_LEVEL</code>, <code>DEBUG</code>等等，都是自动处理的。</li>
<li>标准输出和<code>OUT_DIR</code>地点也由<code>cc</code>图书馆</li>
</ul>
<p>在这里，我们可以开始看到尽可能多地将功能扩展到常见的构建依赖项，而不是在所有构建脚本中复制逻辑的一些主要好处！</p>
<p>回到案例研究，让我们快速看一下<code>src</code>目录：</p>
<pre><code class="language-c">// src/hello.c

#include &lt;stdio.h&gt;

void hello() {
    printf(&quot;Hello, World!\n&quot;);
}
</code></pre>
<pre><code class="language-rust ignore">// src/main.rs

// Note the lack of the `#[link]` attribute. We’re delegating the responsibility
// of selecting what to link over to the build script rather than hard-coding
// it in the source file.
extern { fn hello(); }

fn main() {
    unsafe { hello(); }
}
</code></pre>
<p>我们走了！这将完成我们使用构建脚本本身从Cargo包构建一些C代码的示例。这也说明了为什么在许多情况下，使用构建依赖项是至关重要的，甚至更简洁！</p>
<p>我们还看到了一个简单的例子，说明了构建脚本如何将箱子作为一个依赖项，仅用于构建过程，而不用于运行时的箱子本身。</p>
<h3 id="linking-to-system-libraries"><a class="header" href="#linking-to-system-libraries">Linking to system libraries</a></h3>
<p>此示例演示如何链接系统库，以及如何使用构建脚本来支持此用例。</p>
<p>Rust箱子经常想要链接到系统上提供的本机库，以绑定其功能，或者只是将其用作实现细节的一部分。以平台无关的方式执行此操作时，这是一个相当微妙的问题。如果可能的话，最好是尽可能多地将其外包出去，让消费者尽可能容易地做到这一点。</p>
<p>在本例中，我们将创建一个到系统zlib库的绑定。这是一个在大多数提供数据压缩的类Unix系统上常见的库。这已经在<a href="https://crates.io/crates/libz-sys"><code>libz-sys</code>
crate</a>，但对于这个例子，我们将做一个极其简化的版本。退房<a href="https://github.com/rust-lang/libz-sys">the source code</a>举个完整的例子。</p>
<p>为了便于找到图书馆的位置，我们将使用<a href="https://crates.io/crates/pkg-config"><code>pkg-config</code> crate</a>.这个箱子使用系统的<code>pkg-config</code>用于发现有关库的信息的实用程序。它会自动告诉Cargo连接图书馆需要什么。这可能只适用于具有<code>pkg-config</code>安装。让我们从设置清单开始：</p>
<pre><code class="language-toml"># Cargo.toml

[package]
name = &quot;libz-sys&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
links = &quot;z&quot;

[build-dependencies]
pkg-config = &quot;0.3.16&quot;
</code></pre>
<p>请注意，我们包括了<code>links</code>输入<code>package</code>桌子这告诉Cargo我们正在连接到<code>libz</code>图书馆查看<a href="reference/build-script-examples.zh.html#using-another-sys-crate">“Using another sys
crate”</a>举个例子来说明这一点。</p>
<p>构建脚本相当简单：</p>
<pre><code class="language-rust ignore">// build.rs

fn main() {
    pkg_config::Config::new().probe(&quot;zlib&quot;).unwrap();
    println!(&quot;cargo:rerun-if-changed=build.rs&quot;);
}
</code></pre>
<p>让我们用一个基本的FFI绑定来总结这个例子：</p>
<pre><code class="language-rust ignore">// src/lib.rs

use std::os::raw::{c_uint, c_ulong};

extern &quot;C&quot; {
    pub fn crc32(crc: c_ulong, buf: *const u8, len: c_uint) -&gt; c_ulong;
}

#[test]
fn test_crc32() {
    let s = &quot;hello&quot;;
    unsafe {
        assert_eq!(crc32(0, s.as_ptr(), s.len() as c_uint), 0x3610a686);
    }
}
</code></pre>
<p>跑<code>cargo build -vv</code>查看生成脚本的输出。在一个具有<code>libz</code>已经安装，它可能看起来像这样：</p>
<pre><code class="language-text">[libz-sys 0.1.0] cargo:rustc-link-search=native=/usr/lib
[libz-sys 0.1.0] cargo:rustc-link-lib=z
[libz-sys 0.1.0] cargo:rerun-if-changed=build.rs
</code></pre>
<p>美好的<code>pkg-config</code>做了所有的工作，找到了图书馆，并告诉Cargo它在哪里。</p>
<p>软件包包含库的源代码，如果在系统中找不到源代码，或者设置了功能或环境变量，则静态地构建源代码，这种情况并不少见。例如，真实的<a href="https://crates.io/crates/libz-sys"><code>libz-sys</code> crate</a>检查环境变量<code>LIBZ_SYS_STATIC</code>或者<code>static</code>功能从源代码而不是使用系统库构建它。退房<a href="https://github.com/rust-lang/libz-sys">the
source</a>以获取更完整的示例。</p>
<h3 id="using-another-sys-crate"><a class="header" href="#using-another-sys-crate">Using another <code>sys</code> crate</a></h3>
<p>当使用<code>links</code>关键点，箱子可以设置元数据，这些元数据可以被依赖于它的其他箱子读取。这提供了一种在箱子之间传递信息的机制。在本例中，我们将创建一个C库，该库使用来自真实世界的zlib<a href="https://crates.io/crates/libz-sys"><code>libz-sys</code> crate</a>.</p>
<p>如果你有一个依赖zlib的C库，你可以利用<a href="https://crates.io/crates/libz-sys"><code>libz-sys</code>
crate</a>自动查找或构建它。这非常适合跨平台支持，例如通常不安装zlib的Windows。<code>libz-sys</code> <a href="https://github.com/rust-lang/libz-sys/blob/3c594e677c79584500da673f918c4d2101ac97a1/build.rs#L156">sets
the <code>include</code>
metadata</a>告诉其他包在哪里可以找到zlib的头文件。我们的构建脚本可以使用<code>DEP_Z_INCLUDE</code>环境变量。下面是一个例子：</p>
<pre><code class="language-toml"># Cargo.toml

[package]
name = &quot;zuser&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
libz-sys = &quot;1.0.25&quot;

[build-dependencies]
cc = &quot;1.0.46&quot;
</code></pre>
<p>这里我们包括<code>libz-sys</code>这将确保只有一个<code>libz</code>在最终库中使用，并允许我们从构建脚本访问它：</p>
<pre><code class="language-rust ignore">// build.rs

fn main() {
    let mut cfg = cc::Build::new();
    cfg.file(&quot;src/zuser.c&quot;);
    if let Some(include) = std::env::var_os(&quot;DEP_Z_INCLUDE&quot;) {
        cfg.include(include);
    }
    cfg.compile(&quot;zuser&quot;);
    println!(&quot;cargo:rerun-if-changed=src/zuser.c&quot;);
}
</code></pre>
<p>具有<code>libz-sys</code>完成所有繁重的工作后，C源代码现在可能包括zlib头，它应该可以找到该头，即使在尚未安装它的系统上也是如此。</p>
<pre><code class="language-c">// src/zuser.c

#include &quot;zlib.h&quot;

// … rest of code that makes use of zlib.
</code></pre>
<h3 id="conditional-compilation"><a class="header" href="#conditional-compilation">Conditional compilation</a></h3>
<p>构建脚本可能会发出<a href="reference/build-scripts.html#rustc-cfg"><code>rustc-cfg</code> instructions</a>它可以启用可在编译时检查的条件。在本例中，我们将了解<a href="https://crates.io/crates/openssl"><code>openssl</code> crate</a>使用它来支持多个版本的OpenSSL库。</p>
<p>这个<a href="https://crates.io/crates/openssl-sys"><code>openssl-sys</code> crate</a>实现构建和链接OpenSSL库。它支持多个不同的实现（比如LibreSSL）和多个版本。它利用了<code>links</code>键，以便它可以将信息传递给其他构建脚本。它经过的事情之一是<code>version_number</code>密钥，即检测到的OpenSSL版本。构建脚本中的代码看起来像<a href="https://github.com/sfackler/rust-openssl/blob/dc72a8e2c429e46c275e528b61a733a66e7877fc/openssl-sys/build/main.rs#L216">like
this</a>:</p>
<pre><code class="language-rust ignore">println!(&quot;cargo:version_number={:x}&quot;, openssl_version);
</code></pre>
<p>此指令会导致<code>DEP_OPENSSL_VERSION_NUMBER</code>环境变量设置在任何箱子中，直接取决于<code>openssl-sys</code>.</p>
<p>这个<code>openssl</code>提供更高级别接口的箱子指定<code>openssl-sys</code>作为一种依赖。这个<code>openssl</code>构建脚本可以读取<code>openssl-sys</code>使用<code>DEP_OPENSSL_VERSION_NUMBER</code>环境变量。它用这个来产生一些<a href="https://github.com/sfackler/rust-openssl/blob/dc72a8e2c429e46c275e528b61a733a66e7877fc/openssl/build.rs#L18-L36"><code>cfg</code>
values</a>:</p>
<pre><code class="language-rust ignore">// (portion of build.rs)

if let Ok(version) = env::var(&quot;DEP_OPENSSL_VERSION_NUMBER&quot;) {
    let version = u64::from_str_radix(&amp;version, 16).unwrap();

    if version &gt;= 0x1_00_01_00_0 {
        println!(&quot;cargo:rustc-cfg=ossl101&quot;);
    }
    if version &gt;= 0x1_00_02_00_0 {
        println!(&quot;cargo:rustc-cfg=ossl102&quot;);
    }
    if version &gt;= 0x1_01_00_00_0 {
        println!(&quot;cargo:rustc-cfg=ossl110&quot;);
    }
    if version &gt;= 0x1_01_00_07_0 {
        println!(&quot;cargo:rustc-cfg=ossl110g&quot;);
    }
    if version &gt;= 0x1_01_01_00_0 {
        println!(&quot;cargo:rustc-cfg=ossl111&quot;);
    }
}
</code></pre>
<p>这些<code>cfg</code>然后可以将值与<a href="reference/../../reference/conditional-compilation.html#the-cfg-attribute"><code>cfg</code> attribute</a>或者<a href="reference/../../std/macro.cfg.html"><code>cfg</code>
macro</a>有条件地包含代码。例如，在OpenSSL 1.1.1中添加了SHA3支持，所以<a href="https://github.com/sfackler/rust-openssl/blob/dc72a8e2c429e46c275e528b61a733a66e7877fc/openssl/src/hash.rs#L67-L85">conditionally
excluded</a>对于旧版本：</p>
<pre><code class="language-rust ignore">// (portion of openssl crate)

#[cfg(ossl111)]
pub fn sha3_224() -&gt; MessageDigest {
    unsafe { MessageDigest(ffi::EVP_sha3_224()) }
}
</code></pre>
<p>当然，使用它时应该小心，因为它使生成的二进制文件更加依赖于构建环境。在本例中，如果二进制文件被分发到另一个系统，它可能没有完全相同的共享库，这可能会导致问题。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="发布到-cratesio"><a class="header" href="#发布到-cratesio">发布到 crates.io</a></h2>
<p>一旦你有一个你想与世界分享的 crate，就该把它发布到<a href="https://crates.io/">crates.io</a>! 发布是指，上载特定版本的，以让<a href="https://crates.io/">crates.io</a>进行托管.</p>
<p>发布箱(crate)子时，要小心，因为发布是<strong>常驻</strong>。永远不能覆盖同版本，并且无法删除代码。但是，可以发布的版本数量没有限制。</p>
<h3 id="在你开始发布前"><a class="header" href="#在你开始发布前">在你开始发布前</a></h3>
<p>首先，你需要一个<a href="https://crates.io/">crates.io</a>帐户，用来获取 API 令牌。为此，<a href="https://crates.io/">访问主页</a>，并通过 GitHub 帐户登录(现在需要)。在此之后，访问你的<a href="https://crates.io/me">帐号设定</a>页面，并运行<code>cargo login</code>命令联通账号。</p>
<pre><code class="language-console">$ cargo login abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<p>此命令将告诉 Cargo 关于您的 API 令牌，并将其存储在您的本地<code>~/.cargo/credentials</code>(以前是<code>~/.cargo/config</code>)。请注意，此令牌是一个<strong>秘密</strong>，不应与其他任何人分享。如果因任何原因泄漏，您应立即重新生成。</p>
<h3 id="在你创建新-crate-前"><a class="header" href="#在你创建新-crate-前">在你创建新 crate 前</a></h3>
<p>请记住<a href="https://crates.io/">crates.io</a>上箱子的名字，会采取先到先得的方式分配。一旦获得箱子名称，它就不能用于另一个箱子.</p>
<h4 id="打包一个-crate"><a class="header" href="#打包一个-crate">打包一个 crate</a></h4>
<p>下一步是，将您的包装箱打包成可供<a href="https://crates.io/">crates.io</a>上传的格式。为此，我们将使用<code>cargo package</code>子命令。这将把我们的整个包装箱全部打包成一个<code>*.crate</code>文件，其在<code>target/package</code>目录中。</p>
<pre><code class="language-console">$ cargo package
</code></pre>
<p>作为一个额外的功能，<code>*.crate</code>将独立于当前源树进行验证。在<code>*.crate</code>创建之后，会解压到<code>target/package</code>目录，然后从头开始构建，以确保构建成功的所有必要文件。可以使用<code>--no-verify</code>参数禁用此行为。</p>
<p>现在是时候看看<code>*.crate</code>文件了，为了确保您不会意外地打包 2GB 视频资源，或用于代码生成，集成测试或基准测试的大型数据文件。目前存在 10MB 的<code>*.crate</code>文件上传大小限制。所以，如果<code>tests</code>和<code>benches</code>目录及其依赖项大小，最多只达 几 MB，您仍可以将它们保存在包; 不然的话，最好排除它们。</p>
<p>在打包时，Cargo 会自动忽略版本控制系统的忽略文件，但是如果要指定要额外的忽略文件集，则可以使用清单中的<code>exclude</code>字段:</p>
<pre><code class="language-toml">[package]
# ...
exclude = [
    &quot;public/assets/*&quot;,
    &quot;videos/*&quot;,
]
</code></pre>
<p>这个数组中每个元素接受的语法是<a href="https://github.com/rust-lang/glob">rust-lang/glob</a>。如果您宁愿使用白名单，而不是黑名单,Cargo 也支持<code>include</code>字段，如果设置,则会覆盖<code>exclude</code>字段:</p>
<pre><code class="language-toml">[package]
# ...
include = [
    &quot;**/*.rs&quot;,
    &quot;Cargo.toml&quot;,
]
</code></pre>
<h3 id="上传该-crate"><a class="header" href="#上传该-crate">上传该 crate</a></h3>
<p>现在我们已经有了<code>*.crate</code>文件准备好了，可以上传到<a href="https://crates.io/">crates.io</a>，接着使用<code>cargo publish</code>命令就好。就是这样，你现在已经发布了你的第一个箱子!</p>
<pre><code class="language-console">$ cargo publish
</code></pre>
<p>如果你想跳过<code>cargo package</code>那一步，<code>cargo publish</code>如果找不到副本，子命令将自动打包本地包.</p>
<p>一定要看看<a href="reference/./manifest.zh.html#package-metadata">您可以指定的元数据</a>确保您的箱子更容易被发现!</p>
<h3 id="为已存在的-crate发布一个新版本"><a class="header" href="#为已存在的-crate发布一个新版本">为已存在的 crate，发布一个新版本</a></h3>
<p>要发布新版本，请在<code>Cargo.toml</code>更改<code>version</code>为您指定的值。记住<a href="reference/./manifest.zh.html#the-version-field">semver 规则</a>。然后可选择运行<code>cargo package</code>，如果你想检查一下<code>*.crate</code>发布前的新版本文件，然后运行<code>cargo publish</code>上传新版本.</p>
<h3 id="管理一个-基于-cratesio-的-crate"><a class="header" href="#管理一个-基于-cratesio-的-crate">管理一个 基于 crates.io 的 crate</a></h3>
<p>箱的管理主要通过命令行完成<code>cargo</code>工具，而不是<a href="https://crates.io/">crates.io</a>网络界面。为此，有一些子命令来管理包.</p>
<h4 id="cargo-yank"><a class="header" href="#cargo-yank"><code>cargo yank</code></a></h4>
<p>在您发布时，实际上可能会因某种原因，而最终破坏的箱子版本(语法错误，忘记包含文件等)的情况。对于诸如此类的情况，Cargo 支持一个箱子版本的“yank“。</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1
$ cargo yank --vers 1.0.1 --undo
</code></pre>
<p>一个 yank <strong>不是</strong>删除任何代码。例如，此功能不用于删除意外上传的机密。如果发生这种情况，您必须立即重置这些秘密.</p>
<p>一个 yank 版本的语义是，不为该版本创建新的依赖项，但所有现有的依赖项继续有效。<a href="https://crates.io/">crates.io</a>其中一个主要目标是作为永久存档的箱子库，不会随着时间的推移而改变，而允许删除版本将违背这一目标。所以基本上，一个 yank 意味着所有包的<code>Cargo.lock</code>不会被破坏，在任何的未来，<code>Cargo.lock</code>生成的文件不会列出 yank 的版本。(成为了一个孤岛版本)</p>
<h4 id="cargo-owner"><a class="header" href="#cargo-owner"><code>cargo owner</code></a></h4>
<p>箱子通常由不止一个人开发，或者主要维护者可能会随着时间而改变!箱子的所有者是唯一允许发布新版本箱子的人，但是所有者可以指定其他所有者。</p>
<pre><code class="language-console">$ cargo owner --add my-buddy
$ cargo owner --remove my-buddy
$ cargo owner --add github:rust-lang:owners
$ cargo owner --remove github:rust-lang:owners
</code></pre>
<p>给这些命令的所有者 ID 必须是 GitHub 用户名或 GitHub 团队.</p>
<p>如果用<code>--add</code>了一个用户名，那该用户成为“命名“所有者，拥有该箱子的完全权利。除了能够发布或 yank 箱子的版本，他们还能够添加或删除所有者，<em>包含</em>任命<em>他们</em>的所有者。毋庸置疑，你不应该让那些你不完全信任的人，作命名所有者。要成为命名所有者，用户必须之前就已登录<a href="https://crates.io/">crates.io</a>。</p>
<p>如果用<code>--add</code>了一个团队，那该团队成为“团队“所有者，对箱的权利受到限制。虽然他们有权发布或 yank 箱子的版本，但他们<em>不</em>能够添加或删除所有者。除了更方便管理所有者群体之外，团队还可以更安全地防止恶意所有者。</p>
<p>团队的目前的语法是<code>github:org:team</code>(见上面的例子)。要将团队添加为所有者，必须是该团队的成员。删除所有者的团队就没有此类限制.</p>
<h3 id="github-权限"><a class="header" href="#github-权限">GitHub 权限</a></h3>
<p>团队成员资格，不是 GitHub 提供的简单公共访问权限，并且在使用它时可能会遇到以下消息:</p>
<blockquote>
<p>您似乎无权从 GitHub 查询必要的属性，来完成此请求。您可能需要在<a href="https://crates.io/">crates.io</a>重新进行身份验证，并申请阅读 GitHub 组织成员资格的权限。去<a href="https://crates.io/login">https://crates.io/login</a>看看</p>
</blockquote>
<p>这基本上是一个全查询防御，当“你试图查询团队信息，而其中的五级成员访问控制，拒绝了它“。这并不夸张。GitHub 对团队访问控制的支持是企业级.</p>
<p>最可能的原因是您最后一次登录是在添加此功能之前。我们最初<em>没有</em>要求 GitHub 对用户进行身份验证时的权限，因为我们实际上并没有将用户的令牌用于登录以外的任何其他内容。但是，为了代表您能够查询团队成员资格，我们现在需要<a href="https://developer.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/"><code>read:org</code>范围权限</a>。</p>
<p>您完全可以拒绝我们这个范围，且在团队介绍之前所做的一切，都将继续有效。但是，您永远无法将团队添加为所有者，或者将团队作为团队所有者发布。如果您尝试这样做，您将收到上述错误。如果你试图发布一个你根本不拥有的箱子，但恰好有一个团队，你可能也会看到这个错误。</p>
<p>如果你改变主意，或者只是不确定是否<a href="https://crates.io/">crates.io</a>有足够的许可，你可以随时去<a href="https://crates.io/login">https://crates.io/login</a>查看，<a href="https://crates.io/">crates.io</a>会提示您，它没有获得它想要的所有范围许可。</p>
<p>查询 GitHub 的另一个障碍，是组织可能会主动拒绝第三方访问。要检查这一点，您可以访问:</p>
<pre><code>https://github.com/organizations/:org/settings/oauth_application_policy
</code></pre>
<p>这里的<code>:org</code>是组织的名称(例如 rust-lang)。你可能会看到类似的东西:</p>
<p><img src="reference/../images/org-level-acl.png" alt="Organization Access Control" /></p>
<p>你可以选择，从您组织的黑名单中，明确删除<a href="https://crates.io/">crates.io</a>，或只需按“删除限制(Remove Restrictions)“按钮，允许所有第三方应用程序访问此数据。</p>
<p>或者，当<a href="https://crates.io/">crates.io</a>请求了<code>read:org</code>范围，您可以明确进入白名单的<a href="https://crates.io/">crates.io</a>，能查询组织的问题，通过按其名称旁边的“授予访问权限(Grant Access)“按钮:</p>
<p><img src="reference/../images/auth-level-acl.png" alt="Authentication Access Control" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="package-id-specifications"><a class="header" href="#package-id-specifications">Package ID Specifications</a></h2>
<h3 id="package-id-specifications-1"><a class="header" href="#package-id-specifications-1">Package ID specifications</a></h3>
<p>包 ID 规范</p>
<p>Cargo 的子命令经常需要引用依赖关系图中的特定包来进行各种操作，例如更新，清理，构建等。为了解决这个问题，Cargo 支持包 ID 规范。规范是一个字符串，用于唯一地引用依赖关系图中的一个包.</p>
<h4 id="specification-grammar"><a class="header" href="#specification-grammar">Specification grammar</a></h4>
<p>规范语法</p>
<p>包 ID 规范的形式语法是:</p>
<pre><code class="language-notrust">pkgid := pkgname
       | [ proto &quot;://&quot; ] hostname-and-path [ &quot;#&quot; ( pkgname | semver ) ]
pkgname := name [ &quot;:&quot; semver ]

proto := &quot;http&quot; | &quot;git&quot; | ...
</code></pre>
<p>这里，括号表示内容是可选的.</p>
<h4 id="example-specifications"><a class="header" href="#example-specifications">Example specifications</a></h4>
<p>规范示例</p>
<p>这些都可以是对<code>foo</code>包的引用，版本<code>1.2.3</code>，来自注册表<code>crates.io</code></p>
<table><thead><tr><th style="text-align: left">pkgid</th><th style="text-align: center">名称</th><th style="text-align: center">版本</th><th style="text-align: center">网址</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>foo</code></td><td style="text-align: center"><code>foo</code></td><td style="text-align: center"><code>*</code></td><td style="text-align: center"><code>*</code></td></tr>
<tr><td style="text-align: left"><code>foo:1.2.3</code></td><td style="text-align: center"><code>foo</code></td><td style="text-align: center"><code>1.2.3</code></td><td style="text-align: center"><code>*</code></td></tr>
<tr><td style="text-align: left"><code>crates.io/foo</code></td><td style="text-align: center"><code>foo</code></td><td style="text-align: center"><code>*</code></td><td style="text-align: center"><code>*://crates.io/foo</code></td></tr>
<tr><td style="text-align: left"><code>crates.io/foo#1.2.3</code></td><td style="text-align: center"><code>foo</code></td><td style="text-align: center"><code>1.2.3</code></td><td style="text-align: center"><code>*://crates.io/foo</code></td></tr>
<tr><td style="text-align: left"><code>crates.io/bar#foo:1.2.3</code></td><td style="text-align: center"><code>foo</code></td><td style="text-align: center"><code>1.2.3</code></td><td style="text-align: center"><code>*://crates.io/bar</code></td></tr>
<tr><td style="text-align: left"><code>http://crates.io/foo#1.2.3</code></td><td style="text-align: center"><code>foo</code></td><td style="text-align: center"><code>1.2.3</code></td><td style="text-align: center"><code>http://crates.io/foo</code></td></tr>
</tbody></table>
<h4 id="brevity-of-specifications"><a class="header" href="#brevity-of-specifications">Brevity of specifications</a></h4>
<p>规范的简洁</p>
<p>这样做的目的是用简洁和详尽的语法来引用依赖图中的包。而不明确的引用可以指代一个或多个包。若使用相同的规范会引用多个包，那大多数命令都会生成错误。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="来源-更换"><a class="header" href="#来源-更换">来源 更换</a></h2>
<p>本文档是关于更换 crate 索引(注册表)。您可以阅读有关重写依赖项的信息，它在本文档的<a href="reference/reference/specifying-dependencies.html#overriding-dependencies">重写依赖关系</a>部分。</p>
<p>Cargo 支持<strong>用另一个来源更换一个来源</strong>的能力，可根据镜像或 vendoring 依赖关系来表达倾向。要配置这些，目前通过<a href="reference/reference/config.html"><code>.cargo/config</code>配置</a>机制完成，像这样:</p>
<pre><code class="language-toml"># `source` 表下，就是存储有关要更换的来源名称
[source]

# 在`source` 表格之下的，可为一定数量的有关来源名称. 示例下面就# 定义了一个新源， 叫 `my-awesome-source`， 其内容来自本地 # `vendor`目录 ，其相对于包含`.cargo/config`文件的目录
[source.my-awesome-source]
directory = &quot;vendor&quot;

# Git sources 也指定一个 branch/tag/rev
git = &quot;https://example.com/path/to/repo&quot;
# branch = &quot;master&quot;
# tag = &quot;v1.0.1&quot;
# rev = &quot;313f44e8&quot;

# The crates.io 默认源 在&quot;crates-io&quot;名称下， 且在这里我们使用 `replace-with` 字段指明 默认源更换成&quot;my-awesome-source&quot;源
[source.crates-io]
replace-with = &quot;my-awesome-source&quot;
</code></pre>
<p>使用此配置，Cargo 会尝试在“vendor“目录中，查找所有包，而不是 查询在线注册表 crates.io 。Cargo 有两种来源更换的表达 :</p>
<ul>
<li>
<p>供应(Vendoring) - 可以定义自定义源，它们表示本地文件系统上的包。这些源是它们正在更换的源的子集，并在需要时可以检入包中。</p>
</li>
<li>
<p>镜像(Mirroring) - 可以更换为等效版本的源，行为表现为 crates.io 本身的缓存。</p>
</li>
</ul>
<p>Cargo 有一个关于来源更换的核心假设，源代码从两个完全相同的源而来。在上面的例子中，Cargo 假设所有的箱子都来自<code>my-awesome-source</code>，与<code>crates-io</code>副本完全相同。请注意，这也意味着<code>my-awesome-source</code>，不允许有<code>crates-io</code>源不存在的箱。</p>
<p>因此，来源更换不适用于依赖项补丁(fix bug)，或私有注册表等情况。Cargo 是通过使用<a href="reference/reference/manifest.html#the-replace-section"><code>[replace]</code>字段</a>支持依赖项补丁，计划为未来版本的 Cargo 提供私人注册表的支持。</p>
<h3 id="配置-1"><a class="header" href="#配置-1">配置</a></h3>
<p>更换源的配置通过完成<a href="reference/reference/config.html"><code>.cargo/config</code></a>，下面为全套可用字段是:</p>
<pre><code class="language-toml"># 每个源都有自己的表格，名称即是表名
[source.the-source-name]

# 命令 ，`the-source-name` 会被`another-source`取代
replace-with = &quot;another-source&quot;

# 有几种可用的源定义(接下来有所描述)
registry = &quot;https://example.com/path/to/index&quot;
local-registry = &quot;path/to/registry&quot;
directory = &quot;path/to/vendor&quot;
</code></pre>
<p><code>crates-io</code>代表 crates.io 在线注册表(箱的默认来源)，可以更换为:</p>
<pre><code class="language-toml">[source.crates-io]
replace-with = 'another-source'
</code></pre>
<h3 id="注册表源"><a class="header" href="#注册表源">注册表源</a></h3>
<p>“注册表源“与 crates.io 本身相同。也就是说，它也有一个在 git 存储库中提供的索引，该存储库匹配<a href="https://github.com/rust-lang/crates.io-index">crates.io index</a>的格式。然后该存储库具有指示从哪里下载包的配置。</p>
<p>目前还没有一个已经设置 crates.io 的镜像的可用项目。请继续关注!</p>
<blockquote>
<p>中国用户，可搜索 ‘rust 换 中科大 源’</p>
</blockquote>
<h3 id="本地-注册表源"><a class="header" href="#本地-注册表源">本地 注册表源</a></h3>
<p>“本地注册表源“旨在成为另一个注册表源的子集，但可在本地文件系统(也称为 vendoring)上使用。本地注册表是提前下载，通常与一个 <code>Cargo.lock</code>同步，并由一组<code>*.crate</code>文件和像普通注册表一样的索引组成。</p>
<p>管理和创建本地注册表源的主要方法是通过<a href="https://crates.io/crates/cargo-local-registry"><code>cargo-local-registry</code></a>子命令，可在 crates.io 上找到，并用<code>cargo install cargo-local-registry</code>安装。</p>
<p>本地注册表包含在一个目录，其中包含许多从 crates.io 下载的<code>*.crate</code>文件，以及<code>index</code>目录，它与 crates.io-index 项目目录具有相同格式(仅填充有存在的 crates).</p>
<h3 id="目录-源"><a class="header" href="#目录-源">目录 源</a></h3>
<p>“目录源“类似于本地注册表源，其中包含本地文件系统上许多的可用包，适用于 vendoring 依赖项。与本地注册表一样，目录源主要由外部子命令管理<a href="https://crates.io/crates/cargo-vendor"><code>cargo-vendor</code></a>，可用<code>cargo install cargo-vendor</code>安装。</p>
<p>目录源与本地注册表不同，但它们包含<code>*.crate</code>文件的解压缩版本，使其在某些情况下，更适合检查所有内容到源代码控制工具。目录源只是一个包含许多其他目录的目录，其中包含 crates 的源代码(解压缩版本的<code>*.crate</code>文件)。目前，对每个目录的名称没有限制。</p>
<p>目录源中的每个包也有一个关联的元数据文件，指示包中每个文件的校验和，以防止意外修改。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="external-tools"><a class="header" href="#external-tools">External tools</a></h2>
<p>外部工具</p>
<p>Cargo 的目标之一是与第三方工具(如 IDE 和其他构建系统)的简单集成。为了简化集成，Cargo 有几个设施:</p>
<ul>
<li>
<p>一个<code>cargo metadata</code>命令，以 JSON 格式输出包结构和依赖关系信息，</p>
</li>
<li>
<p>一个<code>--message-format</code>标志，输出有关特定构建的信息，以及</p>
</li>
<li>
<p>支持自定义子命令.</p>
</li>
</ul>
<h3 id="information-about-package-structure"><a class="header" href="#information-about-package-structure">Information about package structure</a></h3>
<p>包结构的资料</p>
<p>您可以使用<code>cargo metadata</code>命令，以获取有关包结构和依赖关系的信息。命令的输出如下所示:</p>
<pre><code class="language-text">{
  // Integer 版本格式数字.
  &quot;version&quot;: integer,

  // 工作区包的列表, 包括 依赖项.
  &quot;packages&quot;: [
    {
      // 包 识别id 队列.
      &quot;id&quot;: PackageId,

      &quot;name&quot;: string,

      &quot;version&quot;: string,

      &quot;source&quot;: SourceId,

      // 确认依赖的一个列表, 可看 `resolve` 字段中的真实依赖.
      &quot;dependencies&quot;: [ Dependency ],

      &quot;targets: [ Target ],

      //  Cargo.toml 路径
      &quot;manifest_path&quot;: string,
    }
  ],

  &quot;workspace_members&quot;: [ PackageId ],

  // 依赖 关系图.
  &quot;resolve&quot;: {
     &quot;nodes&quot;: [
       {
         &quot;id&quot;: PackageId,
         &quot;dependencies&quot;: [ PackageId ]
       }
     ]
  }
}
</code></pre>
<p>格式稳定且有版本化。调用<code>cargo metadata</code>时，你应该通过<code>--format-version</code>明确标记，以避免向前不兼容的危险。</p>
<p>如果你正在使用 Rust，这有个<a href="https://crates.io/crates/cargo_metadata">cargo_metadata</a>箱.</p>
<h3 id="information-about-build"><a class="header" href="#information-about-build">Information about build</a></h3>
<p>关于构建的资料</p>
<p>传递<code>--message-format=json</code>给，Cargo， 将在构建期间输出以下信息:</p>
<ul>
<li>
<p>编译器错误和警告，</p>
</li>
<li>
<p>制作的工件，</p>
</li>
<li>
<p>构建脚本的结果(例如，本机依赖项).</p>
</li>
</ul>
<p>输出以每行格式的 JSON 对象转到 stdout。<code>reason</code>字段区分不同类型的消息.</p>
<p>有关 Makefile 兼容格式的依赖关系的信息存储在工件旁的<code>.d</code>文件中。</p>
<h3 id="custom-subcommands"><a class="header" href="#custom-subcommands">Custom subcommands</a></h3>
<p>自定义的子命令</p>
<p>Cargo 设计为，可以使用新的子命令进行扩展，而无需修改 Cargo 本身。这是通过转化一个 cargo <code>(?&lt;command&gt;[^ ]+)</code>的命令调用，变化为调用外部工具<code>cargo-${command}</code>来实现的。外部工具必须存在于用户其中一个<code>$PATH</code>目录中.</p>
<p>当 Cargo 调用自定义子命令时，子命令的第一个参数将像往常一样是自定义子命令的文件名。第二个参数将是子命令名称本身。例如，在调用<code>cargo-${command}</code>时，第二个参数是<code>${command}</code>。命令行上的其他所有参数将保持不变.</p>
<p>Cargo 还可以用<code>cargo help ${command}</code>显示自定义子命令的帮助输出。Cargo 假定子命令将在第三个参数出现时，打印帮助消息<code>--help</code>.所以，<code>cargo help ${command}</code>会调用<code>cargo-${command} ${command} --help</code>.</p>
<p>自定义子命令可以使用<code>CARGO</code>环境变量回调 Cargo。或者，它可以链接到作为一个库的<code>cargo</code>箱，但这种方法有缺点:</p>
<ul>
<li>
<p>Cargo 作为库是不稳定的:API 可能会更改，但不会弃用</p>
</li>
<li>
<p>链接的 Cargo 库的版本可能与 Cargo 二进制文件不同</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="registries"><a class="header" href="#registries">Registries</a></h2>
<p>Cargo安装箱子并从“注册表”中获取依赖项。默认注册表是<a href="https://crates.io/">crates.io</a>.注册表包含一个“索引”，其中包含可用箱子的可搜索列表。注册表还可以提供web API，以支持直接从Cargo发布新箱子。</p>
<blockquote>
<p>注意：如果您对镜像或出售现有注册表感兴趣，请查看<a href="reference/source-replacement.html">Source Replacement</a>.</p>
</blockquote>
<h3 id="using-an-alternate-registry"><a class="header" href="#using-an-alternate-registry">Using an Alternate Registry</a></h3>
<p>要使用注册表而不是<a href="https://crates.io/">crates.io</a>，必须将注册表的名称和索引URL添加到<a href="reference/config.html"><code>.cargo/config.toml</code> file</a>这个<code>registries</code>表中的每个注册表都有一个键，例如：</p>
<pre><code class="language-toml">[registries]
my-registry = { index = &quot;https://my-intranet:8080/git/index&quot; }
</code></pre>
<p>这个<code>index</code>键应该是指向带有注册表索引的git存储库的URL。然后，箱子可以通过指定<code>registry</code>键和中该依赖项项中注册表名称的值<code>Cargo.toml</code>:</p>
<pre><code class="language-toml"># Sample Cargo.toml
[package]
name = &quot;my-project&quot;
version = &quot;0.1.0&quot;

[dependencies]
other-crate = { version = &quot;1.0&quot;, registry = &quot;my-registry&quot; }
</code></pre>
<p>与大多数配置值一样，可以使用环境变量而不是配置文件指定索引。例如，设置以下环境变量将完成与定义配置文件相同的任务：</p>
<pre><code class="language-ignore">CARGO_REGISTRIES_MY_REGISTRY_INDEX=https://my-intranet:8080/git/index
</code></pre>
<blockquote>
<p>注：<a href="https://crates.io/">crates.io</a>不接受依赖其他登记处箱子的包装。</p>
</blockquote>
<h3 id="publishing-to-an-alternate-registry"><a class="header" href="#publishing-to-an-alternate-registry">Publishing to an Alternate Registry</a></h3>
<p>如果注册表支持web API访问，那么包可以从Cargo直接发布到注册表。Cargo的几个命令，比如<a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a>坐一会儿<code>--registry</code>命令行标志，指示要使用哪个注册表。例如，要在当前目录中发布包，请执行以下操作：</p>
<ol>
<li>
<p><code>cargo login --registry=my-registry</code></p>
<p>这只需要做一次。您必须输入从注册表网站检索到的机密API令牌。或者，令牌可以直接传递给服务器<code>publish</code>指挥<code>--token</code>命令行标志或带有注册表名称的环境变量，例如<code>CARGO_REGISTRIES_MY_REGISTRY_TOKEN</code>.</p>
</li>
<li>
<p><code>cargo publish --registry=my-registry</code></p>
</li>
</ol>
<p>而不是总是通过考试<code>--registry</code>命令行选项，可以在中设置默认注册表<a href="reference/config.html"><code>.cargo/config.toml</code></a>和<code>registry.default</code>钥匙</p>
<p>设定<code>package.publish</code>输入<code>Cargo.toml</code>清单限制允许将包发布到哪些注册表。这有助于防止意外地将封闭源代码包发布到<a href="https://crates.io/">crates.io</a>。该值可以是注册表名列表，例如：</p>
<pre><code class="language-toml">[package]
# ...
publish = [&quot;my-registry&quot;]
</code></pre>
<p>这个<code>publish</code>价值也可能是<code>false</code>限制所有发布，这与空列表相同。</p>
<p>保存的身份验证信息<a href="reference/../commands/cargo-login.html"><code>cargo login</code></a>存储在<code>credentials.toml</code>Cargo主目录中的文件（默认）<code>$HOME/.cargo</code>)。每个注册表都有一个单独的表，例如：</p>
<pre><code class="language-toml">[registries.my-registry]
token = &quot;854DvwSlUwEHtIo3kWy6x7UCPKHfzCmy&quot;
</code></pre>
<h3 id="running-a-registry"><a class="header" href="#running-a-registry">Running a Registry</a></h3>
<p>一个最小的注册表可以通过一个包含索引的git存储库和一个包含压缩文件的服务器来实现<code>.crate</code>创建的文件<a href="reference/../commands/cargo-package.html"><code>cargo package</code></a>。用户将无法使用Cargo向其发布，但对于封闭环境而言，这可能就足够了。</p>
<p>支持发布的功能齐全的注册表还需要一个符合Cargo使用的API的web API服务。下面介绍了web API。</p>
<p>商业和社区项目可用于建立和运行注册表。查看<a href="https://github.com/rust-lang/cargo/wiki/Third-party-registries">https://github.com/rust-lang/cargo/wiki/Third-party-registries</a>查看可用内容的列表。</p>
<h3 id="index-format"><a class="header" href="#index-format">Index Format</a></h3>
<p>下面定义了索引的格式。偶尔会添加新功能，只有从引入它们的Cargo版本开始才能理解这些功能。旧版本的Cargo可能无法使用使用新功能的软件包。然而，旧包装的格式不应该改变，所以旧版本的Cargo应该能够使用它们。</p>
<p>索引存储在git存储库中，这样Cargo就可以高效地获取索引的增量更新。存储库的根目录中有一个名为<code>config.json</code>其中包含Cargo用于访问注册表的JSON信息。这是一个例子，说明<a href="https://crates.io/">crates.io</a>配置文件如下所示：</p>
<pre><code class="language-javascript">{
    &quot;dl&quot;: &quot;https://crates.io/api/v1/crates&quot;,
    &quot;api&quot;: &quot;https://crates.io&quot;
}
</code></pre>
<p>关键是：</p>
<ul>
<li>
<p><code>dl</code>：这是下载索引中列出的箱子的URL。该值可能具有以下标记，这些标记将替换为相应的值：</p>
<ul>
<li><code>{crate}</code>：箱子的名称。</li>
<li><code>{version}</code>：箱子版本。</li>
<li><code>{prefix}</code>：根据箱子名称计算的目录前缀。例如，一个名为<code>cargo</code>前缀为<code>ca/rg</code>.详情见下文。</li>
<li><code>{lowerprefix}</code>：的小写变体<code>{prefix}</code>.</li>
<li><code>{sha256-checksum}</code>：箱子的sha256校验和。</li>
</ul>
<p>如果不存在任何标记，则值<code>/{crate}/{version}/download</code>被附加到结尾。</p>
</li>
<li>
<p><code>api</code>：这是web API的基本URL。此键是可选的，但如果未指定，则可以使用以下命令：<a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a>行不通。下面介绍web API。</p>
</li>
</ul>
<p>下载端点应发送<code>.crate</code>请求的包的文件。Cargo支持https、http和文件URL、http重定向、HTTP1和HTTP2。TLS支持的具体细节取决于Cargo运行的平台、Cargo的版本以及编译方式。</p>
<p>索引存储库的其余部分为每个包包含一个文件，其中文件名是包的小写名称。每个版本的软件包在文件中都有单独的一行。这些文件被组织在一层目录中：</p>
<ul>
<li>名称为1个字符的包被放置在名为<code>1</code>.</li>
<li>名为2个字符的包被放置在名为<code>2</code>.</li>
<li>具有3个字符名称的包被放置在目录中<code>3/{first-character}</code>哪里<code>{first-character}</code>是包名称的第一个字符。</li>
<li>所有其他包都存储在名为<code>{first-two}/{second-two}</code>其中，顶层目录是包名的前两个字符，下一个子目录是包名的第三个和第四个字符。例如<code>cargo</code>将存储在名为<code>ca/rg/cargo</code>.</li>
</ul>
<blockquote>
<p>注意：虽然索引文件名是小写的，但包含包名的字段<code>Cargo.toml</code>索引JSON数据区分大小写，可能包含大小写字符。</p>
</blockquote>
<p>上面的目录名是根据转换成小写的包名计算的；它由标记表示<code>{lowerprefix}</code>.当使用原始包名而不进行大小写转换时，生成的目录名由标记表示<code>{prefix}</code>.例如，包裹<code>MyCrate</code>会有一个<code>{prefix}</code>属于<code>My/Cr</code>还有<code>{lowerprefix}</code>属于<code>my/cr</code>.一般来说，使用<code>{prefix}</code>推荐超过<code>{lowerprefix}</code>，但每种选择都有利弊。使用<code>{prefix}</code>在不区分大小写的文件系统上，会导致（无害但不美观的）目录别名。例如<code>crate</code>和<code>CrateTwo</code>有<code>{prefix}</code>价值观<code>cr/at</code>和<code>Cr/at</code>; 这些在Unix机器上是不同的，但在Windows上是同一目录的别名。使用大小写规范化的目录可以避免别名，但在区分大小写的文件系统上，更难支持缺少大小写的旧版本的Cargo<code>{prefix}</code>/<code>{lowerprefix}</code>。例如，nginx重写规则可以轻松构建<code>{prefix}</code>但无法将大小写转换为构造<code>{lowerprefix}</code>.</p>
<p>注册中心应考虑对包索引中添加的包名称执行限制。Cargo本身允许使用任何名称<a href="reference/../../std/primitive.char.html#method.is_alphanumeric">alphanumeric</a>, <code>-</code>或<code>_</code>角色。<a href="https://crates.io/">crates.io</a>施加了自身的限制，包括：</p>
<ul>
<li>仅允许使用ASCII字符。</li>
<li>只有字母数字，<code>-</code>和<code>_</code>角色。</li>
<li>第一个字符必须按字母顺序排列。</li>
<li>不区分大小写的碰撞检测。</li>
<li>防止分歧<code>-</code> vs <code>_</code>.</li>
<li>在特定长度下（最大64）。</li>
<li>拒绝保留名称，例如Windows特殊文件名，如“nul”。</li>
</ul>
<p>注册中心应考虑合并类似的限制，并考虑安全性的影响，例如<a href="https://en.wikipedia.org/wiki/IDN_homograph_attack">IDN homograph
attacks</a>以及其他方面的担忧<a href="https://www.unicode.org/reports/tr36/">UTR36</a>和<a href="https://www.unicode.org/reports/tr39/">UTS39</a>.</p>
<p>包文件中的每一行都包含一个JSON对象，该对象描述包的发布版本。下面是一个漂亮的打印示例，带有解释条目格式的注释。</p>
<pre><code class="language-javascript">{
    // The name of the package.
    // This must only contain alphanumeric, `-`, or `_` characters.
    &quot;name&quot;: &quot;foo&quot;,
    // The version of the package this row is describing.
    // This must be a valid version number according to the Semantic
    // Versioning 2.0.0 spec at https://semver.org/.
    &quot;vers&quot;: &quot;0.1.0&quot;,
    // Array of direct dependencies of the package.
    &quot;deps&quot;: [
        {
            // Name of the dependency.
            // If the dependency is renamed from the original package name,
            // this is the new name. The original package name is stored in
            // the `package` field.
            &quot;name&quot;: &quot;rand&quot;,
            // The SemVer requirement for this dependency.
            // This must be a valid version requirement defined at
            // https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html.
            &quot;req&quot;: &quot;^0.6&quot;,
            // Array of features (as strings) enabled for this dependency.
            &quot;features&quot;: [&quot;i128_support&quot;],
            // Boolean of whether or not this is an optional dependency.
            &quot;optional&quot;: false,
            // Boolean of whether or not default features are enabled.
            &quot;default_features&quot;: true,
            // The target platform for the dependency.
            // null if not a target dependency.
            // Otherwise, a string such as &quot;cfg(windows)&quot;.
            &quot;target&quot;: null,
            // The dependency kind.
            // &quot;dev&quot;, &quot;build&quot;, or &quot;normal&quot;.
            // Note: this is a required field, but a small number of entries
            // exist in the crates.io index with either a missing or null
            // `kind` field due to implementation bugs.
            &quot;kind&quot;: &quot;normal&quot;,
            // The URL of the index of the registry where this dependency is
            // from as a string. If not specified or null, it is assumed the
            // dependency is in the current registry.
            &quot;registry&quot;: null,
            // If the dependency is renamed, this is a string of the actual
            // package name. If not specified or null, this dependency is not
            // renamed.
            &quot;package&quot;: null,
        }
    ],
    // A SHA256 checksum of the `.crate` file.
    &quot;cksum&quot;: &quot;d867001db0e2b6e0496f9fac96930e2d42233ecd3ca0413e0753d4c7695d289c&quot;,
    // Set of features defined for the package.
    // Each feature maps to an array of features or dependencies it enables.
    &quot;features&quot;: {
        &quot;extras&quot;: [&quot;rand/simd_support&quot;]
    },
    // Boolean of whether or not this version has been yanked.
    &quot;yanked&quot;: false,
    // The `links` string value from the package's manifest, or null if not
    // specified. This field is optional and defaults to null.
    &quot;links&quot;: null
}
</code></pre>
<p>除了<code>yanked</code>其值可能随时更改的字段。</p>
<h3 id="web-api"><a class="header" href="#web-api">Web API</a></h3>
<p>注册表可以在中定义的位置托管web API<code>config.json</code>支持下面列出的任何操作。</p>
<p>Cargo包括<code>Authorization</code>需要身份验证的请求的标头。标头值是API标记。如果令牌无效，服务器应使用403响应代码进行响应。用户需要访问注册中心的网站以获取代币，Cargo可以使用<a href="reference/../commands/cargo-login.html"><code>cargo login</code></a>命令，或通过在命令行上传递令牌。</p>
<p>响应使用200响应代码表示成功和错误。Cargo查看JSON响应以确定是成功还是失败。故障响应有一个JSON对象，其结构如下：</p>
<pre><code class="language-javascript">{
    // Array of errors to display to the user.
    &quot;errors&quot;: [
        {
            // The error message as a string.
            &quot;detail&quot;: &quot;error message text&quot;
        }
    ]
}
</code></pre>
<p>服务器还可以使用404响应代码进行响应，以指示未找到请求的资源（例如，未知的箱子名称）。但是，使用200响应和<code>errors</code>对象允许注册表在需要时提供更详细的错误消息。</p>
<p>为了向后兼容，服务器应该忽略任何意外的查询参数或JSON字段。如果缺少JSON字段，则应假定该字段为空。端点的版本由<code>v1</code>路径的组件，Cargo负责处理将来需要的向后兼容性回退。</p>
<p>Cargo为所有请求设置以下标题：</p>
<ul>
<li><code>Content-Type</code>: <code>application/json</code></li>
<li><code>Accept</code>: <code>application/json</code></li>
<li><code>User-Agent</code>：Cargo版本，例如<code>cargo 1.32.0 (8610973aa 2019-01-02)</code>。用户可在配置值中对此进行修改。添加到1.29中。</li>
</ul>
<h4 id="publish"><a class="header" href="#publish">Publish</a></h4>
<ul>
<li>终点：<code>/api/v1/crates/new</code></li>
<li>方法：放</li>
<li>授权：包括</li>
</ul>
<p>发布端点用于发布箱子的新版本。服务器应验证箱子，使其可供下载，并将其添加到索引中。</p>
<p>Cargo发送的数据主体是：</p>
<ul>
<li>JSON数据长度的32位无符号小整数。</li>
<li>作为JSON对象的包元数据。</li>
<li>数据长度的32位无符号小整数<code>.crate</code>文件</li>
<li>这个<code>.crate</code>文件</li>
</ul>
<p>下面是JSON对象的注释示例。关于美国实施的一些限制的一些注释<a href="https://crates.io/">crates.io</a>仅用于说明可能进行的验证类型的一些建议，不应被视为限制的详尽列表<a href="https://crates.io/">crates.io</a>强加。</p>
<pre><code class="language-javascript">{
    // The name of the package.
    &quot;name&quot;: &quot;foo&quot;,
    // The version of the package being published.
    &quot;vers&quot;: &quot;0.1.0&quot;,
    // Array of direct dependencies of the package.
    &quot;deps&quot;: [
        {
            // Name of the dependency.
            // If the dependency is renamed from the original package name,
            // this is the original name. The new package name is stored in
            // the `explicit_name_in_toml` field.
            &quot;name&quot;: &quot;rand&quot;,
            // The semver requirement for this dependency.
            &quot;version_req&quot;: &quot;^0.6&quot;,
            // Array of features (as strings) enabled for this dependency.
            &quot;features&quot;: [&quot;i128_support&quot;],
            // Boolean of whether or not this is an optional dependency.
            &quot;optional&quot;: false,
            // Boolean of whether or not default features are enabled.
            &quot;default_features&quot;: true,
            // The target platform for the dependency.
            // null if not a target dependency.
            // Otherwise, a string such as &quot;cfg(windows)&quot;.
            &quot;target&quot;: null,
            // The dependency kind.
            // &quot;dev&quot;, &quot;build&quot;, or &quot;normal&quot;.
            &quot;kind&quot;: &quot;normal&quot;,
            // The URL of the index of the registry where this dependency is
            // from as a string. If not specified or null, it is assumed the
            // dependency is in the current registry.
            &quot;registry&quot;: null,
            // If the dependency is renamed, this is a string of the new
            // package name. If not specified or null, this dependency is not
            // renamed.
            &quot;explicit_name_in_toml&quot;: null,
        }
    ],
    // Set of features defined for the package.
    // Each feature maps to an array of features or dependencies it enables.
    // Cargo does not impose limitations on feature names, but crates.io
    // requires alphanumeric ASCII, `_` or `-` characters.
    &quot;features&quot;: {
        &quot;extras&quot;: [&quot;rand/simd_support&quot;]
    },
    // List of strings of the authors.
    // May be empty.
    &quot;authors&quot;: [&quot;Alice &lt;a@example.com&gt;&quot;],
    // Description field from the manifest.
    // May be null. crates.io requires at least some content.
    &quot;description&quot;: null,
    // String of the URL to the website for this package's documentation.
    // May be null.
    &quot;documentation&quot;: null,
    // String of the URL to the website for this package's home page.
    // May be null.
    &quot;homepage&quot;: null,
    // String of the content of the README file.
    // May be null.
    &quot;readme&quot;: null,
    // String of a relative path to a README file in the crate.
    // May be null.
    &quot;readme_file&quot;: null,
    // Array of strings of keywords for the package.
    &quot;keywords&quot;: [],
    // Array of strings of categories for the package.
    &quot;categories&quot;: [],
    // String of the license for the package.
    // May be null. crates.io requires either `license` or `license_file` to be set.
    &quot;license&quot;: null,
    // String of a relative path to a license file in the crate.
    // May be null.
    &quot;license_file&quot;: null,
    // String of the URL to the website for the source repository of this package.
    // May be null.
    &quot;repository&quot;: null,
    // Optional object of &quot;status&quot; badges. Each value is an object of
    // arbitrary string to string mappings.
    // crates.io has special interpretation of the format of the badges.
    &quot;badges&quot;: {
        &quot;travis-ci&quot;: {
            &quot;branch&quot;: &quot;master&quot;,
            &quot;repository&quot;: &quot;rust-lang/cargo&quot;
        }
    },
    // The `links` string value from the package's manifest, or null if not
    // specified. This field is optional and defaults to null.
    &quot;links&quot;: null
}
</code></pre>
<p>成功的响应包括JSON对象：</p>
<pre><code class="language-javascript">{
    // Optional object of warnings to display to the user.
    &quot;warnings&quot;: {
        // Array of strings of categories that are invalid and ignored.
        &quot;invalid_categories&quot;: [],
        // Array of strings of badge names that are invalid and ignored.
        &quot;invalid_badges&quot;: [],
        // Array of strings of arbitrary warnings to display to the user.
        &quot;other&quot;: []
    }
}
</code></pre>
<h4 id="yank"><a class="header" href="#yank">Yank</a></h4>
<ul>
<li>终点：<code>/api/v1/crates/{crate_name}/{version}/yank</code></li>
<li>方法：删除</li>
<li>授权：包括</li>
</ul>
<p>yank端点将设置<code>yank</code>指定箱子版本的字段<code>true</code>在索引中。</p>
<p>成功的响应包括JSON对象：</p>
<pre><code class="language-javascript">{
    // Indicates the delete succeeded, always true.
    &quot;ok&quot;: true,
}
</code></pre>
<h4 id="unyank"><a class="header" href="#unyank">Unyank</a></h4>
<ul>
<li>终点：<code>/api/v1/crates/{crate_name}/{version}/unyank</code></li>
<li>方法：放</li>
<li>授权：包括</li>
</ul>
<p>unyank端点将设置<code>yank</code>指定箱子版本的字段<code>false</code>在索引中。</p>
<p>成功的响应包括JSON对象：</p>
<pre><code class="language-javascript">{
    // Indicates the delete succeeded, always true.
    &quot;ok&quot;: true,
}
</code></pre>
<h4 id="owners"><a class="header" href="#owners">Owners</a></h4>
<p>Cargo没有用户和所有者的固有概念，但它确实提供了<code>owner</code>协助管理有权控制箱子的人员的命令。由注册中心决定用户和所有者的具体处理方式。看到了吗<a href="reference/publishing.html#cargo-owner">publishing documentation</a>想了解一下<a href="https://crates.io/">crates.io</a>通过GitHub用户和团队处理所有者。</p>
<h5 id="owners-list"><a class="header" href="#owners-list">Owners: List</a></h5>
<ul>
<li>终点：<code>/api/v1/crates/{crate_name}/owners</code></li>
<li>方法：获取</li>
<li>授权：包括</li>
</ul>
<p>owners端点返回箱子所有者的列表。</p>
<p>成功的响应包括JSON对象：</p>
<pre><code class="language-javascript">{
    // Array of owners of the crate.
    &quot;users&quot;: [
        {
            // Unique unsigned 32-bit integer of the owner.
            &quot;id&quot;: 70,
            // The unique username of the owner.
            &quot;login&quot;: &quot;github:rust-lang:core&quot;,
            // Name of the owner.
            // This is optional and may be null.
            &quot;name&quot;: &quot;Core&quot;,
        }
    ]
}
</code></pre>
<h5 id="owners-add"><a class="header" href="#owners-add">Owners: Add</a></h5>
<ul>
<li>终点：<code>/api/v1/crates/{crate_name}/owners</code></li>
<li>方法：放</li>
<li>授权：包括</li>
</ul>
<p>PUT请求将向注册表发送向箱子添加新所有者的请求。如何处理请求取决于注册表。例如<a href="https://crates.io/">crates.io</a>向用户发送一个邀请，用户在添加之前必须接受该邀请。</p>
<p>请求应包括以下JSON对象：</p>
<pre><code class="language-javascript">{
    // Array of `login` strings of owners to add.
    &quot;users&quot;: [&quot;login_name&quot;]
}
</code></pre>
<p>成功的响应包括JSON对象：</p>
<pre><code class="language-javascript">{
    // Indicates the add succeeded, always true.
    &quot;ok&quot;: true,
    // A string to be displayed to the user.
    &quot;msg&quot;: &quot;user ehuss has been invited to be an owner of crate cargo&quot;
}
</code></pre>
<h5 id="owners-remove"><a class="header" href="#owners-remove">Owners: Remove</a></h5>
<ul>
<li>终点：<code>/api/v1/crates/{crate_name}/owners</code></li>
<li>方法：删除</li>
<li>授权：包括</li>
</ul>
<p>删除请求将从箱子中删除所有者。请求应包括以下JSON对象：</p>
<pre><code class="language-javascript">{
    // Array of `login` strings of owners to remove.
    &quot;users&quot;: [&quot;login_name&quot;]
}
</code></pre>
<p>成功的响应包括JSON对象：</p>
<pre><code class="language-javascript">{
    // Indicates the remove succeeded, always true.
    &quot;ok&quot;: true
}
</code></pre>
<h4 id="search"><a class="header" href="#search">Search</a></h4>
<ul>
<li>终点：<code>/api/v1/crates</code></li>
<li>方法：获取</li>
<li>查询参数：
<ul>
<li><code>q</code>：搜索查询字符串。</li>
<li><code>per_page</code>：结果数，默认为10，最大为100。</li>
</ul>
</li>
</ul>
<p>搜索请求将使用服务器上定义的条件搜索箱子。</p>
<p>成功的响应包括JSON对象：</p>
<pre><code class="language-javascript">{
    // Array of results.
    &quot;crates&quot;: [
        {
            // Name of the crate.
            &quot;name&quot;: &quot;rand&quot;,
            // The highest version available.
            &quot;max_version&quot;: &quot;0.6.1&quot;,
            // Textual description of the crate.
            &quot;description&quot;: &quot;Random number generators and other randomness functionality.\n&quot;,
        }
    ],
    &quot;meta&quot;: {
        // Total number of results available on the server.
        &quot;total&quot;: 119
    }
}
</code></pre>
<h4 id="login"><a class="header" href="#login">Login</a></h4>
<ul>
<li>终点：<code>/me</code></li>
</ul>
<p>“登录”端点不是实际的API请求。它的存在完全是为了<a href="reference/../commands/cargo-login.html"><code>cargo login</code></a>命令显示URL，以指示用户在web浏览器中访问以登录并检索API令牌。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependency-resolution"><a class="header" href="#dependency-resolution">Dependency Resolution</a></h1>
<p>Cargo的主要任务之一是根据每个包中指定的版本要求确定要使用的依赖项的版本。这个过程称为“依赖解析”，由“解析程序”执行。解析结果存储在<code>Cargo.lock</code>文件，该文件将依赖项“锁定”到特定版本，并随时间保持固定。</p>
<p>解析器试图在考虑可能冲突的需求的同时统一公共依赖关系。以下各节提供了有关如何处理这些约束以及如何使用解析器的一些详细信息。</p>
<p>参见本章<a href="reference/specifying-dependencies.html">Specifying Dependencies</a>有关如何指定依赖项要求的更多详细信息。</p>
<p>这个<a href="reference/../commands/cargo-tree.html"><code>cargo tree</code></a>命令可用于可视化分解器的结果。</p>
<h2 id="semver-compatibility-1"><a class="header" href="#semver-compatibility-1">SemVer compatibility</a></h2>
<p>Cargo用途<a href="https://semver.org/">SemVer</a>用于指定版本号。这为不同版本的软件包之间的兼容性建立了一个通用约定。看到了吗<a href="reference/semver.html">SemVer Compatibility</a>第章为“兼容”变更的指导。“兼容性”这个概念很重要，因为Cargo假设在不破坏构建的情况下，在兼容范围内更新依赖项应该是安全的。</p>
<p>如果最左边的非零主/次/补丁组件相同，则认为版本兼容。例如<code>1.0.3</code>和<code>1.1.0</code>被认为是兼容的，因此从旧版本更新到新版本应该是安全的。然而，来自<code>1.1.0</code>到<code>2.0.0</code>不允许自动生成。此约定也适用于前导零的版本。例如<code>0.1.0</code>和<code>0.1.2</code>是兼容的，但是<code>0.1.0</code>和<code>0.2.0</code>不是。同样地，<code>0.0.1</code>和<code>0.0.2</code>不兼容。</p>
<p>作为一个快速的复习<em>版本要求</em>Cargo用于依赖项的语法是：</p>
<table><thead><tr><th>要求</th><th>实例</th><th>等价</th><th>描述</th></tr></thead><tbody>
<tr><td>插入符号</td><td><code>1.2.3</code>或<code>^1.2.3</code></td><td><code>&gt;=1.2.3, &lt;2.0.0</code></td><td>至少给定值的任何SemVer兼容版本。</td></tr>
<tr><td>蒂尔德</td><td><code>~1.2</code></td><td><code>&gt;=1.2.0, &lt;1.3.0</code></td><td>最低版本，兼容范围有限。</td></tr>
<tr><td>通配符</td><td><code>1.*</code></td><td><code>&gt;=1.0.0, &lt;2.0.0</code></td><td>任何版本的<code>*</code>位置</td></tr>
<tr><td>等于</td><td><code>=1.2.3</code></td><td><code>=1.2.3</code></td><td>仅适用于指定的版本。</td></tr>
<tr><td>比较</td><td><code>&gt;1.1</code></td><td><code>&gt;=1.2.0</code></td><td>指定数字的简单数字比较。</td></tr>
<tr><td>复合物</td><td><code>&gt;=1.2, &lt;1.5</code></td><td><code>&gt;1.2.0, &lt;1.5.0</code></td><td>必须同时满足的多个需求。</td></tr>
</tbody></table>
<p>当多个软件包为一个公共软件包指定依赖项时，只要它们在SemVer兼容范围内，解析程序就会尝试确保它们使用该公共软件包的相同版本。它还尝试使用该兼容范围内当前可用的最棒版本。例如，如果解析图中有两个包具有以下要求：</p>
<pre><code class="language-toml"># Package A
[dependencies]
bitflags = &quot;1.0&quot;

# Package B
[dependencies]
bitflags = &quot;1.1&quot;
</code></pre>
<p>如果当时<code>Cargo.lock</code>生成的文件是<code>bitflags</code>是<code>1.2.1</code>，则两个包都将使用<code>1.2.1</code>因为它是兼容范围内最好的。如果<code>2.0.0</code>发布后，仍将使用<code>1.2.1</code>因为<code>2.0.0</code>这被认为是不相容的。</p>
<p>如果多个包与semver不兼容的版本有一个共同的依赖关系，Cargo将允许这样做，但将构建该依赖关系的两个单独副本。例如：</p>
<pre><code class="language-toml"># Package A
[dependencies]
rand = &quot;0.7&quot;

# Package B
[dependencies]
rand = &quot;0.6&quot;
</code></pre>
<p>上述情况将导致A包使用最大的<code>0.7</code>释放(<code>0.7.3</code>在撰写本文时）和包B将使用最大的<code>0.6</code>释放(<code>0.6.5</code>例如）。这可能会导致潜在的问题，请参阅<a href="reference/resolver.zh.html#version-incompatibility-hazards">Version-incompatibility hazards</a>第节了解更多详细信息。</p>
<p>不允许在同一兼容范围内有多个版本，如果在一个兼容范围内约束为两个不同的版本，则会导致冲突解决程序错误。例如，如果解析图中有两个包具有以下要求：</p>
<pre><code class="language-toml"># Package A
[dependencies]
log = &quot;=0.4.11&quot;

# Package B
[dependencies]
log = &quot;=0.4.8&quot;
</code></pre>
<p>上述操作将失败，因为它不允许有两个单独的副本<code>0.4</code>发布<code>log</code>包裹</p>
<h3 id="version-incompatibility-hazards"><a class="header" href="#version-incompatibility-hazards">Version-incompatibility hazards</a></h3>
<p>当一个箱子的多个版本出现在解析图中时，如果使用箱子的箱子暴露了这些箱子中的类型，则可能会导致问题。这是因为Rust编译器认为类型和项是不同的，即使它们具有相同的名称。库在发布SemVer不兼容的版本（例如，发布<code>2.0.0</code>之后<code>1.0.0</code>已投入使用），尤其是对于广泛使用的图书馆。</p>
<p>“<a href="https://github.com/dtolnay/semver-trick">semver trick</a>“是一种解决方法，可以在发布突破性更改的同时保留与旧版本的兼容性。链接页面详细说明问题所在以及解决方法。简而言之，当库想要发布突破性版本时，可以发布新版本，也可以发布上一版本的点版本。”n从新版本重新导出类型。</p>
<p>这些不兼容通常表现为编译时错误，但有时它们只会表现为运行时错误行为。例如，假设有一个名为<code>foo</code>这两个版本最终都会出现<code>1.0.0</code>和<code>2.0.0</code>在解析图中。如果<a href="reference/../../std/any/trait.Any.html#method.downcast_ref"><code>downcast_ref</code></a>在库使用版本创建的对象上使用<code>1.0.0</code>，以及代码调用<code>downcast_ref</code>正在从版本向下转换为类型<code>2.0.0</code>，则downcast将在运行时失败。</p>
<p>如果你有一个库的多个版本，你必须确保你正在正确地使用它们，尤其是如果不同版本的类型有可能一起使用的话。这个<a href="reference/../commands/cargo-tree.html"><code>cargo tree -d</code></a>命令可用于标识重复版本及其来源。同样，如果发布一个不兼容版本的流行库，那么考虑对生态系统的影响是很重要的。</p>
<h3 id="pre-releases"><a class="header" href="#pre-releases">Pre-releases</a></h3>
<p>SemVer有“预发布”的概念，版本中带有破折号，例如<code>1.0.0-alpha</code>或<code>1.0.0-beta</code>.除非明确要求，否则Cargo将避免自动使用预释放。例如，如果<code>1.0.0-alpha</code>包装<code>foo</code>发布后，则需要<code>foo = &quot;1.0&quot;</code>将<em>不</em>匹配，并将返回一个错误。必须指定预发布，例如<code>foo = &quot;1.0.0-alpha&quot;</code>.同样<a href="reference/../commands/cargo-install.html"><code>cargo install</code></a>除非明确要求安装，否则将避免预发布。</p>
<p>Cargo允许自动使用“更新的”预发布。例如，如果<code>1.0.0-beta</code>发布，然后是一个要求<code>foo = &quot;1.0.0-alpha&quot;</code>将允许更新到<code>beta</code>版本请注意，预发布版本可能不稳定，因此在使用它们时应小心。一些项目可能会选择在预发布版本之间发布突破性的更改。如果库不是预发行版，建议不要在库中使用预发行版依赖项。更新您的应用程序时也应小心<code>Cargo.lock</code>，并在发布前更新导致问题时做好准备。</p>
<p>预发布标签可以用句点分隔，以区分不同的组件。数字组件将使用数字比较。例如<code>1.0.0-alpha.4</code>将使用数字比较<code>4</code>组成部分这意味着如果<code>1.0.0-alpha.11</code>这将被选为最伟大的版本。非数字成分按字典顺序进行比较。</p>
<h3 id="version-metadata"><a class="header" href="#version-metadata">Version metadata</a></h3>
<p>SemVer有“版本元数据”的概念，在版本中有一个加号，例如<code>1.0.0+21AF26D3</code>。此元数据通常被忽略，不应在版本要求中使用。绝不应发布仅在元数据标记上不同的多个版本（注意，这是一个<a href="https://github.com/rust-lang/crates.io/issues/1059">known issue</a>具有<a href="https://crates.io/">crates.io</a>这是目前允许的）。</p>
<h2 id="other-constraints"><a class="header" href="#other-constraints">Other constraints</a></h2>
<p>在选择和统一依赖项时，版本需求并不是解析器考虑的唯一约束。以下部分介绍了可能影响分辨率的其他一些约束。</p>
<h3 id="features-1"><a class="header" href="#features-1">Features</a></h3>
<p>为了产生<code>Cargo.lock</code>，解析器构建依赖关系图，就像所有<a href="reference/features.html">features</a>最重要的<a href="reference/workspaces.html">workspace</a>成员已启用。这样可以确保在使用添加或删除功能时，任何可选的依赖项都可用，并与图的其余部分一起正确解析<a href="reference/features.html#command-line-feature-options"><code>--features</code> command-line flag</a>。解析程序将再次运行，以确定在以下情况下使用的实际功能：<em>汇编</em>箱子，基于命令行上选择的特征。</p>
<p>依赖关系是通过对其启用所有功能的联合来解决的。例如，如果一个包依赖于<a href="https://crates.io/crates/im"><code>im</code></a>打包<a href="https://github.com/bodil/im-rs/blob/v15.0.0/Cargo.toml#L46"><code>serde</code>
dependency</a>已启用，另一个包依赖于<a href="https://github.com/bodil/im-rs/blob/v15.0.0/Cargo.toml#L47"><code>rayon</code>
dependency</a>那么启用了吗<code>im</code>将在启用功能和<code>serde</code>和<code>rayon</code>箱子将包含在解析图中。如果没有包依赖于<code>im</code>有了这些特性，这些可选依赖项将被忽略，并且它们不会影响分辨率。</p>
<p>在工作区中构建多个包时（例如<code>--workspace</code>还是多重<code>-p</code>所有这些包的依赖项的特性都是统一的。如果您希望避免不同工作区成员的统一，那么需要通过单独的<code>cargo</code>召唤。</p>
<p>解析器将跳过缺少必需功能的软件包版本。例如，如果包取决于版本<code>^1</code>属于<a href="https://crates.io/crates/regex"><code>regex</code></a>和<a href="https://github.com/rust-lang/regex/blob/1.3.0/Cargo.toml#L56"><code>perf</code> feature</a>，那么它可以选择的最旧版本是<code>1.3.0</code>，因为在此之前的版本不包含<code>perf</code>特色类似地，如果从新版本中删除了某个功能，那么需要该功能的软件包将被粘贴到包含该功能的旧版本中。不鼓励删除SemVer兼容版本中的功能。请注意，可选依赖项也会定义隐式功能，因此删除可选依赖项或使其成为非可选依赖项可能会导致问题，请参阅<a href="reference/semver.html#cargo-remove-opt-dep">removing an
optional dependency</a>.</p>
<h4 id="feature-resolver-version-2-1"><a class="header" href="#feature-resolver-version-2-1">Feature resolver version 2</a></h4>
<p>什么时候<code>resolver = &quot;2&quot;</code>是在<code>Cargo.toml</code>（见<a href="reference/resolver.zh.html#resolver-versions">resolver
versions</a>下面），使用不同的特征分解器，该分解器使用不同的算法来统一特征。版本<code>&quot;1&quot;</code>无论在哪里指定，解析器都将统一软件包的功能。版本<code>&quot;2&quot;</code>在以下情况下，解析器将避免统一功能：</p>
<ul>
<li>
<p>如果当前未生成目标，则不会启用目标特定依赖项的功能。例如：</p>
<pre><code class="language-toml">[dependency.common]
version = &quot;1.0&quot;
features = [&quot;f1&quot;]

[target.'cfg(windows)'.dependencies.common]
version = &quot;1.0&quot;
features = [&quot;f2&quot;]
</code></pre>
<p>在为非Windows平台构建此示例时<code>f2</code>特写会<em>不</em>将被启用。</p>
</li>
<li>
<p>在上启用的功能<a href="reference/specifying-dependencies.html#build-dependencies">build-dependencies</a>或者，当这些依赖项用作普通依赖项时，proc宏将无法统一。例如：</p>
<pre><code class="language-toml">[dependencies]
log = &quot;0.4&quot;

[build-dependencies]
log = {version = &quot;0.4&quot;, features=['std']}
</code></pre>
<p>在构建构建脚本时<code>log</code>箱子将与<code>std</code>特色在构建软件包的库时，它不会启用该功能。</p>
</li>
<li>
<p>在上启用的功能<a href="reference/specifying-dependencies.html#development-dependencies">dev-dependencies</a>当这些依赖项用作普通依赖项时，将不会统一，除非这些开发人员依赖项当前正在生成。例如：</p>
<pre><code class="language-toml">[dependencies]
serde = {version = &quot;1.0&quot;, default-features = false}

[dev-dependencies]
serde = {version = &quot;1.0&quot;, features = [&quot;std&quot;]}
</code></pre>
<p>在本例中，库通常会链接到<code>serde</code>没有<code>std</code>特色然而，当作为测试或示例构建时，它将包括<code>std</code>特色例如<code>cargo test</code>或<code>cargo build --all-targets</code>将统一这些特征。请注意，依赖项中的开发依赖项始终被忽略，这仅与顶级包或工作区成员相关。</p>
</li>
</ul>
<h3 id="links"><a class="header" href="#links"><code>links</code></a></h3>
<p>这个<a href="reference/manifest.html#the-links-field"><code>links</code> field</a>用于确保只有本机库的一个副本链接到二进制文件中。解析程序将尝试找到一个图，其中每个图只有一个实例<code>links</code>名称如果无法找到满足该约束的图形，它将返回一个错误。</p>
<p>例如，如果一个包依赖于<a href="https://crates.io/crates/libgit2-sys"><code>libgit2-sys</code></a>版本<code>0.11</code>另一个取决于<code>0.12</code>，因为Cargo无法统一这些，但它们都与<code>git2</code>本地图书馆。由于这一要求，建议在使SemVer与<code>links</code>字段（如果您的库是常用库）。</p>
<h3 id="yanked-versions"><a class="header" href="#yanked-versions">Yanked versions</a></h3>
<p><a href="reference/publishing.html#cargo-yank">Yanked releases</a>是那些标记为不应使用的。当解析器构建图形时，它将忽略所有被拖动的释放，除非它们已经存在于图形中<code>Cargo.lock</code>文件</p>
<h2 id="dependency-updates"><a class="header" href="#dependency-updates">Dependency updates</a></h2>
<p>依赖关系解析由需要了解依赖关系图的所有Cargo命令自动执行。例如<a href="reference/../commands/cargo-build.html"><code>cargo build</code></a>将运行冲突解决程序以发现要生成的所有依赖项。第一次运行后，结果存储在<code>Cargo.lock</code>文件后续命令将运行解析器，将依赖项锁定到中的版本<code>Cargo.lock</code> <em>如果可以的话</em>.</p>
<p>如果依赖项列表<code>Cargo.toml</code>已修改，例如，将依赖项的版本从<code>1.0</code>到<code>2.0</code>，然后解析器将为该依赖项选择与新需求匹配的新版本。如果新的依赖关系引入了新的需求，那么这些新需求也可能会触发额外的更新。这个<code>Cargo.lock</code>文件将用新结果更新。这个<code>--locked</code>或<code>--frozen</code>标志可用于更改此行为，以防止在需求更改时自动更新，并返回错误。</p>
<p><a href="reference/../commands/cargo-update.html"><code>cargo update</code></a>可用于更新中的条目<code>Cargo.lock</code>当新版本发布时。如果没有任何选项，它将尝试更新锁文件中的所有包。这个<code>-p</code>标志可用于针对特定包的更新，以及其他标志，如<code>--aggressive</code>或<code>--precise</code>可用于控制如何选择版本。</p>
<h2 id="overrides-1"><a class="header" href="#overrides-1">Overrides</a></h2>
<p>Cargo有几种机制来覆盖图中的依赖关系。这个<a href="reference/overriding-dependencies.html">Overriding Dependencies</a>本章详细介绍了如何使用覆盖。覆盖显示为注册表的覆盖，用新条目替换已修补的版本。否则，分辨率将像正常情况一样执行。</p>
<h2 id="dependency-kinds"><a class="header" href="#dependency-kinds">Dependency kinds</a></h2>
<p>包中有三种依赖关系：正常依赖关系，<a href="reference/specifying-dependencies.html#build-dependencies">build</a>和<a href="reference/specifying-dependencies.html#development-dependencies">dev</a>.从解析器的角度来看，大多数情况下，它们都被视为相同的。一个区别是，非工作区成员的开发依赖关系总是被忽略，并且不会影响解决方案。</p>
<p><a href="reference/specifying-dependencies.html#platform-specific-dependencies">Platform-specific dependencies</a>和<code>[target]</code>表被解析为所有平台都已启用。换句话说，解析程序忽略平台或<code>cfg</code>表示</p>
<h3 id="dev-dependency-cycles"><a class="header" href="#dev-dependency-cycles">dev-dependency cycles</a></h3>
<p>通常，解析器不允许循环出现在图中，但它允许循环出现在图中<a href="reference/specifying-dependencies.html#development-dependencies">dev-dependencies</a>例如，项目“foo”对“bar”有一个开发依赖项，而“bar”对“foo”有一个正常依赖项（通常是“路径”依赖项）。这是允许的，因为从构建工件的角度来看，实际上没有一个周期。在本例中，构建“foo”库（不需要“bar”，因为“bar”仅用于测试），然后根据“foo”构建“bar”，然后链接到“bar”构建“foo”测试。</p>
<p>请注意，这可能会导致令人困惑的错误。在构建库单元测试的情况下，实际上有两个库副本链接到最终的测试二进制文件中：一个是用“bar”链接的，另一个是包含单元测试的。与报告中强调的问题类似<a href="reference/resolver.zh.html#version-incompatibility-hazards">Version-incompatibility hazards</a>这两种类型之间不兼容。在这种情况下，从“bar”中暴露“foo”类型时要小心，因为“foo”单元测试不会将它们与本地类型一样对待。</p>
<p>如果可能的话，试着将你的包拆分成多个包，并对其进行重组，使其保持严格的非循环。</p>
<h2 id="resolver-versions"><a class="header" href="#resolver-versions">Resolver versions</a></h2>
<p>通过在中指定分解器版本，可以使用不同的特征分解器算法<code>Cargo.toml</code>这样地：</p>
<pre><code class="language-toml">[package]
name = &quot;my-package&quot;
version = &quot;1.0.0&quot;
resolver = &quot;2&quot;
</code></pre>
<p>版本<code>&quot;1&quot;</code>resolver是在1.50版本之前随货提供的原始resolver。默认值是<code>&quot;2&quot;</code>如果根包指定<a href="reference/manifest.html#the-edition-field"><code>edition = &quot;2021&quot;</code></a>或者更新版本。否则默认为<code>&quot;1&quot;</code>.</p>
<p>版本<code>&quot;2&quot;</code>解析器引入了<a href="reference/resolver.zh.html#features">feature
unification</a>.看<a href="reference/features.html#feature-resolver-version-2">features chapter</a>更多细节。</p>
<p>解析器是影响整个工作空间的全局选项。这个<code>resolver</code>将忽略依赖项中的版本，只使用顶级包中的值。如果使用<a href="reference/workspaces.html#virtual-manifest">virtual workspace</a>，版本应在<code>[workspace]</code>表，例如：</p>
<pre><code class="language-toml">[workspace]
members = [&quot;member1&quot;, &quot;member2&quot;]
resolver = &quot;2&quot;
</code></pre>
<h2 id="recommendations"><a class="header" href="#recommendations">Recommendations</a></h2>
<p>以下是一些关于在包中设置版本以及指定依赖项要求的建议。这些是适用于常见情况的一般指南，但当然，有些情况可能需要指定不寻常的要求。</p>
<ul>
<li>
<p>遵循<a href="reference/semver.html">SemVer guidelines</a>在决定如何更新版本号，以及是否需要进行SemVer不兼容的版本更改时。</p>
</li>
<li>
<p>对依赖项使用插入符号要求，例如<code>&quot;1.2.3&quot;</code>，适用于大多数情况。这确保了解析器在选择版本时能够最大限度地灵活，同时保持构建兼容性。</p>
<ul>
<li>使用当前使用的版本指定所有三个组件。这有助于设置将要使用的最低版本，并确保其他用户不会最终使用旧版本的依赖项，而该依赖项可能会缺少软件包所需的内容。</li>
<li>避免<code>*</code>要求，因为不允许在<a href="https://crates.io/">crates.io</a>，并且他们可以在正常情况下引入一些破坏性的变化<code>cargo update</code>.</li>
<li>避免过于宽泛的版本要求。例如<code>&gt;=2.0.0</code>可以引入任何SemVer不兼容的版本，比如<code>5.0.0</code>，这可能会在将来导致构建中断。</li>
<li>尽可能避免过于狭窄的版本要求。例如，如果指定一个波浪形要求，如<code>bar=&quot;~1.3&quot;</code>，另一个包规定了<code>bar=&quot;1.4&quot;</code>，这将无法解决，即使小版本应该兼容。</li>
</ul>
</li>
<li>
<p>尽量使依赖项版本与库所需的实际最低版本保持最新。例如，如果您需要<code>bar=&quot;1.0.12&quot;</code>，然后在未来的版本中，您将开始使用<code>1.1.0</code>发布“bar”，将您的依赖性要求更新为<code>bar=&quot;1.1.0&quot;</code>.</p>
<p>如果你做不到这一点，它可能不会立即明显，因为Cargo可以机会主义地选择最新版本时，你运行一个毯子<code>cargo update</code>。但是，如果另一个用户依赖于您的库并运行<code>cargo update -p your-library</code>会的<em>不</em>如果“栏”被锁定在其<code>Cargo.lock</code>。只有在依赖项声明也更新的情况下，才会更新“bar”。如果不这样做，可能会导致使用<code>cargo update -p</code>.</p>
</li>
<li>
<p>如果两个包紧密耦合，那么<code>=</code>依赖性要求可能有助于确保它们保持同步。例如，一个带有配套proc宏库的库有时会在两个库之间做出假设，如果这两个库不同步，这些假设将无法很好地工作（而且永远不会单独使用这两个库）。父库可以使用<code>=</code>并重新导出宏以便于访问。</p>
</li>
<li>
<p><code>0.0.x</code>版本可用于永久不稳定的软件包。</p>
</li>
</ul>
<p>一般来说，依赖项要求越严格，解析程序失败的可能性就越大。相反，如果您使用的需求过于宽松，那么发布的新版本可能会破坏构建。</p>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<p>下面说明了您可能遇到的一些问题，以及一些可能的解决方案。</p>
<h3 id="semver-breaking-patch-release-breaks-the-build"><a class="header" href="#semver-breaking-patch-release-breaks-the-build">SemVer-breaking patch release breaks the build</a></h3>
<p>有时，一个项目可能会无意中发布一个带有严重变更的point版本。当用户使用<code>cargo update</code>，他们将选择这个新版本，然后他们的构建可能会中断。在这种情况下，建议项目<a href="reference/publishing.html#cargo-yank">yank</a>发布，并删除SemVer破坏性更改，或将其发布为新的SemVer主要版本。</p>
<p>如果变更发生在第三方项目中，如果可能，尝试（礼貌地！）与项目合作解决问题。</p>
<p>在等待释放的过程中，一些变通方法取决于具体情况：</p>
<ul>
<li>如果您的项目是最终产品（例如二进制可执行文件），请避免在中更新有问题的包<code>Cargo.lock</code>.这可以通过<code>--precise</code>加入<a href="reference/../commands/cargo-update.html"><code>cargo update</code></a>.</li>
<li>如果你发布一个二进制文件<a href="https://crates.io/">crates.io</a>，则可以临时添加<code>=</code>强制依赖于特定良好版本的要求。
<ul>
<li>二进制项目也可以推荐用户使用<code>--locked</code>选项<a href="reference/../commands/cargo-install.html"><code>cargo install</code></a>使用原版<code>Cargo.lock</code>包含已知的好版本。</li>
</ul>
</li>
<li>库还可以考虑发布一个临时的新版本，其具有更严格的要求，避免了麻烦的依赖性。您可能需要考虑使用范围要求（而不是<code>=</code>)避免与使用相同依赖项的其他包发生冲突的过于严格的要求。问题解决后，您可以发布另一个point release，将依赖关系放松为插入符号需求。</li>
<li>如果第三方项目看起来无法或不愿意删除该版本，那么一个选项是更新代码以与更改兼容，并更新依赖项要求以将最低版本设置为新版本。您还需要考虑这是否是一个违反您自己的库的更改程序，例如，如果它从依赖关系中公开类型。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="semver-compatibility-2"><a class="header" href="#semver-compatibility-2">SemVer Compatibility</a></h1>
<p>本章详细介绍了对于新版本的软件包，通常认为什么是兼容的或破坏性的SemVer更改。看到了吗<a href="reference/resolver.html#semver-compatibility">SemVer compatibility</a>本节详细介绍了什么是SemVer，以及Cargo如何使用它来确保库的兼容性。</p>
<p>这些只是<em>指导方针</em>，而不是所有项目都必须遵守的硬性规定。这个<a href="reference/semver.zh.html#change-categories">Change categories</a>第节详细介绍了本指南如何对变更的级别和严重性进行分类。本指南的大部分内容侧重于将导致<code>cargo</code>和<code>rustc</code>未能建造出以前有用的东西。几乎每一个变更都会带来一些风险，即它会对运行时行为产生负面影响，在这些情况下，项目维护人员通常会判断它是否是一个SemVer不兼容的变更。</p>
<p>另见<a href="https://github.com/rust-dev-tools/rust-semverver">rust-semverver</a>，这是一个尝试以编程方式检查兼容性规则的实验工具。</p>
<h2 id="change-categories"><a class="header" href="#change-categories">Change categories</a></h2>
<p>以下列出的所有政策均按变化程度分类：</p>
<ul>
<li><strong>重大变化</strong>：需要进行大幅度碰撞的更改。</li>
<li><strong>小变化</strong>：只需要轻微碰撞的更改。</li>
<li><strong>可能是零钱</strong>一些项目可能会考虑重大变化，而其他项目则考虑较小。</li>
</ul>
<p>“可能突破”类别包括具有以下特征的更改：<em>潜在的</em>在更新过程中中断，但不一定会导致中断。应仔细考虑这些变化的影响。具体性质将取决于变更和项目维护人员的原则。</p>
<p>一些项目可能会选择只在一个小的更改上增加补丁号。建议遵循SemVer规范，并且只在补丁版本中应用错误修复。然而，一个bug修复可能需要一个标记为“微小更改”的API更改，并且不应该影响兼容性。本指南没有对如何对待每个“微小变化”采取立场，因为微小变化和补丁变化之间的区别是取决于变化性质的惯例。</p>
<p>有些更改被标记为“微小”，尽管它们有破坏构建的潜在风险。这适用于可能性极低的情况，并且潜在的破坏性代码不太可能用惯用语言编写，或者特别不鼓励使用。</p>
<p>本指南使用术语“主要”和“次要”，假设这与“1.0.0”或更高版本有关。以“0.y.z”开头的初始开发版本可以将“y”中的更改视为主要版本，“z”中的更改视为次要版本。“0.0.z”版本总是主要的变化。这是因为Cargo使用的约定是，只有最左边的非零组件中的更改才被视为不兼容。</p>
<ul>
<li>API兼容性
<ul>
<li>项目
<ul>
<li><a href="reference/semver.zh.html#item-remove">Major: renaming/moving/removing any public items</a></li>
<li><a href="reference/semver.zh.html#item-new">Minor: adding new public items</a></li>
</ul>
</li>
<li>结构体
<ul>
<li><a href="reference/semver.zh.html#struct-add-private-field-when-public">Major: adding a private struct field when all current fields are public</a></li>
<li><a href="reference/semver.zh.html#struct-add-public-field-when-no-private">Major: adding a public field when no private field exists</a></li>
<li><a href="reference/semver.zh.html#struct-private-fields-with-private">Minor: adding or removing private fields when at least one already exists</a></li>
<li><a href="reference/semver.zh.html#struct-tuple-normal-with-private">Minor: going from a tuple struct with all private fields (with at least one field) to a normal struct, or vice versa</a></li>
</ul>
</li>
<li>枚举类型
<ul>
<li><a href="reference/semver.zh.html#enum-variant-new">Major: adding new enum variants (without <code>non_exhaustive</code>)</a></li>
<li><a href="reference/semver.zh.html#enum-fields-new">Major: adding new fields to an enum variant</a></li>
</ul>
</li>
<li>特点
<ul>
<li><a href="reference/semver.zh.html#trait-new-item-no-default">Major: adding a non-defaulted trait item</a></li>
<li><a href="reference/semver.zh.html#trait-item-signature">Major: any change to trait item signatures</a></li>
<li><a href="reference/semver.zh.html#trait-new-default-item">Possibly-breaking: adding a defaulted trait item</a></li>
<li><a href="reference/semver.zh.html#trait-object-safety">Major: adding a trait item that makes the trait non-object safe</a></li>
<li><a href="reference/semver.zh.html#trait-new-parameter-no-default">Major: adding a type parameter without a default</a></li>
<li><a href="reference/semver.zh.html#trait-new-parameter-default">Minor: adding a defaulted trait type parameter</a></li>
</ul>
</li>
<li>启动位置
<ul>
<li><a href="reference/semver.zh.html#impl-item-new">Possibly-breaking change: adding any inherent items</a></li>
</ul>
</li>
<li>仿制药
<ul>
<li><a href="reference/semver.zh.html#generic-bounds-tighten">Major: tightening generic bounds</a></li>
<li><a href="reference/semver.zh.html#generic-bounds-loosen">Minor: loosening generic bounds</a></li>
<li><a href="reference/semver.zh.html#generic-new-default">Minor: adding defaulted type parameters</a></li>
<li><a href="reference/semver.zh.html#generic-generalize-identical">Minor: generalizing a type to use generics (with identical types)</a></li>
<li><a href="reference/semver.zh.html#generic-generalize-different">Major: generalizing a type to use generics (with possibly different types)</a></li>
<li><a href="reference/semver.zh.html#generic-more-generic">Minor: changing a generic type to a more generic type</a></li>
</ul>
</li>
<li>功能
<ul>
<li><a href="reference/semver.zh.html#fn-change-arity">Major: adding/removing function parameters</a></li>
<li><a href="reference/semver.zh.html#fn-generic-new">Possibly-breaking: introducing a new function type parameter</a></li>
<li><a href="reference/semver.zh.html#fn-generalize-compatible">Minor: generalizing a function to use generics (supporting original type)</a></li>
<li><a href="reference/semver.zh.html#fn-generalize-mismatch">Major: generalizing a function to use generics with type mismatch</a></li>
</ul>
</li>
<li>属性
<ul>
<li><a href="reference/semver.zh.html#attr-no-std-to-std">Major: switching from <code>no_std</code> support to requiring <code>std</code></a></li>
</ul>
</li>
</ul>
</li>
<li>工具和环境兼容性
<ul>
<li><a href="reference/semver.zh.html#env-new-rust">Possibly-breaking: changing the minimum version of Rust required</a></li>
<li><a href="reference/semver.zh.html#env-change-requirements">Possibly-breaking: changing the platform and environment requirements</a></li>
<li>Cargo
<ul>
<li><a href="reference/semver.zh.html#cargo-feature-add">Minor: adding a new Cargo feature</a></li>
<li><a href="reference/semver.zh.html#cargo-feature-remove">Major: removing a Cargo feature</a></li>
<li><a href="reference/semver.zh.html#cargo-feature-remove-another">Major: removing a feature from a feature list if that changes functionality or public items</a></li>
<li><a href="reference/semver.zh.html#cargo-remove-opt-dep">Possibly-breaking: removing an optional dependency</a></li>
<li><a href="reference/semver.zh.html#cargo-change-dep-feature">Minor: changing dependency features</a></li>
<li><a href="reference/semver.zh.html#cargo-dep-add">Minor: adding dependencies</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="reference/semver.zh.html#application-compatibility">Application compatibility</a></li>
</ul>
<h2 id="api-compatibility"><a class="header" href="#api-compatibility">API compatibility</a></h2>
<p>下面的所有示例都包含三个部分：原始代码、修改后的代码，以及可能出现在另一个项目中的代码用法示例。在一个小的改变中，示例用法应该成功地使用之前和之后的版本构建。</p>
<p><a id="item-remove"></a></p>
<h3 id="major-renamingmovingremoving-any-public-items"><a class="header" href="#major-renamingmovingremoving-any-public-items">Major: renaming/moving/removing any public items</a></h3>
<p>没有公开曝光的<a href="reference/../../reference/items.html">item</a>将导致该项的任何使用无法编译。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub fn foo() {}

///////////////////////////////////////////////////////////
// After
// ... item has been removed

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    updated_crate::foo(); // Error: cannot find function `foo`
}
</code></pre>
<p>这包括添加任何类型的<a href="reference/../../reference/conditional-compilation.html#the-cfg-attribute"><code>cfg</code> attribute</a>它可以根据以下内容更改可用的项目或行为：<a href="reference/../../reference/conditional-compilation.html">conditional compilation</a>.</p>
<p>缓解策略：</p>
<ul>
<li>将要删除的项目标记为<a href="reference/../../reference/attributes/diagnostics.html#the-deprecated-attribute">deprecated</a>，然后在以后的版本中删除它们。</li>
<li>将重命名的项目标记为<a href="reference/../../reference/attributes/diagnostics.html#the-deprecated-attribute">deprecated</a>，并使用<a href="reference/../../reference/items/use-declarations.html"><code>pub use</code></a>要重新导出为旧名称的项。</li>
</ul>
<p><a id="item-new"></a></p>
<h3 id="minor-adding-new-public-items"><a class="header" href="#minor-adding-new-public-items">Minor: adding new public items</a></h3>
<p>添加新的、公开的<a href="reference/../../reference/items.html">items</a>这是一个小变化。</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
// ... absence of item

///////////////////////////////////////////////////////////
// After
pub fn foo() {}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
// `foo` is not used since it didn't previously exist.
</code></pre>
<p>请注意，在某些罕见的情况下，这可能是一个错误<strong>零钱</strong>由于全球进口。例如，如果您添加了一个新特性，而一个项目使用了一个全局导入，将该特性引入范围，并且新特性引入了一个关联项，该项与它所实现的任何类型都冲突，这可能会由于不明确而导致编译时错误。例子：</p>
<pre><code class="language-rust ignore">// Breaking change example

///////////////////////////////////////////////////////////
// Before
// ... absence of trait

///////////////////////////////////////////////////////////
// After
pub trait NewTrait {
    fn foo(&amp;self) {}
}

impl NewTrait for i32 {}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::*;

pub trait LocalTrait {
    fn foo(&amp;self) {}
}

impl LocalTrait for i32 {}

fn main() {
    123i32.foo(); // Error:  multiple applicable items in scope
}
</code></pre>
<p>这不被认为是一个重大变化，因为传统上，glob进口是一个已知的兼容性风险。Glob应避免从外部箱子进口物品。</p>
<p><a id="struct-add-private-field-when-public"></a></p>
<h3 id="major-adding-a-private-struct-field-when-all-current-fields-are-public"><a class="header" href="#major-adding-a-private-struct-field-when-all-current-fields-are-public">Major: adding a private struct field when all current fields are public</a></h3>
<p>当一个私有字段被添加到一个以前拥有所有公共字段的结构中时，这将破坏任何试图用<a href="reference/../../reference/expressions/struct-expr.html">struct literal</a>.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo {
    pub f1: i32,
}

///////////////////////////////////////////////////////////
// After
pub struct Foo {
    pub f1: i32,
    f2: i32,
}

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    let x = updated_crate::Foo { f1: 123 }; // Error: cannot construct `Foo`
}
</code></pre>
<p>缓解策略：</p>
<ul>
<li>不要向所有公共字段结构添加新字段。</li>
<li>将结构标记为<a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a>当第一次引入struct以防止用户使用struct literal语法时，而是提供构造函数方法和/或<a href="reference/../../std/default/trait.Default.html">Default</a>实施</li>
</ul>
<p><a id="struct-add-public-field-when-no-private"></a></p>
<h3 id="major-adding-a-public-field-when-no-private-field-exists"><a class="header" href="#major-adding-a-public-field-when-no-private-field-exists">Major: adding a public field when no private field exists</a></h3>
<p>当一个公共字段被添加到一个包含所有公共字段的结构中时，这将破坏任何试图用公共字段构造它的代码<a href="reference/../../reference/expressions/struct-expr.html">struct literal</a>.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo {
    pub f1: i32,
}

///////////////////////////////////////////////////////////
// After
pub struct Foo {
    pub f1: i32,
    pub f2: i32,
}

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    let x = updated_crate::Foo { f1: 123 }; // Error: missing field `f2`
}
</code></pre>
<p>缓解策略：</p>
<ul>
<li>不要向所有公共字段结构添加新字段。</li>
<li>将结构标记为<a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a>当第一次引入struct以防止用户使用struct literal语法时，而是提供构造函数方法和/或<a href="reference/../../std/default/trait.Default.html">Default</a>实施</li>
</ul>
<p><a id="struct-private-fields-with-private"></a></p>
<h3 id="minor-adding-or-removing-private-fields-when-at-least-one-already-exists"><a class="header" href="#minor-adding-or-removing-private-fields-when-at-least-one-already-exists">Minor: adding or removing private fields when at least one already exists</a></h3>
<p>当结构已经至少有一个私有字段时，可以安全地从结构中添加或删除私有字段。</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[derive(Default)]
pub struct Foo {
    f1: i32,
}

///////////////////////////////////////////////////////////
// After
#[derive(Default)]
pub struct Foo {
    f2: f64,
}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
fn main() {
    // Cannot access private fields.
    let x = updated_crate::Foo::default();
}
</code></pre>
<p>这是安全的，因为现有代码不能使用<a href="reference/../../reference/expressions/struct-expr.html">struct literal</a>去构建它，也不完全匹配它的内容。</p>
<p>请注意，对于元组结构，这是一个<strong>重大变化</strong>如果元组包含公共字段，并且添加或删除私有字段会更改任何公共字段的索引。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[derive(Default)]
pub struct Foo(pub i32, i32);

///////////////////////////////////////////////////////////
// After
#[derive(Default)]
pub struct Foo(f64, pub i32, i32);

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    let x = updated_crate::Foo::default();
    let y = x.0; // Error: is private
}
</code></pre>
<p><a id="struct-tuple-normal-with-private"></a></p>
<h3 id="minor-going-from-a-tuple-struct-with-all-private-fields-with-at-least-one-field-to-a-normal-struct-or-vice-versa"><a class="header" href="#minor-going-from-a-tuple-struct-with-all-private-fields-with-at-least-one-field-to-a-normal-struct-or-vice-versa">Minor: going from a tuple struct with all private fields (with at least one field) to a normal struct, or vice versa</a></h3>
<p>如果所有字段都是私有的，那么将元组结构更改为普通结构（反之亦然）是安全的。</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[derive(Default)]
pub struct Foo(i32);

///////////////////////////////////////////////////////////
// After
#[derive(Default)]
pub struct Foo {
    f1: i32,
}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
fn main() {
    // Cannot access private fields.
    let x = updated_crate::Foo::default();
}
</code></pre>
<p>这是安全的，因为现有代码不能使用<a href="reference/../../reference/expressions/struct-expr.html">struct literal</a>构建它，也不匹配它的内容。</p>
<p><a id="enum-variant-new"></a></p>
<h3 id="major-adding-new-enum-variants-without-non_exhaustive"><a class="header" href="#major-adding-new-enum-variants-without-non_exhaustive">Major: adding new enum variants (without <code>non_exhaustive</code>)</a></h3>
<p>如果枚举不使用<a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a>属性</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub enum E {
    Variant1,
}

///////////////////////////////////////////////////////////
// After
pub enum E {
    Variant1,
    Variant2,
}

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    use updated_crate::E;
    let x = E::Variant1;
    match x { // Error: `Variant2` not covered
        E::Variant1 =&gt; {}
    }
}
</code></pre>
<p>缓解策略：</p>
<ul>
<li>引入枚举时，将其标记为<a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a>强制用户使用<a href="reference/../../reference/patterns.html#wildcard-pattern">wildcard patterns</a>捕捉新的变种。</li>
</ul>
<p><a id="enum-fields-new"></a></p>
<h3 id="major-adding-new-fields-to-an-enum-variant"><a class="header" href="#major-adding-new-fields-to-an-enum-variant">Major: adding new fields to an enum variant</a></h3>
<p>向枚举变量添加新字段是一个突破性的改变，因为所有字段都是公共的，构造函数和匹配项将无法编译。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub enum E {
    Variant1 { f1: i32 },
}

///////////////////////////////////////////////////////////
// After
pub enum E {
    Variant1 { f1: i32, f2: i32 },
}

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    use updated_crate::E;
    let x = E::Variant1 { f1: 1 }; // Error: missing f2
    match x {
        E::Variant1 { f1 } =&gt; {} // Error: missing f2
    }
}
</code></pre>
<p>缓解策略：</p>
<ul>
<li>引入枚举时，将变量标记为<a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>non_exhaustive</code></a>因此，如果没有通配符，就无法构造或匹配它。
<pre><code class="language-rust ignore skip">pub enum E {
    #[non_exhaustive]
    Variant1{f1: i32}
}
</code></pre>
</li>
<li>引入枚举时，使用显式结构作为值，这样可以控制字段的可见性。
<pre><code class="language-rust ignore skip">pub struct Foo {
   f1: i32,
   f2: i32,
}
pub enum E {
    Variant1(Foo)
}
</code></pre>
</li>
</ul>
<p><a id="trait-new-item-no-default"></a></p>
<h3 id="major-adding-a-non-defaulted-trait-item"><a class="header" href="#major-adding-a-non-defaulted-trait-item">Major: adding a non-defaulted trait item</a></h3>
<p>将非默认项添加到特征中是一个突破性的改变。这将打破这种特性的任何实现者。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}

///////////////////////////////////////////////////////////
// After
pub trait Trait {
    fn foo(&amp;self);
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}  // Error: not all trait items implemented
</code></pre>
<p>缓解策略：</p>
<ul>
<li>始终为新关联的特征项提供默认实现或值。</li>
<li>在介绍这种特质时，使用<a href="https://rust-lang.github.io/api-guidelines/future-proofing.html#sealed-traits-protect-against-downstream-implementations-c-sealed">sealed trait</a>防止箱子外的用户实现该特性的技术。</li>
</ul>
<p><a id="trait-item-signature"></a></p>
<h3 id="major-any-change-to-trait-item-signatures"><a class="header" href="#major-any-change-to-trait-item-signatures">Major: any change to trait item signatures</a></h3>
<p>对特征项签名进行任何更改都是一个突破性的改变。这可能会打破这种特质的外部实现者。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {
    fn f(&amp;self, x: i32) {}
}

///////////////////////////////////////////////////////////
// After
pub trait Trait {
    // For sealed traits or normal functions, this would be a minor change
    // because generalizing with generics strictly expands the possible uses.
    // But in this case, trait implementations must use the same signature.
    fn f&lt;V&gt;(&amp;self, x: V) {}
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {
    fn f(&amp;self, x: i32) {}  // Error: trait declaration has 1 type parameter
}
</code></pre>
<p>缓解策略：</p>
<ul>
<li>引入带有默认实现的新项，以覆盖新功能，而不是修改现有项。</li>
<li>在介绍这种特质时，使用<a href="https://rust-lang.github.io/api-guidelines/future-proofing.html#sealed-traits-protect-against-downstream-implementations-c-sealed">sealed trait</a>防止箱子外的用户实现该特性的技术。</li>
</ul>
<p><a id="trait-new-default-item"></a></p>
<h3 id="possibly-breaking-adding-a-defaulted-trait-item"><a class="header" href="#possibly-breaking-adding-a-defaulted-trait-item">Possibly-breaking: adding a defaulted trait item</a></h3>
<p>添加默认特征项通常是安全的。然而，这有时会导致编译错误。例如，如果另一个特征中存在同名的方法，这可能会导致歧义。</p>
<pre><code class="language-rust ignore">// Breaking change example

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}

///////////////////////////////////////////////////////////
// After
pub trait Trait {
    fn foo(&amp;self) {}
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Trait;
struct Foo;

trait LocalTrait {
    fn foo(&amp;self) {}
}

impl Trait for Foo {}
impl LocalTrait for Foo {}

fn main() {
    let x = Foo;
    x.foo(); // Error: multiple applicable items in scope
}
</code></pre>
<p>请注意，这种模糊性确实存在<em>不</em>存在的名称冲突<a href="reference/../../reference/items/implementations.html#inherent-implementations">inherent
implementations</a>，因为他们优先于特质项目。</p>
<p>查看<a href="reference/semver.zh.html#trait-object-safety">trait-object-safety</a>在添加特性项时要考虑的特殊情况。</p>
<p>缓解策略：</p>
<ul>
<li>一些项目可能会认为这种破损是可以接受的，尤其是如果新项目名称不太可能与任何现有代码冲突的话。仔细选择名称以避免这些冲突。此外，要求下游用户添加<a href="reference/../../reference/expressions/call-expr.html#disambiguating-function-calls">disambiguation syntax</a>更新依赖项时选择正确的函数。</li>
</ul>
<p><a id="trait-object-safety"></a></p>
<h3 id="major-adding-a-trait-item-that-makes-the-trait-non-object-safe"><a class="header" href="#major-adding-a-trait-item-that-makes-the-trait-non-object-safe">Major: adding a trait item that makes the trait non-object safe</a></h3>
<p>这是一个突破性的改变，添加一个特性项，改变特性为不存在<a href="reference/../../reference/items/traits.html#object-safety">object safe</a>.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}

///////////////////////////////////////////////////////////
// After
pub trait Trait {
    // An associated const makes the trait not object-safe.
    const CONST: i32 = 123;
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}

fn main() {
    let obj: Box&lt;dyn Trait&gt; = Box::new(Foo); // Error: cannot be made into an object
}
</code></pre>
<p>反过来做是安全的（把一个非对象安全的特征变成一个安全的特征）。</p>
<p><a id="trait-new-parameter-no-default"></a></p>
<h3 id="major-adding-a-type-parameter-without-a-default"><a class="header" href="#major-adding-a-type-parameter-without-a-default">Major: adding a type parameter without a default</a></h3>
<p>在没有默认特性的情况下添加类型参数是一个突破性的改变。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}

///////////////////////////////////////////////////////////
// After
pub trait Trait&lt;T&gt; {}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}  // Error: missing generics
</code></pre>
<p>缓解策略：</p>
<ul>
<li>查看<a href="reference/semver.zh.html#trait-new-parameter-default">adding a defaulted trait type parameter</a>.</li>
</ul>
<p><a id="trait-new-parameter-default"></a></p>
<h3 id="minor-adding-a-defaulted-trait-type-parameter"><a class="header" href="#minor-adding-a-defaulted-trait-type-parameter">Minor: adding a defaulted trait type parameter</a></h3>
<p>向trait添加类型参数是安全的，只要它有默认值。外部实现者将使用默认值，而无需指定参数。</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}

///////////////////////////////////////////////////////////
// After
pub trait Trait&lt;T = i32&gt; {}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}
</code></pre>
<p><a id="impl-item-new"></a></p>
<h3 id="possibly-breaking-change-adding-any-inherent-items"><a class="header" href="#possibly-breaking-change-adding-any-inherent-items">Possibly-breaking change: adding any inherent items</a></h3>
<p>通常，向实现中添加固有项应该是安全的，因为固有项优先于特性项。然而，在某些情况下，如果名称与具有不同签名的实现特征项相同，冲突可能会导致问题。</p>
<pre><code class="language-rust ignore">// Breaking change example

///////////////////////////////////////////////////////////
// Before
pub struct Foo;

///////////////////////////////////////////////////////////
// After
pub struct Foo;

impl Foo {
    pub fn foo(&amp;self) {}
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Foo;

trait Trait {
    fn foo(&amp;self, x: i32) {}
}

impl Trait for Foo {}

fn main() {
    let x = Foo;
    x.foo(1); // Error: this function takes 0 arguments
}
</code></pre>
<p>请注意，如果签名匹配，则不会出现编译时错误，但运行时行为可能会发生无声更改（因为它现在正在执行不同的函数）。</p>
<p>缓解策略：</p>
<ul>
<li>一些项目可能会认为这种破损是可以接受的，尤其是如果新项目名称不太可能与任何现有代码冲突的话。仔细选择名称以避免这些冲突。此外，要求下游用户添加<a href="reference/../../reference/expressions/call-expr.html#disambiguating-function-calls">disambiguation syntax</a>更新依赖项时选择正确的函数。</li>
</ul>
<p><a id="generic-bounds-tighten"></a></p>
<h3 id="major-tightening-generic-bounds"><a class="header" href="#major-tightening-generic-bounds">Major: tightening generic bounds</a></h3>
<p>收紧类型的泛型界限是一个突破性的改变，因为这会打破用户对宽松界限的期望。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo&lt;A&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// After
pub struct Foo&lt;A: Eq&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Foo;

fn main() {
    let s = Foo { f1: 1.23 }; // Error: the trait bound `{float}: Eq` is not satisfied
}
</code></pre>
<p><a id="generic-bounds-loosen"></a></p>
<h3 id="minor-loosening-generic-bounds"><a class="header" href="#minor-loosening-generic-bounds">Minor: loosening generic bounds</a></h3>
<p>放松类型的泛型界限是安全的，因为它只扩展了允许的范围。</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo&lt;A: Clone&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// After
pub struct Foo&lt;A&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::Foo;

fn main() {
    let s = Foo { f1: 123 };
}
</code></pre>
<p><a id="generic-new-default"></a></p>
<h3 id="minor-adding-defaulted-type-parameters"><a class="header" href="#minor-adding-defaulted-type-parameters">Minor: adding defaulted type parameters</a></h3>
<p>向类型添加类型参数是安全的，只要它有默认值。所有现有引用都将使用默认值，而无需指定参数。</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[derive(Default)]
pub struct Foo {}

///////////////////////////////////////////////////////////
// After
#[derive(Default)]
pub struct Foo&lt;A = i32&gt; {
    f1: A,
}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::Foo;

fn main() {
    let s: Foo = Default::default();
}
</code></pre>
<p><a id="generic-generalize-identical"></a></p>
<h3 id="minor-generalizing-a-type-to-use-generics-with-identical-types"><a class="header" href="#minor-generalizing-a-type-to-use-generics-with-identical-types">Minor: generalizing a type to use generics (with identical types)</a></h3>
<p>结构或枚举字段可以从具体类型更改为泛型类型参数，前提是更改会导致所有现有用例的类型相同。例如，允许进行以下更改：</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo(pub u8);

///////////////////////////////////////////////////////////
// After
pub struct Foo&lt;T = u8&gt;(pub T);

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::Foo;

fn main() {
    let s: Foo = Foo(123);
}
</code></pre>
<p>因为现有的<code>Foo</code>是的缩写<code>Foo&lt;u8&gt;</code>这会产生相同的字段类型。</p>
<p><a id="generic-generalize-different"></a></p>
<h3 id="major-generalizing-a-type-to-use-generics-with-possibly-different-types"><a class="header" href="#major-generalizing-a-type-to-use-generics-with-possibly-different-types">Major: generalizing a type to use generics (with possibly different types)</a></h3>
<p>如果类型可以更改，将结构或枚举字段从具体类型更改为泛型类型参数可能会中断。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo&lt;T = u8&gt;(pub T, pub u8);

///////////////////////////////////////////////////////////
// After
pub struct Foo&lt;T = u8&gt;(pub T, pub T);

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Foo;

fn main() {
    let s: Foo&lt;f32&gt; = Foo(3.14, 123); // Error: mismatched types
}
</code></pre>
<p><a id="generic-more-generic"></a></p>
<h3 id="minor-changing-a-generic-type-to-a-more-generic-type"><a class="header" href="#minor-changing-a-generic-type-to-a-more-generic-type">Minor: changing a generic type to a more generic type</a></h3>
<p>将泛型类型更改为更通用的类型是安全的。例如，下面添加了一个默认为原始类型的泛型参数，这是安全的，因为所有现有用户将对这两个字段使用相同的类型，不需要指定默认参数。</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo&lt;T&gt;(pub T, pub T);

///////////////////////////////////////////////////////////
// After
pub struct Foo&lt;T, U = T&gt;(pub T, pub U);

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::Foo;

fn main() {
    let s: Foo&lt;f32&gt; = Foo(1.0, 2.0);
}
</code></pre>
<p><a id="fn-change-arity"></a></p>
<h3 id="major-addingremoving-function-parameters"><a class="header" href="#major-addingremoving-function-parameters">Major: adding/removing function parameters</a></h3>
<p>改变函数的算术性是一个突破性的改变。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub fn foo() {}

///////////////////////////////////////////////////////////
// After
pub fn foo(x: i32) {}

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    updated_crate::foo(); // Error: this function takes 1 argument
}
</code></pre>
<p>缓解策略：</p>
<ul>
<li>引入具有新签名的新函数，并可能<a href="reference/../../reference/attributes/diagnostics.html#the-deprecated-attribute">deprecate</a>老的那个。</li>
<li>介绍采用struct参数的函数，其中struct是使用builder模式构建的。这允许将来将新字段添加到结构中。</li>
</ul>
<p><a id="fn-generic-new"></a></p>
<h3 id="possibly-breaking-introducing-a-new-function-type-parameter"><a class="header" href="#possibly-breaking-introducing-a-new-function-type-parameter">Possibly-breaking: introducing a new function type parameter</a></h3>
<p>通常，添加非默认类型参数是安全的，但在某些情况下，这可能是一个突破性的更改：</p>
<pre><code class="language-rust ignore">// Breaking change example

///////////////////////////////////////////////////////////
// Before
pub fn foo&lt;T&gt;() {}

///////////////////////////////////////////////////////////
// After
pub fn foo&lt;T, U&gt;() {}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::foo;

fn main() {
    foo::&lt;u8&gt;(); // Error: this function takes 2 generic arguments but 1 generic argument was supplied
}
</code></pre>
<p>然而，这种显式调用非常罕见（通常可以用其他方式编写），因此这种中断通常是可以接受的。我们应该考虑使用显式类型参数调用相关函数的可能性。</p>
<p><a id="fn-generalize-compatible"></a></p>
<h3 id="minor-generalizing-a-function-to-use-generics-supporting-original-type"><a class="header" href="#minor-generalizing-a-function-to-use-generics-supporting-original-type">Minor: generalizing a function to use generics (supporting original type)</a></h3>
<p>函数的参数类型或其返回值可以是<em>广义的</em>使用泛型，包括引入新的类型参数，只要可以将其实例化为原始类型。例如，允许进行以下更改：</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub fn foo(x: u8) -&gt; u8 {
    x
}
pub fn bar&lt;T: Iterator&lt;Item = u8&gt;&gt;(t: T) {}

///////////////////////////////////////////////////////////
// After
use std::ops::Add;
pub fn foo&lt;T: Add&gt;(x: T) -&gt; T {
    x
}
pub fn bar&lt;T: IntoIterator&lt;Item = u8&gt;&gt;(t: T) {}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::{bar, foo};

fn main() {
    foo(1);
    bar(vec![1, 2, 3].into_iter());
}
</code></pre>
<p>因为所有现有的使用都是新签名的实例。</p>
<p>也许有些令人惊讶的是，鉴于每个特征都实现了自身，一般化也适用于特征对象：</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}
pub fn foo(t: &amp;dyn Trait) {}

///////////////////////////////////////////////////////////
// After
pub trait Trait {}
pub fn foo&lt;T: Trait + ?Sized&gt;(t: &amp;T) {}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::{foo, Trait};

struct Foo;
impl Trait for Foo {}

fn main() {
    let obj = Foo;
    foo(&amp;obj);
}
</code></pre>
<p>（使用<code>?Sized</code>是必要的；否则您无法恢复原始签名。）</p>
<p>以这种方式引入泛型可能会导致类型推断失败。这通常很少见，对于某些项目来说可能是可以接受的，因为这可以通过附加类型注释来修复。</p>
<pre><code class="language-rust ignore">// Breaking change example

///////////////////////////////////////////////////////////
// Before
pub fn foo() -&gt; i32 {
    0
}

///////////////////////////////////////////////////////////
// After
pub fn foo&lt;T: Default&gt;() -&gt; T {
    Default::default()
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::foo;

fn main() {
    let x = foo(); // Error: type annotations needed
}
</code></pre>
<p><a id="fn-generalize-mismatch"></a></p>
<h3 id="major-generalizing-a-function-to-use-generics-with-type-mismatch"><a class="header" href="#major-generalizing-a-function-to-use-generics-with-type-mismatch">Major: generalizing a function to use generics with type mismatch</a></h3>
<p>如果泛型类型限制或更改了以前允许的类型，则更改函数参数或返回类型是一种突破性的更改。例如，以下内容添加了现有代码可能无法满足的通用约束：</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub fn foo(x: Vec&lt;u8&gt;) {}

///////////////////////////////////////////////////////////
// After
pub fn foo&lt;T: Copy + IntoIterator&lt;Item = u8&gt;&gt;(x: T) {}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::foo;

fn main() {
    foo(vec![1, 2, 3]); // Error: `Copy` is not implemented for `Vec&lt;u8&gt;`
}
</code></pre>
<p><a id="attr-no-std-to-std"></a></p>
<h3 id="major-switching-from-no_std-support-to-requiring-std"><a class="header" href="#major-switching-from-no_std-support-to-requiring-std">Major: switching from <code>no_std</code> support to requiring <code>std</code></a></h3>
<p>如果您的库特别支持<a href="reference/../../reference/names/preludes.html#the-no_std-attribute"><code>no_std</code></a>环境，这是一个突破性的变化，使新的版本需要<code>std</code>.</p>
<pre><code class="language-rust ignore skip">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
#![no_std]
pub fn foo() {}

///////////////////////////////////////////////////////////
// After
pub fn foo() {
    std::time::SystemTime::now();
}

///////////////////////////////////////////////////////////
// Example usage that will break.
// This will fail to link for no_std targets because they don't have a `std` crate.
#![no_std]
use updated_crate::foo;

fn example() {
    foo();
}
</code></pre>
<p>缓解策略：</p>
<ul>
<li>避免这种情况的一个常见习惯用法是包含<code>std</code> <a href="reference/features.html">Cargo feature</a>这可以选择性地启用<code>std</code>支持，当该功能关闭时，该库可以在<code>no_std</code>环境</li>
</ul>
<h2 id="tooling-and-environment-compatibility"><a class="header" href="#tooling-and-environment-compatibility">Tooling and environment compatibility</a></h2>
<p><a id="env-new-rust"></a></p>
<h3 id="possibly-breaking-changing-the-minimum-version-of-rust-required"><a class="header" href="#possibly-breaking-changing-the-minimum-version-of-rust-required">Possibly-breaking: changing the minimum version of Rust required</a></h3>
<p>在新版本的Rust中引入新功能可以打破使用旧版本Rust的项目。这还包括在新发布的Cargo中使用新功能，以及要求在之前在stable上工作的箱子中只使用夜间功能。</p>
<p>出于各种原因，一些项目选择在小版本中允许这种情况。更新到更新版本的Rust通常相对容易。Rust还有一个快速的6周发布周期，一些项目将在一个发布窗口内提供兼容性（例如当前的稳定版本加上N个以前的版本）。请记住，一些大型项目可能无法快速更新其 Rust 工具链。</p>
<p>缓解策略：</p>
<ul>
<li>使用<a href="reference/features.html">Cargo features</a>让新功能选择加入。</li>
<li>为旧版本提供一个大的支持窗口。</li>
<li>如果可能，请复制新标准库项的源，以便可以继续使用旧版本，但利用新功能。</li>
<li>提供一个较旧的次要版本的单独分支，可以接收重要错误修复的后台端口。</li>
<li>留心这件事<a href="https://github.com/rust-lang/rust/issues/64796"><code>[cfg(version(..))]</code></a>和<a href="https://github.com/rust-lang/rust/issues/64797"><code>#[cfg(accessible(..))]</code></a>为新功能提供选择加入机制的功能。这些频道目前不稳定，只能在夜间频道使用。</li>
</ul>
<p><a id="env-change-requirements"></a></p>
<h3 id="possibly-breaking-changing-the-platform-and-environment-requirements"><a class="header" href="#possibly-breaking-changing-the-platform-and-environment-requirements">Possibly-breaking: changing the platform and environment requirements</a></h3>
<p>对于一个库所运行的环境，有各种各样的假设，例如主机平台、操作系统版本、可用服务、文件系统支持等。如果您发布一个新版本，限制以前支持的内容，那么这可能是一个突破性的改变，例如，需要更新版本的操作系统。这些更改可能很难跟踪，因为您可能并不总是知道更改是否在未自动测试的环境中中断。</p>
<p>一些项目可能认为这种破坏是可以接受的，尤其是如果大多数用户不太可能破坏，或者项目没有支持所有环境的资源。另一个值得注意的情况是，当供应商停止支持某些硬件或操作系统时，项目可能认为停止支持也是合理的。</p>
<p>缓解策略：</p>
<ul>
<li>记录您特别支持的平台和环境。</li>
<li>在CI中的各种环境中测试代码。</li>
</ul>
<h3 id="cargo"><a class="header" href="#cargo">Cargo</a></h3>
<p><a id="cargo-feature-add"></a></p>
<h4 id="minor-adding-a-new-cargo-feature"><a class="header" href="#minor-adding-a-new-cargo-feature">Minor: adding a new Cargo feature</a></h4>
<p>添加新的内容通常是安全的<a href="reference/features.html">Cargo features</a>。如果该功能引入了新的更改，导致出现突破性的更改，这可能会给具有更严格向后兼容性需求的项目带来困难。在这种情况下，避免将该功能添加到“默认”列表中，并可能记录启用该功能的后果。</p>
<pre><code class="language-toml"># MINOR CHANGE

###########################################################
# Before
[features]
# ..empty

###########################################################
# After
[features]
std = []
</code></pre>
<p><a id="cargo-feature-remove"></a></p>
<h4 id="major-removing-a-cargo-feature"><a class="header" href="#major-removing-a-cargo-feature">Major: removing a Cargo feature</a></h4>
<p>这通常是一个突破性的改变删除<a href="reference/features.html">Cargo features</a>。这将导致启用该功能的任何项目出错。</p>
<pre><code class="language-toml"># MAJOR CHANGE

###########################################################
# Before
[features]
logging = []

###########################################################
# After
[dependencies]
# ..logging removed
</code></pre>
<p>缓解策略：</p>
<ul>
<li>清楚地记录你的特征。如果存在内部或实验性功能，请将其标记为该功能，以便用户了解该功能的状态。</li>
<li>保留旧功能<code>Cargo.toml</code>，但在其他方面删除其功能。记录该功能已被弃用，并在未来的主要SemVer版本中删除它。</li>
</ul>
<p><a id="cargo-feature-remove-another"></a></p>
<h4 id="major-removing-a-feature-from-a-feature-list-if-that-changes-functionality-or-public-items"><a class="header" href="#major-removing-a-feature-from-a-feature-list-if-that-changes-functionality-or-public-items">Major: removing a feature from a feature list if that changes functionality or public items</a></h4>
<p>如果从另一个功能中删除一个功能，如果现有用户希望通过该功能可以使用该功能，那么这可能会中断现有用户。</p>
<pre><code class="language-toml"># Breaking change example

###########################################################
# Before
[features]
default = [&quot;std&quot;]
std = []

###########################################################
# After
[features]
default = []  # This may cause packages to fail if they are expecting std to be enabled.
std = []
</code></pre>
<p><a id="cargo-remove-opt-dep"></a></p>
<h4 id="possibly-breaking-removing-an-optional-dependency"><a class="header" href="#possibly-breaking-removing-an-optional-dependency">Possibly-breaking: removing an optional dependency</a></h4>
<p>删除可选依赖项可能会中断使用库的项目，因为另一个项目可能通过<a href="reference/features.html">Cargo features</a>.</p>
<pre><code class="language-toml"># Breaking change example

###########################################################
# Before
[dependencies]
curl = { version = &quot;0.4.31&quot;, optional = true }

###########################################################
# After
[dependencies]
# ..curl removed
</code></pre>
<p>缓解策略：</p>
<ul>
<li>清楚地记录你的特征。如果可选的依赖项不包含在文档的特征列表中，那么您可能会认为更改无文档条目是安全的。</li>
<li>保留可选依赖项，只是不要在库中使用它。</li>
<li>将可选依赖项替换为<a href="reference/features.html">Cargo feature</a>这不起任何作用，并记录它已被弃用。</li>
<li>使用支持可选依赖项的高级功能，并将其记录为支持扩展功能的首选方式。例如，如果您的库对“networking”之类的东西有可选支持，请创建一个通用功能名“networking”，以启用实现“networking”所需的可选依赖项。然后记录“联网”功能。</li>
</ul>
<p><a id="cargo-change-dep-feature"></a></p>
<h4 id="minor-changing-dependency-features"><a class="header" href="#minor-changing-dependency-features">Minor: changing dependency features</a></h4>
<p>更改依赖项上的功能通常是安全的，只要该功能不引入破坏性的更改。</p>
<pre><code class="language-toml"># MINOR CHANGE

###########################################################
# Before
[dependencies]
rand = { version = &quot;0.7.3&quot;, features = [&quot;small_rng&quot;] }


###########################################################
# After
[dependencies]
rand = &quot;0.7.3&quot;
</code></pre>
<p><a id="cargo-dep-add"></a></p>
<h4 id="minor-adding-dependencies"><a class="header" href="#minor-adding-dependencies">Minor: adding dependencies</a></h4>
<p>添加新的依赖项通常是安全的，只要新的依赖项不会引入导致破坏性更改的新需求。例如，添加一个新的依赖项是一个重大的改变，该依赖项需要在以前在stable上工作的项目中每晚工作一次。</p>
<pre><code class="language-toml"># MINOR CHANGE

###########################################################
# Before
[dependencies]
# ..empty

###########################################################
# After
[dependencies]
log = &quot;0.4.11&quot;
</code></pre>
<h2 id="application-compatibility"><a class="header" href="#application-compatibility">Application compatibility</a></h2>
<p>Cargo项目还可能包括具有自己接口（例如CLI接口、操作系统级交互等）的可执行二进制文件。因为它们是Cargo包装的一部分，所以它们通常使用和共享与包装相同的版本。在对应用程序进行更改时，您需要决定是否以及如何与用户签订SemVer合同。一个应用程序的潜在破坏性和兼容性更改太多，无法列出，因此我们鼓励您使用<a href="https://semver.org/">SemVer</a>规范来指导您决定如何对应用程序应用版本控制，或者至少记录您的承诺。</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="future-incompat-report"><a class="header" href="#future-incompat-report">Future incompat report</a></h3>
<p>Cargo检查所有依赖项中的未来不兼容警告。这些警告针对可能在将来成为硬错误的更改，导致依赖关系在未来版本的rustc中停止构建。如果发现任何警告，将显示一个小通知，指示已发现警告，并提供有关如何显示完整报告的说明。</p>
<p>可以使用<code>cargo report future-incompatibilities --id ID</code>命令，或者使用<code>--future-incompat-report</code>选项然后，开发人员应该将他们的依赖项更新到问题得到修复的版本，或者与依赖项的开发人员一起帮助解决问题。</p>
<p>此功能可以通过<code>[future-incompat-report]</code>部分<code>.cargo/config</code>。目前，受支持的选项包括：</p>
<pre><code>[future-incompat-report]
frequency = FREQUENCY
</code></pre>
<p>的支持值<code>FREQUENCY</code>你总是<code>and 'never', which control whether or not a message is printed out at the end of</code>Cargo建造<code>/</code>Cargo检查。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unstable-features"><a class="header" href="#unstable-features">Unstable Features</a></h2>
<blockquote>
<p>不稳定的特性</p>
</blockquote>
<p>实验性 Cargo 特性仅适用于夜间通道(Rust 的 nightly 版本)。您通常使用<code>-Z</code>带其中一个特性，以启用它们。运行<code>cargo -Z help</code>查看可用的标志列表。</p>
<p><code>-Z unstable-options</code>是用于启用其他不稳定命令行标志的通用标志。需要的此选项将在下面列出。</p>
<p>某些不稳定的特性需要您，在<code>Cargo.toml</code>指定<code>cargo-features</code>字段。</p>
<h3 id="alternate-registries"><a class="header" href="#alternate-registries">Alternate Registries</a></h3>
<blockquote>
<p>替换(/备用)注册表</p>
</blockquote>
<ul>
<li>RFC:<a href="https://github.com/rust-lang/rfcs/blob/master/text/2141-alternative-registries.md">#2141</a></li>
<li>跟踪问题:<a href="https://github.com/rust-lang/rust/issues/44931">rust-lang/rust#44931</a></li>
</ul>
<p>备用注册表，允许您使用 crates.io 以外的注册表。</p>
<p>注册表的名称定义在<code>.cargo/config</code>中，<code>registries</code>表格的下面:</p>
<pre><code class="language-toml">[registries]
my-registry = { index = &quot;https://my-intranet:8080/git/index&quot; }
</code></pre>
<p>可以在<code>.cargo/credentials</code>添加备用注册表的身份验证信息:</p>
<pre><code class="language-toml">[registries.my-registry]
token = &quot;api-token&quot;
</code></pre>
<p>在<code>Cargo.toml</code>里面，您可以使用指定<code>registry</code>字段，让某个依赖项来自哪个注册表。但首先，您需要在文件的顶部包含适当的<code>cargo-features</code>:</p>
<pre><code class="language-toml">cargo-features = [&quot;alternative-registries&quot;]

[package]
...

[dependencies]
other-create = { version = &quot;1.0&quot;, registry = &quot;my-registry&quot;}
</code></pre>
<p>一个<code>--registry</code>标志 已添加到与注册表交互的<code>publish</code>，<code>login</code>等命令中。示例:</p>
<pre><code>cargo +nightly publish -Z unstable-options --registry my-registry
</code></pre>
<p>在<code>Cargo.toml</code>的 <code>publish</code> 字段，已被扩展为接受限制为发布到这些注册表的注册表列表。</p>
<pre><code class="language-toml">[package]
...
publish = [&quot;my-registry&quot;]
</code></pre>
<h3 id="publish-lockfile"><a class="header" href="#publish-lockfile">publish-lockfile</a></h3>
<blockquote>
<p>发布-锁文件</p>
</blockquote>
<ul>
<li>原始问题:<a href="https://github.com/rust-lang/cargo/issues/2263">#2263</a></li>
<li>PR:<a href="https://github.com/rust-lang/cargo/pull/5093">#5093</a></li>
<li>跟踪问题:<a href="https://github.com/rust-lang/cargo/issues/5654">#5654</a></li>
</ul>
<p>创建<code>.crate</code>文件分发时，Cargo 历史上不包括<code>Cargo.lock</code>文件。这可能会导致<code>cargo install</code>用于二进制文件的问题。您可以在<code>cargo package</code>要么<code>cargo publish</code>使用时，指定您的包应包含<code>Cargo.lock</code>，方法是在<code>Cargo.toml</code>中指定<code>publish-lockfile</code>字段。这也需要适当的<code>cargo-features</code>要求:</p>
<pre><code class="language-toml">cargo-features = [&quot;publish-lockfile&quot;]

[package]
...
publish-lockfile = true
</code></pre>
<h3 id="offline-mode"><a class="header" href="#offline-mode">Offline Mode</a></h3>
<blockquote>
<p>离线模式</p>
</blockquote>
<ul>
<li>原始问题:<a href="https://github.com/rust-lang/cargo/issues/4686">#4686</a></li>
<li>跟踪问题:<a href="https://github.com/rust-lang/cargo/issues/5655">#5655</a></li>
</ul>
<p><code>-Z offline</code>标志 可防止 Cargo 因任何原因尝试访问网络。通常情况下，如果 Cargo 要访问网络但它不可用，则会因错误而停止。</p>
<p>请注意，这可能会导致与在线模式不同的依赖项解析。即使可能有索引的较新版本的本地副本，Cargo 也会将自己限制在本地可用的箱(crate)中。</p>
<h3 id="no-index-update"><a class="header" href="#no-index-update">no-index-update</a></h3>
<blockquote>
<p>无索引更新</p>
</blockquote>
<ul>
<li>原始问题:<a href="https://github.com/rust-lang/cargo/issues/3479">#3479</a></li>
</ul>
<p><code>-Z no-index-update</code>标志 确保 Cargo 不会尝试更新注册表索引。这适用于测试(调制)许多 Cargo 命令的 Crater 等工具，并且您希望每次都避免更新索引的网络延迟。</p>
<h3 id="avoid-dev-deps"><a class="header" href="#avoid-dev-deps">avoid-dev-deps</a></h3>
<blockquote>
<p>阻止 开发依赖项</p>
</blockquote>
<ul>
<li>原始问题:<a href="https://github.com/rust-lang/cargo/issues/4988">#4988</a></li>
<li>稳定问题:<a href="https://github.com/rust-lang/cargo/issues/5133">#5133</a></li>
</ul>
<p>运行命令如<code>cargo install</code>要么<code>cargo build</code>时，Cargo 当前会需要下载 dev 依赖项，即使它们未被使用。而该<code>-Z avoid-dev-deps</code>标志 则让 Cargo 避免在不需要时下载 dev 依赖项。该<code>Cargo.lock</code>如果跳过了 dev-dependencies，将不会生成相关信息。</p>
<h3 id="minimal-versions"><a class="header" href="#minimal-versions">minimal-versions</a></h3>
<blockquote>
<p>最小的版本</p>
</blockquote>
<ul>
<li>原始问题:<a href="https://github.com/rust-lang/cargo/issues/4100">#4100</a></li>
<li>跟踪问题:<a href="https://github.com/rust-lang/cargo/issues/5657">#5657</a></li>
</ul>
<p>当一个<code>Cargo.lock</code>文件被生成，<code>-Z minimal-versions</code>标志的使用， 将解析依赖关系为满足要求的最小 semver 版本(而不是最高版本)。</p>
<p>此标志的预期用例，是在持续集成期间，检查 Cargo.toml 中指定的版本是否是您实际使用的最低版本的正确反映。也就是说，如果 Cargo.toml 有<code>foo = &quot;1.0.0&quot;</code>说明，那您依赖该特性，不会意外地添加<code>foo 1.5.0</code>。</p>
<h3 id="out-dir"><a class="header" href="#out-dir">out-dir</a></h3>
<blockquote>
<p>输出目录</p>
</blockquote>
<ul>
<li>原始问题:<a href="https://github.com/rust-lang/cargo/issues/4875">#4875</a></li>
</ul>
<p>此功能允许您指定，构建工件后，将复制到的目录。通常，工件只写入<code>target/release</code>要么<code>target/debug</code>目录。但是，确定明确的文件名可能很棘手，因为您需要解析 JSON 输出。而该<code>--out-dir</code>标志 可以更容易地预测访问工件。但是请注意，工件只是被复制，因此原件仍在<code>target</code>目录.例:</p>
<pre><code>cargo +nightly build --out-dir=out -Z unstable-options
</code></pre>
<h3 id="profile-overrides"><a class="header" href="#profile-overrides">Profile Overrides</a></h3>
<blockquote>
<p>覆盖配置</p>
</blockquote>
<ul>
<li>跟踪问题:<a href="https://github.com/rust-lang/rust/issues/48683">rust-lang/rust#48683</a></li>
<li>RFC:<a href="https://github.com/rust-lang/rfcs/blob/master/text/2282-profile-dependencies.md">#2282</a></li>
</ul>
<p>可以为特定包和自定义生成脚本覆盖配置文件。一般格式如下:</p>
<pre><code class="language-toml">cargo-features = [&quot;profile-overrides&quot;]

[package]
...

[profile.dev]
opt-level = 0
debug = true

# 这个 `image` 箱 会编译的等级 -Copt-level=3
[profile.dev.overrides.image]
opt-level = 3

# 所有 依赖项 (但 不是 箱本身 或 某些工作区成员)
# 会编译的等级 -Copt-level=2 。 其中包括 构建依赖项.
[profile.dev.overrides.&quot;*&quot;]
opt-level = 2

# 构建 脚本和他们的 依赖项， 会编译的等级 -Copt-level=3
# 默认情况， 构建 脚本 对剩下的配置使用相同的选择
[profile.dev.build-override]
opt-level = 3
</code></pre>
<p>能只为 dev 和 release 配置文件指定覆盖。</p>
<h3 id="config-profiles"><a class="header" href="#config-profiles">Config Profiles</a></h3>
<blockquote>
<p>配置 配置文件 (第一个动词，第二个名词)</p>
</blockquote>
<ul>
<li>跟踪问题:<a href="https://github.com/rust-lang/rust/issues/48683">rust-lang/rust#48683</a></li>
<li>RFC:<a href="https://github.com/rust-lang/rfcs/blob/master/text/2282-profile-dependencies.md">#2282</a></li>
</ul>
<!-- HERE -->
<p>可以在<code>.cargo/config</code>文件中指定配置文件。该<code>-Z config-profile</code>命令行标志是使用此功能所必需的。格式与一个 <code>Cargo.toml</code>清单格式相同。如果在多个文件中找到相同的配置，则通过使用常规设置<a href="reference/./config.html#hierarchical-structure">配置层次结构</a>合并。配置设置优先于清单设置。</p>
<pre><code class="language-toml">[profile.dev]
opt-level = 3
</code></pre>
<pre><code>cargo +nightly build -Z config-profile
</code></pre>
<h3 id="namespaced-features"><a class="header" href="#namespaced-features">Namespaced features</a></h3>
<blockquote>
<p>特性的命名区间化</p>
</blockquote>
<ul>
<li>原始问题:<a href="https://github.com/rust-lang/cargo/issues/1286">#1286</a></li>
<li>跟踪问题:<a href="https://github.com/rust-lang/cargo/issues/5565">rust-lang/Cargo#5565</a></li>
</ul>
<p>目前，不可能在清单中具有相同名称的特性和依赖项。但如果你设置<code>namespaced-features</code>至<code>true</code>，功能和依赖项的命名空间就会是分开的。这样做的结果是，在特性请求中，依赖项必须以<code>crate:</code>为前缀。像这样:</p>
<pre><code class="language-toml">[package]
namespaced-features = true

[features]
bar = [&quot;crate:baz&quot;, &quot;foo&quot;]
foo = []

[dependencies]
baz = { version = &quot;0.1&quot;, optional = true }
</code></pre>
<p>为了防止不必要的，必须为每个可选依赖项显式声明特性的模版，将为任何不是定义为相同名称的特性，的可选依赖项创建隐式特性。但是，如果定义了与依赖项同名的特性，则该特性必须将依赖项作为必需项，正如<code>foo = [&quot;crate:foo&quot;]</code>。</p>
<h3 id="build-plan"><a class="header" href="#build-plan">Build-plan</a></h3>
<blockquote>
<p>构建计划</p>
</blockquote>
<ul>
<li>跟踪问题:<a href="https://github.com/rust-lang/cargo/issues/5579">rust-lang/Cargo#5579</a></li>
</ul>
<p><code>build</code>命令的<code>--build-plan</code>参数，将输出 JSON，其中包含有关将运行哪些命令，和不实际执行任何操作的信息。与其他构建工具集成时，这可能很有用。例:</p>
<pre><code>cargo +nightly build --build-plan -Z unstable-options
</code></pre>
<h3 id="default-run"><a class="header" href="#default-run">default-run</a></h3>
<blockquote>
<p>默认运行</p>
</blockquote>
<ul>
<li>原始问题:<a href="https://github.com/rust-lang/cargo/issues/2200">#2200</a></li>
</ul>
<p>清单中<code>[package]</code>部分的该<code>default-run</code>选项，可用于指定<code>cargo run</code>选择的默认二进制文件。例如，当存在<code>src/bin/a.rs</code>和<code>src/bin/b.rs</code>两者时，选择前者:</p>
<pre><code class="language-toml">[package]
default-run = &quot;a&quot;
</code></pre>
<h3 id="metabuild"><a class="header" href="#metabuild">Metabuild</a></h3>
<blockquote>
<p>元构建</p>
</blockquote>
<ul>
<li>跟踪问题:<a href="https://github.com/rust-lang/rust/issues/49803">rust-lang/rust#49803</a></li>
<li>RFC:<a href="https://github.com/rust-lang/rfcs/blob/master/text/2196-metabuild.md">#2196</a></li>
</ul>
<p>Metabuild 是一个具有声明性构建脚本的特性。作为不去写一个<code>build.rs</code>脚本，而是您在<code>Cargo.toml</code>中的<code>metabuild</code>字段，指定构建依赖项列表。其将自动生成一个构建脚本，该脚本按顺序运行每个构建依赖项。然后，Metabuild 包可以从<code>Cargo.toml</code>中读取元数据，执行他们的指定行为。</p>
<p>需要包括<code>cargo-features</code>在<code>Cargo.toml</code>的顶部， 一个<code>metadata</code>字段在<code>package</code>下，列出<code>build-dependencies</code>依赖项，并添加 metabuild 包所需的任何元数据。例:</p>
<pre><code class="language-toml">cargo-features = [&quot;metabuild&quot;]

[package]
name = &quot;mypackage&quot;
version = &quot;0.0.1&quot;
metabuild = [&quot;foo&quot;, &quot;bar&quot;]

[build-dependencies]
foo = &quot;1.0&quot;
bar = &quot;1.0&quot;

[package.metadata.foo]
extra-info = &quot;qwerty&quot;
</code></pre>
<p>Metabuild 包应该有一个名<code>metabuild</code>为的公共函数，它会执行与常规<code>build.rs</code>脚本一样，执行相同操作。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-commands"><a class="header" href="#cargo-commands">Cargo Commands</a></h1>
<ul>
<li><a href="commands/general-commands.zh.html">General Commands</a></li>
<li><a href="commands/build-commands.zh.html">Build Commands</a></li>
<li><a href="commands/manifest-commands.zh.html">Manifest Commands</a></li>
<li><a href="commands/package-commands.zh.html">Package Commands</a></li>
<li><a href="commands/publishing-commands.zh.html">Publishing Commands</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="general-commands"><a class="header" href="#general-commands">General Commands</a></h1>
<ul>
<li><a href="commands/cargo.zh.html">cargo</a></li>
<li><a href="commands/cargo-help.zh.html">cargo help</a></li>
<li><a href="commands/cargo-version.zh.html">cargo version</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo1"><a class="header" href="#cargo1">cargo(1)</a></h1>
<h2 id="name"><a class="header" href="#name">NAME</a></h2>
<p>Cargo - Rust 包管理器</p>
<h2 id="synopsis"><a class="header" href="#synopsis">SYNOPSIS</a></h2>
<p><code>cargo</code> [<em>options</em>] <em>command</em> [<em>args</em>]<br />
<code>cargo</code> [<em>options</em>] <code>--version</code><br />
<code>cargo</code> [<em>options</em>] <code>--list</code><br />
<code>cargo</code> [<em>options</em>] <code>--help</code><br />
<code>cargo</code> [<em>options</em>] <code>--explain</code> <em>code</em></p>
<h2 id="description"><a class="header" href="#description">DESCRIPTION</a></h2>
<p>该程序是 Rust 语言的包管理器和构建工具，列入<a href="https://rust-lang.org">https://rust-lang.org</a>。</p>
<h2 id="commands"><a class="header" href="#commands">COMMANDS</a></h2>
<h3 id="build-commands"><a class="header" href="#build-commands">Build Commands</a></h3>
<p><a href="commands/cargo-bench.zh.html">cargo-bench(1)</a><br />
执行包的基准测试。</p>
<p><a href="commands/cargo-build.zh.html">cargo-build(1)</a><br />
编译一个包。</p>
<p><a href="commands/cargo-check.zh.html">cargo-check(1)</a><br />
检查本地包及其所有依赖项是否存在错误。</p>
<p><a href="commands/cargo-clean.zh.html">cargo-clean(1)</a><br />
移除 Cargo 过去生成的工件。</p>
<p><a href="commands/cargo-doc.zh.html">cargo-doc(1)</a><br />
构建包的文档。</p>
<p><a href="commands/cargo-fetch.zh.html">cargo-fetch(1)</a><br />
网络获取包的依赖项。</p>
<p><a href="commands/cargo-fix.zh.html">cargo-fix(1)</a><br />
自动修复 rustc 报告的 lint 警告。</p>
<p><a href="commands/cargo-run.zh.html">cargo-run(1)</a><br />
运行二进制文件或本地包的示例。</p>
<p><a href="commands/cargo-rustc.zh.html">cargo-rustc(1)</a><br />
编译一个包，并将额外的选项传递给编译器。</p>
<p><a href="commands/cargo-rustdoc.zh.html">cargo-rustdoc(1)</a><br />
使用指定的自定义标志，生成包的文档。</p>
<p><a href="commands/cargo-test.zh.html">cargo-test(1)</a><br />
执行软件包的单元测试和集成测试。</p>
<h3 id="manifest-commands"><a class="header" href="#manifest-commands">Manifest Commands</a></h3>
<p><a href="commands/cargo-generate-lockfile.zh.html">cargo-generate-lockfile(1)</a><br />
为了一个项目，生成<code>Cargo.lock</code>。</p>
<p><a href="commands/cargo-locate-project.zh.html">cargo-locate-project(1)</a><br />
打印 JSON 格式的<code>Cargo.toml</code>文件的位置。</p>
<p><a href="commands/cargo-metadata.zh.html">cargo-metadata(1)</a><br />
以机器可读的格式，输出已解析的包依赖项。</p>
<p><a href="commands/cargo-pkgid.zh.html">cargo-pkgid(1)</a><br />
打印完全合格的包规格。</p>
<p><a href="commands/cargo-tree.zh.html">cargo-tree(1)</a><br />
显示依赖关系图的树可视化。</p>
<p><a href="commands/cargo-update.zh.html">cargo-update(1)</a><br />
更新本地锁文件中，记录的依赖项。</p>
<p><a href="commands/cargo-vendor.zh.html">cargo-vendor(1)</a><br />
本地供应所有依赖项。</p>
<p><a href="commands/cargo-verify-project.zh.html">cargo-verify-project(1)</a><br />
检查箱子清单的正确性。</p>
<h3 id="package-commands"><a class="header" href="#package-commands">Package Commands</a></h3>
<p><a href="commands/cargo-init.zh.html">cargo-init(1)</a><br />
在现有目录中，创建新的 Cargo 包。</p>
<p><a href="commands/cargo-install.zh.html">cargo-install(1)</a><br />
构建并安装一个 Rust 的二进制文件。</p>
<p><a href="commands/cargo-new.zh.html">cargo-new(1)</a><br />
创建一个新的 Cargo 包。</p>
<p><a href="commands/cargo-search.zh.html">cargo-search(1)</a><br />
在 crates.io 中搜索包。</p>
<p><a href="commands/cargo-uninstall.zh.html">cargo-uninstall(1)</a><br />
移除一个 Rust 包二进制程序。</p>
<h3 id="publishing-commands"><a class="header" href="#publishing-commands">Publishing Commands</a></h3>
<p><a href="commands/cargo-login.zh.html">cargo-login(1)</a><br />
本地保存一个 registry（来源网站） 的 API 令牌。</p>
<p><a href="commands/cargo-owner.zh.html">cargo-owner(1)</a><br />
管理 registry 上，箱子的所有者。</p>
<p><a href="commands/cargo-package.zh.html">cargo-package(1)</a><br />
将本地包汇编成一个可分配的压缩文件（tarball）。</p>
<p><a href="commands/cargo-publish.zh.html">cargo-publish(1)</a><br />
将包上载到 来源网站 。</p>
<p><a href="commands/cargo-yank.zh.html">cargo-yank(1)</a><br />
从索引中，移除一个已推送的箱子。</p>
<h3 id="general-commands-1"><a class="header" href="#general-commands-1">General Commands</a></h3>
<p><a href="commands/cargo-help.zh.html">cargo-help(1)</a><br />
显示有关 Cargo 的帮助信息。</p>
<p><a href="commands/cargo-version.zh.html">cargo-version(1)</a><br />
显示版本信息。</p>
<h2 id="options"><a class="header" href="#options">OPTIONS</a></h2>
<h3 id="special-options"><a class="header" href="#special-options">Special Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo--V"><a class="option-anchor" href="commands/cargo.zh.html#option-cargo--V"></a><code>-V</code></dt>
<dt class="option-term" id="option-cargo---version"><a class="option-anchor" href="commands/cargo.zh.html#option-cargo---version"></a><code>--version</code></dt>
<dd class="option-desc">打印版本信息并退出。如果使用了 <code>--verbose</code>, 就会打印额外信息</dd>
<dt class="option-term" id="option-cargo---list"><a class="option-anchor" href="commands/cargo.zh.html#option-cargo---list"></a><code>--list</code></dt>
<dd class="option-desc">列出所有安装的 Cargo 子命令。如果使用了 <code>--verbose</code>, 打印额外的信息。</dd>
<dt class="option-term" id="option-cargo---explain"><a class="option-anchor" href="commands/cargo.zh.html#option-cargo---explain"></a><code>--explain</code> <em>code</em></dt>
<dd class="option-desc">运行 <code>rustc --explain CODE</code>，它会给出一个错误信息的详细解释 (例如 CODE 可以是, <code>E0004</code>)。</dd>
</dl>
<h3 id="display-options"><a class="header" href="#display-options">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo--v"><a class="option-anchor" href="commands/cargo.zh.html#option-cargo--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo---verbose"><a class="option-anchor" href="commands/cargo.zh.html#option-cargo---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">详细的输出。还可以两个 v 字符，就是 &quot;非常详细&quot; 的输出：包括额外的输出，如依赖警告和构建脚本的输出。
还可以使用 <code>term.verbose</code>
<a href="commands/../reference/config.zh.html">配置选项</a>.</dd>
<dt class="option-term" id="option-cargo--q"><a class="option-anchor" href="commands/cargo.zh.html#option-cargo--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo---quiet"><a class="option-anchor" href="commands/cargo.zh.html#option-cargo---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不打印日志信息。
还可以使用 <code>term.quiet</code>
<a href="commands/../reference/config.zh.html">配置选项</a>。</dd>
<dt class="option-term" id="option-cargo---color"><a class="option-anchor" href="commands/cargo.zh.html#option-cargo---color"></a><code>--color</code></dt>
<dd class="option-desc">颜色化输出的配置。可用选项:</p>
<ul>
<li><code>auto</code> (default): 自动</li>
<li><code>always</code>: 有颜色</li>
<li><code>never</code>: 没颜色</li>
</ul>
<p>还可以使用 <code>term.color</code>
<a href="commands/../reference/config.zh.html">配置选项</a>.</dd>
</dl>
<h3 id="manifest-options"><a class="header" href="#manifest-options">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo---frozen"><a class="option-anchor" href="commands/cargo.zh.html#option-cargo---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo---locked"><a class="option-anchor" href="commands/cargo.zh.html#option-cargo---locked"></a><code>--locked</code></dt>
<dd class="option-desc">两个命令选项都要求 <code>Cargo.lock</code> 文件是最新的。如果缺少了该文件，或是它需要更新，那么 Cargo 就以一个错误退出。 <code>--frozen</code> 阻止 Cargo 连网检测它是不是最新的。</p>
<p>这两个选项可用在 CI 的环境，断定
<code>Cargo.lock</code> 是最新的，或是阻止网络的访问。</dd>
<dt class="option-term" id="option-cargo---offline"><a class="option-anchor" href="commands/cargo.zh.html#option-cargo---offline"></a><code>--offline</code></dt>
<dd class="option-desc">网络禁止。在没有这个选项的情况下，网络访问失败，Cargo 会以一个错误停止。若使用了这个选项，Cargo 会尝试不联网的状态继续执行</p>
<p>注意，大概率会产生与联网时不同的依赖解析。限制为本地已下载的箱子，即便是本地索引的新副本，都不行。
看看 <a href="commands/cargo-fetch.zh.html">cargo-fetch(1)</a> 在断网前，下载依赖</p>
<p>还可以使用 <code>net.offline</code> <a href="commands/../reference/config.zh.html">配置选项</a>.</dd>
</dl>
<h3 id="common-options"><a class="header" href="#common-options">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-+toolchain"><a class="option-anchor" href="commands/cargo.zh.html#option-cargo-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">若是使用 rustup 安装的 Cargo, <code>cargo</code> 的第一个参数 
<code>+</code>, 跟着工具链名称 (例如
例如 <code>+stable</code> 或 <code>+nightly</code>).
可以查看<a href="https://rust-lang.github.io/rustup/overrides.html">rustup 文档。</a>
关于工具链覆盖的详细信息。</dd>
<dt class="option-term" id="option-cargo--h"><a class="option-anchor" href="commands/cargo.zh.html#option-cargo--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo---help"><a class="option-anchor" href="commands/cargo.zh.html#option-cargo---help"></a><code>--help</code></dt>
<dd class="option-desc">打印帮助信息。</dd>
<dt class="option-term" id="option-cargo--Z"><a class="option-anchor" href="commands/cargo.zh.html#option-cargo--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Cargo 的 不稳定的 (nightly-only) 选项。运行 <code>cargo -Z help</code> 获取详细信息。</dd>
</dl>
<h2 id="environment"><a class="header" href="#environment">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.zh.html">the reference</a>有关 Cargo 读取的环境变量的详细信息。</p>
<h2 id="exit-status"><a class="header" href="#exit-status">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>： Cargo 成功。</li>
<li><code>101</code>： Cargo 未能完成。</li>
</ul>
<h2 id="files-1"><a class="header" href="#files-1">FILES</a></h2>
<p><code>~/.cargo/</code><br />
Cargo 的“主”目录的默认位置，用于存储各种文件。可以通过<code>CARGO_HOME</code>环境变量改变。</p>
<p><code>$CARGO_HOME/bin/</code><br />
由<a href="commands/cargo-install.zh.html">cargo-install(1)</a>安装的二进制文件，将位于这里。如果使用<a href="https://rust-lang.github.io/rustup/">rustup</a>，Rust 的可执行文件也位于此处。</p>
<p><code>$CARGO_HOME/config.toml</code><br />
全局配置文件。查看<a href="commands/../reference/config.zh.html">the reference</a>有关配置文件的更多信息。</p>
<p><code>.cargo/config.toml</code><br />
Cargo 会自动搜索，在当前目录和所有父目录中，名为<code>.cargo/config.toml</code>的文件。这些配置文件将与全局配置文件合并。</p>
<p><code>$CARGO_HOME/credentials.toml</code><br />
用于登录到 来源网站 的私人身份验证信息。</p>
<p><code>$CARGO_HOME/registry/</code><br />
此目录包含 来源网站 索引的缓存下载和任何下载的依赖项。</p>
<p><code>$CARGO_HOME/git/</code><br />
此目录包含 git 依赖项的缓存下载。</p>
<p>请注意<code>$CARGO_HOME</code>目录的内部结构尚未稳定，可能会发生更改。</p>
<h2 id="examples-2"><a class="header" href="#examples-2">EXAMPLES</a></h2>
<ol>
<li>构建本地包及其所有依赖项：</li>
</ol>
<pre><code class="language-bash">cargo build
</code></pre>
<ol start="2">
<li>构建一个优化包：</li>
</ol>
<pre><code class="language-bash">cargo build --release
</code></pre>
<ol start="3">
<li>对跨编译的目标运行测试：</li>
</ol>
<pre><code class="language-bash">cargo test --target i686-unknown-linux-gnu
</code></pre>
<ol start="4">
<li>创建用于生成可执行文件的新包：</li>
</ol>
<pre><code class="language-bash">cargo new foobar
</code></pre>
<ol start="5">
<li>在当前目录中，创建包：</li>
</ol>
<pre><code class="language-bash">mkdir foo &amp;&amp; cd foo
cargo init .
</code></pre>
<ol start="6">
<li>了解命令的选项和用法：</li>
</ol>
<pre><code class="language-bash">cargo help clean
</code></pre>
<h2 id="bugs"><a class="header" href="#bugs">BUGS</a></h2>
<p>查看<a href="https://github.com/rust-lang/cargo/issues">https://github.com/rust-lang/cargo/issues</a>关于问题。</p>
<h2 id="see-also"><a class="header" href="#see-also">SEE ALSO</a></h2>
<p><a href="https://doc.rust-lang.org/rustc/index.zh.md">rustc(1)</a>, <a href="https://doc.rust-lang.org/rustdoc/index.zh.md">rustdoc(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-help1"><a class="header" href="#cargo-help1">cargo-help(1)</a></h1>
<h2 id="name-1"><a class="header" href="#name-1">NAME</a></h2>
<p>Cargo-help - 获得 Cargo 帮助信息</p>
<h2 id="synopsis-1"><a class="header" href="#synopsis-1">SYNOPSIS</a></h2>
<p><code>cargo help</code> [<em>subcommand</em>]</p>
<h2 id="description-1"><a class="header" href="#description-1">DESCRIPTION</a></h2>
<p>打印给定命令的帮助消息。</p>
<h2 id="examples-3"><a class="header" href="#examples-3">EXAMPLES</a></h2>
<ol>
<li>获取命令帮助：</li>
</ol>
<pre><code class="language-bash">    cargo help build
</code></pre>
<ol start="2">
<li>也可以通过<code>--help</code>选项：</li>
</ol>
<pre><code class="language-bash">    cargo build --help
</code></pre>
<h2 id="see-also-1"><a class="header" href="#see-also-1">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-version1"><a class="header" href="#cargo-version1">cargo-version(1)</a></h1>
<h2 id="name-2"><a class="header" href="#name-2">NAME</a></h2>
<p>cargo-version - 显示版本信息</p>
<h2 id="synopsis-2"><a class="header" href="#synopsis-2">SYNOPSIS</a></h2>
<p><code>cargo version</code> [<em>options</em>]</p>
<h2 id="description-2"><a class="header" href="#description-2">DESCRIPTION</a></h2>
<p>显示 Cargo 的版本。</p>
<h2 id="options-1"><a class="header" href="#options-1">OPTIONS</a></h2>
<dl>
<dt class="option-term" id="option-cargo-version--v"><a class="option-anchor" href="commands/cargo-version.zh.html#option-cargo-version--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-version---verbose"><a class="option-anchor" href="commands/cargo-version.zh.html#option-cargo-version---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">显示额外的版本信息</dd>
</dl>
<h2 id="examples-4"><a class="header" href="#examples-4">EXAMPLES</a></h2>
<ol>
<li>显示版本：</li>
</ol>
<pre><code>cargo version
</code></pre>
<ol start="2">
<li>该版本也可通过以下标志获得：</li>
</ol>
<pre><code>cargo --version
cargo -V
</code></pre>
<ol start="3">
<li>显示额外的版本信息：</li>
</ol>
<pre><code>cargo -Vv
</code></pre>
<h2 id="see-also-2"><a class="header" href="#see-also-2">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-commands-1"><a class="header" href="#build-commands-1">Build Commands</a></h1>
<ul>
<li><a href="commands/cargo-bench.zh.html">cargo bench</a></li>
<li><a href="commands/cargo-build.zh.html">cargo build</a></li>
<li><a href="commands/cargo-check.zh.html">cargo check</a></li>
<li><a href="commands/cargo-clean.zh.html">cargo clean</a></li>
<li><a href="commands/cargo-doc.zh.html">cargo doc</a></li>
<li><a href="commands/cargo-fetch.zh.html">cargo fetch</a></li>
<li><a href="commands/cargo-fix.zh.html">cargo fix</a></li>
<li><a href="commands/cargo-run.zh.html">cargo run</a></li>
<li><a href="commands/cargo-rustc.zh.html">cargo rustc</a></li>
<li><a href="commands/cargo-rustdoc.zh.html">cargo rustdoc</a></li>
<li><a href="commands/cargo-test.zh.html">cargo test</a></li>
<li><a href="commands/cargo-report.zh.html">cargo report</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-bench1"><a class="header" href="#cargo-bench1">cargo-bench(1)</a></h1>
<h2 id="name-3"><a class="header" href="#name-3">NAME</a></h2>
<p>cargo-bench - 执行箱子的基准测试</p>
<h2 id="synopsis-3"><a class="header" href="#synopsis-3">SYNOPSIS</a></h2>
<p><code>cargo bench</code> [<em>options</em>] [<em>benchname</em>] [<code>--</code> <em>bench-options</em>]</p>
<h2 id="description-3"><a class="header" href="#description-3">DESCRIPTION</a></h2>
<p>编译并执行基准测试。</p>
<p>基准测试的筛选参数 <code>benchname</code> 以及，两个破折号(<code>--</code>)后面的所有参数，都传递给基准测试的二进制文件，从而传递给 <code>libtest</code>（rustc 的内置单元测试和微基准测试框架）。如果您同时向 Cargo 和二进制文件传递参数，那么，<code>--</code>后面的参数给到二进制文件，而之前的给到 Cargo 。有关 libtest 参数的详细信息，请参阅<code>cargo bench -- --help</code>看看 rustc 书中，关于测试如何工作的 <a href="https://doc.rust-lang.org/rustc/tests/index.html">https://doc.rust-lang.org/rustc/tests/index.html</a>.</p>
<p>例如，下面的示例中，只运行名为<code>foo</code>（并跳过，其他类似名称的基准测试，如<code>foobar</code>):</p>
<pre><code>cargo bench -- foo --exact
</code></pre>
<p>基准测试是用<code>rustc</code>的<code>--test</code>选项，它创建了一个<code>main</code>函数，自动运行所有带<code>#[bench]</code>属性函数，Cargo 传递<code>--bench</code>给测试工具，告诉它只运行基准测试。</p>
<p>libtest harness 可以禁用，需要通过设置<code>harness = false</code>，在这种情况下，代码需要提供自己的<code>main</code>函数，来处理运行中的基准测试。</p>
<blockquote>
<p><strong>注意：</strong> <a href="https://doc.rust-lang.org/nightly/unstable-book/library-features/test.html"><code>#[bench]</code> attribute</a>目前不稳定，仅在<a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly channel</a>可用。<a href="https://crates.io/keywords/benchmark">crates.io</a>上会有些包，能够帮助你在 stable channel 上运行基准测试，例如，<a href="https://crates.io/crates/criterion">Criterion</a>。</p>
</blockquote>
<p>默认情况下，<code>cargo bench</code>使用<a href="commands/../reference/profiles.html#bench"><code>bench</code> profile</a>，启用了优化，并禁用调试信息。如果需要调试一个基准测试，可以使用<code>--profile=dev</code>命令行选项，切换到 dev profile。然后，可以在调试器中，运行启用调试的基准测试。</p>
<h2 id="options-2"><a class="header" href="#options-2">OPTIONS</a></h2>
<h3 id="benchmark-options"><a class="header" href="#benchmark-options">Benchmark Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-bench---no-run"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---no-run"></a><code>--no-run</code></dt>
<dd class="option-desc">编译，但不运行基准测试</dd>
<dt class="option-term" id="option-cargo-bench---no-fail-fast"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---no-fail-fast"></a><code>--no-fail-fast</code></dt>
<dd class="option-desc">不管失败的，运行所有基准测试。若是没有这个选项，在第一次基准测试失败， Cargo 会退出。The Rust test harness 会运行可执行文件，直到所有的基准测试完成，这个选项仅应用到完整的可执行文件。</dd>
</dl>
<h3 id="package-selection-2"><a class="header" href="#package-selection-2">Package Selection</a></h3>
<p>默认情况下，如果未提供包选择选项，则选择的包取决于选择的清单文件（如果需要，则基于当前工作目录）<code>--manifest-path</code>未给出）。如果清单是工作区的根目录，则会选择工作区默认成员，否则只会选择清单定义的包。</p>
<p>可以使用<code>workspace.default-members</code>输入根清单。如果未设置，虚拟工作区将包括所有工作区成员（相当于传递）<code>--workspace</code>)，非虚拟工作区将只包括根箱子本身。</p>
<dl>
<dt class="option-term" id="option-cargo-bench--p"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-bench---package"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Benchmark only the specified packages. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the
SPEC format. This flag may be specified multiple times and supports common Unix
glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell accidentally 
expanding glob patterns before Cargo handles them, you must use single quotes or
double quotes around each pattern.</dd>
<dt class="option-term" id="option-cargo-bench---workspace"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">Benchmark all members in the workspace.</dd>
<dt class="option-term" id="option-cargo-bench---all"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---all"></a><code>--all</code></dt>
<dd class="option-desc">Deprecated alias for <code>--workspace</code>.</dd>
<dt class="option-term" id="option-cargo-bench---exclude"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---exclude"></a><code>--exclude</code> <em>SPEC</em>...</dt>
<dd class="option-desc">Exclude the specified packages. Must be used in conjunction with the
<code>--workspace</code> flag. This flag may be specified multiple times and supports
common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell
accidentally expanding glob patterns before Cargo handles them, you must use
single quotes or double quotes around each pattern.</dd>
</dl>
<h3 id="target-selection"><a class="header" href="#target-selection">Target Selection</a></h3>
<p>当没有给出目标选择选项时，<code>cargo bench</code>将为选定的软件包建立以下目标：</p>
<ul>
<li>lib-用于链接二进制文件和基准测试</li>
<li>BIN（仅当建立了基准目标且所需功能可用时）</li>
<li>lib 作为基准</li>
<li>以垃圾箱为基准</li>
<li>基准目标</li>
</ul>
<p>可以通过设置<code>bench</code>清单设置中目标的标志。以身作则<code>bench = true</code>将构建并运行该示例作为基准。设定目标<code>bench = false</code>将阻止它们在默认情况下成为基准。按名称获取目标的目标选择选项忽略<code>bench</code>标记并始终对给定目标进行基准测试。</p>
<p>传递目标选择标志将仅对指定的目标进行基准测试。</p>
<p>注意<code>--bin</code>, <code>--example</code>, <code>--test</code>和<code>--bench</code>标志还支持常见的 Unix 全局模式，如<code>*</code>, <code>?</code>和<code>[]</code>但是，为了避免您的 shell 在 Cargo 处理 glob 模式之前意外地扩展 glob 模式，您必须在每个 glob 模式周围使用单引号或双引号。</p>
<dl>
<dt class="option-term" id="option-cargo-bench---lib"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---lib"></a><code>--lib</code></dt>
<dd class="option-desc">Benchmark the package's library.</dd>
<dt class="option-term" id="option-cargo-bench---bin"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">Benchmark the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-bench---bins"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---bins"></a><code>--bins</code></dt>
<dd class="option-desc">Benchmark all binary targets.</dd>
<dt class="option-term" id="option-cargo-bench---example"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---example"></a><code>--example</code> <em>name</em>...</dt>
<dd class="option-desc">Benchmark the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-bench---examples"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---examples"></a><code>--examples</code></dt>
<dd class="option-desc">Benchmark all example targets.</dd>
<dt class="option-term" id="option-cargo-bench---test"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---test"></a><code>--test</code> <em>name</em>...</dt>
<dd class="option-desc">Benchmark the specified integration test. This flag may be specified
multiple times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-bench---tests"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---tests"></a><code>--tests</code></dt>
<dd class="option-desc">Benchmark all targets in test mode that have the <code>test = true</code> manifest
flag set. By default this includes the library and binaries built as
unittests, and integration tests. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
unittest, and once as a dependency for binaries, integration tests, etc.).
Targets may be enabled or disabled by setting the <code>test</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-bench---bench"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---bench"></a><code>--bench</code> <em>name</em>...</dt>
<dd class="option-desc">Benchmark the specified benchmark. This flag may be specified multiple
times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-bench---benches"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---benches"></a><code>--benches</code></dt>
<dd class="option-desc">Benchmark all targets in benchmark mode that have the <code>bench = true</code>
manifest flag set. By default this includes the library and binaries built
as benchmarks, and bench targets. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
benchmark, and once as a dependency for binaries, benchmarks, etc.).
Targets may be enabled or disabled by setting the <code>bench</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-bench---all-targets"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---all-targets"></a><code>--all-targets</code></dt>
<dd class="option-desc">Benchmark all targets. This is equivalent to specifying <code>--lib --bins --tests --benches --examples</code>.</dd>
</dl>
<h3 id="feature-selection"><a class="header" href="#feature-selection">Feature Selection</a></h3>
<p>功能标志允许您控制启用哪些功能。如果未提供任何功能选项，则<code>default</code>为每个选定的软件包激活该功能。</p>
<p>查看<a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>更多细节。</p>
<dl>
<dt class="option-term" id="option-cargo-bench---features"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</dd>
<dt class="option-term" id="option-cargo-bench---all-features"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">Activate all available features of all selected packages.</dd>
<dt class="option-term" id="option-cargo-bench---no-default-features"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">Do not activate the <code>default</code> feature of the selected packages.</dd>
</dl>
<h3 id="compilation-options"><a class="header" href="#compilation-options">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-bench---target"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Benchmark for the given architecture. The default is the host
architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>. Run <code>rustc --print target-list</code> for a
list of supported targets.</p>
<p>This may also be specified with the <code>build.target</code>
<a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../guide/build-cache.html">build cache</a> documentation for more details.</dd>
<dt class="option-term" id="option-cargo-bench---profile"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Benchmark with the given profile.
See the <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</dd>
<dt class="option-term" id="option-cargo-bench---ignore-rust-version"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---ignore-rust-version"></a><code>--ignore-rust-version</code></dt>
<dd class="option-desc">Benchmark the target even if the selected Rust compiler is older than the
required Rust version as configured in the project's <code>rust-version</code> field.</dd>
</dl>
<h3 id="output-options"><a class="header" href="#output-options">Output Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-bench---target-dir"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</dd>
</dl>
<h3 id="display-options-1"><a class="header" href="#display-options-1">Display Options</a></h3>
<p>默认情况下，Rust 测试工具会隐藏基准测试执行的输出，以保持结果的可读性。基准测试输出可以通过以下方式恢复（例如，用于调试）<code>--nocapture</code>对于基准二进制文件：</p>
<pre><code>cargo bench -- --nocapture
</code></pre>
<dl>
<dt class="option-term" id="option-cargo-bench--v"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-bench---verbose"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-bench--q"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-bench---quiet"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-bench---color"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-bench---message-format"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the &quot;short&quot; rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc's default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics in
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo's own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul></dd>
</dl>
<h3 id="manifest-options-1"><a class="header" href="#manifest-options-1">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-bench---manifest-path"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-bench---frozen"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-bench---locked"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-bench---offline"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-1"><a class="header" href="#common-options-1">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-bench-+toolchain"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-bench--h"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-bench---help"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-bench--Z"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h3 id="miscellaneous-options"><a class="header" href="#miscellaneous-options">Miscellaneous Options</a></h3>
<p>这个<code>--jobs</code>参数影响基准可执行文件的构建，但不影响运行基准时使用的线程数。防锈测试 harness 在单螺纹中连续运行。</p>
<dl>
<dt class="option-term" id="option-cargo-bench--j"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-bench---jobs"><a class="option-anchor" href="commands/cargo-bench.zh.html#option-cargo-bench---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of CPUs.</dd>
</dl>
<h2 id="environment-1"><a class="header" href="#environment-1">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.html">the reference</a>有关 Cargo 读取的环境变量的详细信息。</p>
<h2 id="exit-status-1"><a class="header" href="#exit-status-1">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>：Cargo 成功。</li>
<li><code>101</code>：Cargo 未能完成。</li>
</ul>
<h2 id="examples-5"><a class="header" href="#examples-5">EXAMPLES</a></h2>
<ol>
<li>
<p>构建并执行当前软件包的所有基准：</p>
<p>货台</p>
</li>
<li>
<p>仅在特定基准目标内运行特定基准：</p>
<p>货梯——梯梯台_名称——modname:：一些_基准</p>
</li>
</ol>
<h2 id="see-also-3"><a class="header" href="#see-also-3">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a>, <a href="commands/cargo-test.html">cargo-test(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-build1"><a class="header" href="#cargo-build1">cargo-build(1)</a></h1>
<h2 id="name-4"><a class="header" href="#name-4">NAME</a></h2>
<p>Cargo构建-编译当前包</p>
<h2 id="synopsis-4"><a class="header" href="#synopsis-4">SYNOPSIS</a></h2>
<p><code>cargo build</code> [<em>options</em>]</p>
<h2 id="description-4"><a class="header" href="#description-4">DESCRIPTION</a></h2>
<p>编译本地包及其所有依赖项。</p>
<h2 id="options-3"><a class="header" href="#options-3">OPTIONS</a></h2>
<h3 id="package-selection-3"><a class="header" href="#package-selection-3">Package Selection</a></h3>
<p>默认情况下，如果未提供包选择选项，则选择的包取决于选择的清单文件（如果需要，则基于当前工作目录）<code>--manifest-path</code>未给出）。如果清单是工作区的根目录，则会选择工作区默认成员，否则只会选择清单定义的包。</p>
<p>可以使用<code>workspace.default-members</code>输入根清单。如果未设置，虚拟工作区将包括所有工作区成员（相当于传递）<code>--workspace</code>)，非虚拟工作区将只包括根箱子本身。</p>
<dl>
<dt class="option-term" id="option-cargo-build--p"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-build---package"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Build only the specified packages. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the
SPEC format. This flag may be specified multiple times and supports common Unix
glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell accidentally 
expanding glob patterns before Cargo handles them, you must use single quotes or
double quotes around each pattern.</dd>
<dt class="option-term" id="option-cargo-build---workspace"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">Build all members in the workspace.</dd>
<dt class="option-term" id="option-cargo-build---all"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---all"></a><code>--all</code></dt>
<dd class="option-desc">Deprecated alias for <code>--workspace</code>.</dd>
<dt class="option-term" id="option-cargo-build---exclude"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---exclude"></a><code>--exclude</code> <em>SPEC</em>...</dt>
<dd class="option-desc">Exclude the specified packages. Must be used in conjunction with the
<code>--workspace</code> flag. This flag may be specified multiple times and supports
common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell
accidentally expanding glob patterns before Cargo handles them, you must use
single quotes or double quotes around each pattern.</dd>
</dl>
<h3 id="target-selection-1"><a class="header" href="#target-selection-1">Target Selection</a></h3>
<p>当没有给出目标选择选项时，<code>cargo build</code>将生成所选包的所有二进制和库目标。如果有二进制文件，则跳过它们<code>required-features</code>这些都不见了。</p>
<p>传递目标选择标志将只生成指定的目标。</p>
<p>注意<code>--bin</code>, <code>--example</code>, <code>--test</code>和<code>--bench</code>标志还支持常见的Unix全局模式，如<code>*</code>, <code>?</code>和<code>[]</code>但是，为了避免您的shell在Cargo处理glob模式之前意外地扩展glob模式，您必须在每个glob模式周围使用单引号或双引号。</p>
<dl>
<dt class="option-term" id="option-cargo-build---lib"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---lib"></a><code>--lib</code></dt>
<dd class="option-desc">Build the package's library.</dd>
<dt class="option-term" id="option-cargo-build---bin"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">Build the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-build---bins"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---bins"></a><code>--bins</code></dt>
<dd class="option-desc">Build all binary targets.</dd>
<dt class="option-term" id="option-cargo-build---example"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---example"></a><code>--example</code> <em>name</em>...</dt>
<dd class="option-desc">Build the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-build---examples"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---examples"></a><code>--examples</code></dt>
<dd class="option-desc">Build all example targets.</dd>
<dt class="option-term" id="option-cargo-build---test"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---test"></a><code>--test</code> <em>name</em>...</dt>
<dd class="option-desc">Build the specified integration test. This flag may be specified
multiple times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-build---tests"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---tests"></a><code>--tests</code></dt>
<dd class="option-desc">Build all targets in test mode that have the <code>test = true</code> manifest
flag set. By default this includes the library and binaries built as
unittests, and integration tests. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
unittest, and once as a dependency for binaries, integration tests, etc.).
Targets may be enabled or disabled by setting the <code>test</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-build---bench"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---bench"></a><code>--bench</code> <em>name</em>...</dt>
<dd class="option-desc">Build the specified benchmark. This flag may be specified multiple
times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-build---benches"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---benches"></a><code>--benches</code></dt>
<dd class="option-desc">Build all targets in benchmark mode that have the <code>bench = true</code>
manifest flag set. By default this includes the library and binaries built
as benchmarks, and bench targets. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
benchmark, and once as a dependency for binaries, benchmarks, etc.).
Targets may be enabled or disabled by setting the <code>bench</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-build---all-targets"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---all-targets"></a><code>--all-targets</code></dt>
<dd class="option-desc">Build all targets. This is equivalent to specifying <code>--lib --bins --tests --benches --examples</code>.</dd>
</dl>
<h3 id="feature-selection-1"><a class="header" href="#feature-selection-1">Feature Selection</a></h3>
<p>功能标志允许您控制启用哪些功能。如果未提供任何功能选项，则<code>default</code>为每个选定的软件包激活该功能。</p>
<p>查看<a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>更多细节。</p>
<dl>
<dt class="option-term" id="option-cargo-build---features"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</dd>
<dt class="option-term" id="option-cargo-build---all-features"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">Activate all available features of all selected packages.</dd>
<dt class="option-term" id="option-cargo-build---no-default-features"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">Do not activate the <code>default</code> feature of the selected packages.</dd>
</dl>
<h3 id="compilation-options-1"><a class="header" href="#compilation-options-1">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-build---target"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Build for the given architecture. The default is the host
architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>. Run <code>rustc --print target-list</code> for a
list of supported targets.</p>
<p>This may also be specified with the <code>build.target</code>
<a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../guide/build-cache.html">build cache</a> documentation for more details.</dd>
<dt class="option-term" id="option-cargo-build--r"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build--r"></a><code>-r</code></dt>
<dt class="option-term" id="option-cargo-build---release"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---release"></a><code>--release</code></dt>
<dd class="option-desc">Build optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</dd>
<dt class="option-term" id="option-cargo-build---profile"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Build with the given profile.
See the <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</dd>
<dt class="option-term" id="option-cargo-build---ignore-rust-version"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---ignore-rust-version"></a><code>--ignore-rust-version</code></dt>
<dd class="option-desc">Build the target even if the selected Rust compiler is older than the
required Rust version as configured in the project's <code>rust-version</code> field.</dd>
</dl>
<h3 id="output-options-1"><a class="header" href="#output-options-1">Output Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-build---target-dir"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</dd>
<dt class="option-term" id="option-cargo-build---out-dir"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---out-dir"></a><code>--out-dir</code> <em>directory</em></dt>
<dd class="option-desc">Copy final artifacts to this directory.</p>
<p>This option is unstable and available only on the
<a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly channel</a>
and requires the <code>-Z unstable-options</code> flag to enable.
See <a href="https://github.com/rust-lang/cargo/issues/6790">https://github.com/rust-lang/cargo/issues/6790</a> for more information.</dd>
</dl>
<h3 id="display-options-2"><a class="header" href="#display-options-2">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-build--v"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-build---verbose"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-build--q"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-build---quiet"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-build---color"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-build---message-format"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the &quot;short&quot; rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc's default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics in
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo's own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul></dd>
<dt class="option-term" id="option-cargo-build---build-plan"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---build-plan"></a><code>--build-plan</code></dt>
<dd class="option-desc">Outputs a series of JSON messages to stdout that indicate the commands to run
the build.</p>
<p>This option is unstable and available only on the
<a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly channel</a>
and requires the <code>-Z unstable-options</code> flag to enable.
See <a href="https://github.com/rust-lang/cargo/issues/5579">https://github.com/rust-lang/cargo/issues/5579</a> for more information.</dd>
</dl>
<h3 id="manifest-options-2"><a class="header" href="#manifest-options-2">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-build---manifest-path"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-build---frozen"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-build---locked"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-build---offline"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-2"><a class="header" href="#common-options-2">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-build-+toolchain"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-build--h"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-build---help"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-build--Z"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h3 id="miscellaneous-options-1"><a class="header" href="#miscellaneous-options-1">Miscellaneous Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-build--j"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-build---jobs"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of CPUs.</dd>
<dt class="option-term" id="option-cargo-build---future-incompat-report"><a class="option-anchor" href="commands/cargo-build.zh.html#option-cargo-build---future-incompat-report"></a><code>--future-incompat-report</code></dt>
<dd class="option-desc">Displays a future-incompat report for any future-incompatible warnings
produced during execution of this command</p>
<p>See <a href="commands/cargo-report.html">cargo-report(1)</a></dd>
</dl>
<h2 id="environment-2"><a class="header" href="#environment-2">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.html">the reference</a>有关Cargo读取的环境变量的详细信息。</p>
<h2 id="exit-status-2"><a class="header" href="#exit-status-2">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>：Cargo成功。</li>
<li><code>101</code>：Cargo未能完成。</li>
</ul>
<h2 id="examples-6"><a class="header" href="#examples-6">EXAMPLES</a></h2>
<ol>
<li>
<p>构建本地包及其所有依赖项：</p>
<p>Cargo建造</p>
</li>
<li>
<p>通过优化构建：</p>
<p>Cargo建造——放行</p>
</li>
</ol>
<h2 id="see-also-4"><a class="header" href="#see-also-4">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a>, <a href="commands/cargo-rustc.html">cargo-rustc(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-check1"><a class="header" href="#cargo-check1">cargo-check(1)</a></h1>
<h2 id="name-5"><a class="header" href="#name-5">NAME</a></h2>
<p>Cargo检查-检查当前包裹</p>
<h2 id="synopsis-5"><a class="header" href="#synopsis-5">SYNOPSIS</a></h2>
<p><code>cargo check</code> [<em>options</em>]</p>
<h2 id="description-5"><a class="header" href="#description-5">DESCRIPTION</a></h2>
<p>检查本地包及其所有依赖项是否存在错误。这将基本上编译包，而不执行代码生成的最后一步，这比运行<code>cargo build</code>。编译器将元数据文件保存到磁盘，以便在源代码未被修改的情况下，将来的运行将重用它们。一些诊断和错误只在代码生成期间发出，因此它们本质上不会被报告<code>cargo check</code>.</p>
<h2 id="options-4"><a class="header" href="#options-4">OPTIONS</a></h2>
<h3 id="package-selection-4"><a class="header" href="#package-selection-4">Package Selection</a></h3>
<p>默认情况下，如果未提供包选择选项，则选择的包取决于选择的清单文件（如果需要，则基于当前工作目录）<code>--manifest-path</code>未给出）。如果清单是工作区的根目录，则会选择工作区默认成员，否则只会选择清单定义的包。</p>
<p>可以使用<code>workspace.default-members</code>输入根清单。如果未设置，虚拟工作区将包括所有工作区成员（相当于传递）<code>--workspace</code>)，非虚拟工作区将只包括根箱子本身。</p>
<dl>
<dt class="option-term" id="option-cargo-check--p"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-check---package"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Check only the specified packages. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the
SPEC format. This flag may be specified multiple times and supports common Unix
glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell accidentally 
expanding glob patterns before Cargo handles them, you must use single quotes or
double quotes around each pattern.</dd>
<dt class="option-term" id="option-cargo-check---workspace"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">Check all members in the workspace.</dd>
<dt class="option-term" id="option-cargo-check---all"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---all"></a><code>--all</code></dt>
<dd class="option-desc">Deprecated alias for <code>--workspace</code>.</dd>
<dt class="option-term" id="option-cargo-check---exclude"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---exclude"></a><code>--exclude</code> <em>SPEC</em>...</dt>
<dd class="option-desc">Exclude the specified packages. Must be used in conjunction with the
<code>--workspace</code> flag. This flag may be specified multiple times and supports
common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell
accidentally expanding glob patterns before Cargo handles them, you must use
single quotes or double quotes around each pattern.</dd>
</dl>
<h3 id="target-selection-2"><a class="header" href="#target-selection-2">Target Selection</a></h3>
<p>当没有给出目标选择选项时，<code>cargo check</code>将检查所选包的所有二进制和库目标。如果有二进制文件，则跳过它们<code>required-features</code>这些都不见了。</p>
<p>传递目标选择标志将仅检查指定的目标。</p>
<p>注意<code>--bin</code>, <code>--example</code>, <code>--test</code>和<code>--bench</code>标志还支持常见的Unix全局模式，如<code>*</code>, <code>?</code>和<code>[]</code>但是，为了避免您的shell在Cargo处理glob模式之前意外地扩展glob模式，您必须在每个glob模式周围使用单引号或双引号。</p>
<dl>
<dt class="option-term" id="option-cargo-check---lib"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---lib"></a><code>--lib</code></dt>
<dd class="option-desc">Check the package's library.</dd>
<dt class="option-term" id="option-cargo-check---bin"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">Check the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-check---bins"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---bins"></a><code>--bins</code></dt>
<dd class="option-desc">Check all binary targets.</dd>
<dt class="option-term" id="option-cargo-check---example"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---example"></a><code>--example</code> <em>name</em>...</dt>
<dd class="option-desc">Check the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-check---examples"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---examples"></a><code>--examples</code></dt>
<dd class="option-desc">Check all example targets.</dd>
<dt class="option-term" id="option-cargo-check---test"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---test"></a><code>--test</code> <em>name</em>...</dt>
<dd class="option-desc">Check the specified integration test. This flag may be specified
multiple times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-check---tests"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---tests"></a><code>--tests</code></dt>
<dd class="option-desc">Check all targets in test mode that have the <code>test = true</code> manifest
flag set. By default this includes the library and binaries built as
unittests, and integration tests. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
unittest, and once as a dependency for binaries, integration tests, etc.).
Targets may be enabled or disabled by setting the <code>test</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-check---bench"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---bench"></a><code>--bench</code> <em>name</em>...</dt>
<dd class="option-desc">Check the specified benchmark. This flag may be specified multiple
times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-check---benches"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---benches"></a><code>--benches</code></dt>
<dd class="option-desc">Check all targets in benchmark mode that have the <code>bench = true</code>
manifest flag set. By default this includes the library and binaries built
as benchmarks, and bench targets. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
benchmark, and once as a dependency for binaries, benchmarks, etc.).
Targets may be enabled or disabled by setting the <code>bench</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-check---all-targets"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---all-targets"></a><code>--all-targets</code></dt>
<dd class="option-desc">Check all targets. This is equivalent to specifying <code>--lib --bins --tests --benches --examples</code>.</dd>
</dl>
<h3 id="feature-selection-2"><a class="header" href="#feature-selection-2">Feature Selection</a></h3>
<p>功能标志允许您控制启用哪些功能。如果未提供任何功能选项，则<code>default</code>为每个选定的软件包激活该功能。</p>
<p>查看<a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>更多细节。</p>
<dl>
<dt class="option-term" id="option-cargo-check---features"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</dd>
<dt class="option-term" id="option-cargo-check---all-features"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">Activate all available features of all selected packages.</dd>
<dt class="option-term" id="option-cargo-check---no-default-features"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">Do not activate the <code>default</code> feature of the selected packages.</dd>
</dl>
<h3 id="compilation-options-2"><a class="header" href="#compilation-options-2">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-check---target"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Check for the given architecture. The default is the host
architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>. Run <code>rustc --print target-list</code> for a
list of supported targets.</p>
<p>This may also be specified with the <code>build.target</code>
<a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../guide/build-cache.html">build cache</a> documentation for more details.</dd>
<dt class="option-term" id="option-cargo-check--r"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check--r"></a><code>-r</code></dt>
<dt class="option-term" id="option-cargo-check---release"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---release"></a><code>--release</code></dt>
<dd class="option-desc">Check optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</dd>
<dt class="option-term" id="option-cargo-check---profile"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Check with the given profile.</p>
<p>As a special case, specifying the <code>test</code> profile will also enable checking in
test mode which will enable checking tests and enable the <code>test</code> cfg option.
See <a href="https://doc.rust-lang.org/rustc/tests/index.html">rustc tests</a> for more
detail.</p>
<p>See the <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</dd>
<dt class="option-term" id="option-cargo-check---ignore-rust-version"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---ignore-rust-version"></a><code>--ignore-rust-version</code></dt>
<dd class="option-desc">Check the target even if the selected Rust compiler is older than the
required Rust version as configured in the project's <code>rust-version</code> field.</dd>
</dl>
<h3 id="output-options-2"><a class="header" href="#output-options-2">Output Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-check---target-dir"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</dd>
</dl>
<h3 id="display-options-3"><a class="header" href="#display-options-3">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-check--v"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-check---verbose"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-check--q"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-check---quiet"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-check---color"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-check---message-format"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the &quot;short&quot; rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc's default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics in
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo's own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul></dd>
</dl>
<h3 id="manifest-options-3"><a class="header" href="#manifest-options-3">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-check---manifest-path"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-check---frozen"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-check---locked"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-check---offline"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-3"><a class="header" href="#common-options-3">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-check-+toolchain"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-check--h"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-check---help"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-check--Z"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h3 id="miscellaneous-options-2"><a class="header" href="#miscellaneous-options-2">Miscellaneous Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-check--j"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-check---jobs"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of CPUs.</dd>
<dt class="option-term" id="option-cargo-check---future-incompat-report"><a class="option-anchor" href="commands/cargo-check.zh.html#option-cargo-check---future-incompat-report"></a><code>--future-incompat-report</code></dt>
<dd class="option-desc">Displays a future-incompat report for any future-incompatible warnings
produced during execution of this command</p>
<p>See <a href="commands/cargo-report.html">cargo-report(1)</a></dd>
</dl>
<h2 id="environment-3"><a class="header" href="#environment-3">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.html">the reference</a>有关Cargo读取的环境变量的详细信息。</p>
<h2 id="exit-status-3"><a class="header" href="#exit-status-3">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>：Cargo成功。</li>
<li><code>101</code>：Cargo未能完成。</li>
</ul>
<h2 id="examples-7"><a class="header" href="#examples-7">EXAMPLES</a></h2>
<ol>
<li>
<p>检查本地包是否存在错误：</p>
<p>Cargo检查</p>
</li>
<li>
<p>检查所有目标，包括单元测试：</p>
<p>Cargo检查——所有目标——外形=测试</p>
</li>
</ol>
<h2 id="see-also-5"><a class="header" href="#see-also-5">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a>, <a href="commands/cargo-build.html">cargo-build(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-clean1"><a class="header" href="#cargo-clean1">cargo-clean(1)</a></h1>
<h2 id="name-6"><a class="header" href="#name-6">NAME</a></h2>
<p>Cargo清理-移除生成的工件</p>
<h2 id="synopsis-6"><a class="header" href="#synopsis-6">SYNOPSIS</a></h2>
<p><code>cargo clean</code> [<em>options</em>]</p>
<h2 id="description-6"><a class="header" href="#description-6">DESCRIPTION</a></h2>
<p>从Cargo过去生成的目标目录中删除工件。</p>
<p>别无选择，<code>cargo clean</code>将删除整个目标目录。</p>
<h2 id="options-5"><a class="header" href="#options-5">OPTIONS</a></h2>
<h3 id="package-selection-5"><a class="header" href="#package-selection-5">Package Selection</a></h3>
<p>如果未选择任何包，则会清除工作区中的所有包和所有依赖项。</p>
<dl>
<dt class="option-term" id="option-cargo-clean--p"><a class="option-anchor" href="commands/cargo-clean.zh.html#option-cargo-clean--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-clean---package"><a class="option-anchor" href="commands/cargo-clean.zh.html#option-cargo-clean---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Clean only the specified packages. This flag may be specified
multiple times. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the SPEC format.</dd>
</dl>
<h3 id="clean-options"><a class="header" href="#clean-options">Clean Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-clean---doc"><a class="option-anchor" href="commands/cargo-clean.zh.html#option-cargo-clean---doc"></a><code>--doc</code></dt>
<dd class="option-desc">This option will cause <code>cargo clean</code> to remove only the <code>doc</code> directory in
the target directory.</dd>
<dt class="option-term" id="option-cargo-clean---release"><a class="option-anchor" href="commands/cargo-clean.zh.html#option-cargo-clean---release"></a><code>--release</code></dt>
<dd class="option-desc">Remove all artifacts in the <code>release</code> directory.</dd>
<dt class="option-term" id="option-cargo-clean---profile"><a class="option-anchor" href="commands/cargo-clean.zh.html#option-cargo-clean---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Remove all artifacts in the directory with the given profile name.</dd>
<dt class="option-term" id="option-cargo-clean---target-dir"><a class="option-anchor" href="commands/cargo-clean.zh.html#option-cargo-clean---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</dd>
<dt class="option-term" id="option-cargo-clean---target"><a class="option-anchor" href="commands/cargo-clean.zh.html#option-cargo-clean---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Clean for the given architecture. The default is the host
architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>. Run <code>rustc --print target-list</code> for a
list of supported targets.</p>
<p>This may also be specified with the <code>build.target</code>
<a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../guide/build-cache.html">build cache</a> documentation for more details.</dd>
</dl>
<h3 id="display-options-4"><a class="header" href="#display-options-4">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-clean--v"><a class="option-anchor" href="commands/cargo-clean.zh.html#option-cargo-clean--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-clean---verbose"><a class="option-anchor" href="commands/cargo-clean.zh.html#option-cargo-clean---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-clean--q"><a class="option-anchor" href="commands/cargo-clean.zh.html#option-cargo-clean--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-clean---quiet"><a class="option-anchor" href="commands/cargo-clean.zh.html#option-cargo-clean---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-clean---color"><a class="option-anchor" href="commands/cargo-clean.zh.html#option-cargo-clean---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="manifest-options-4"><a class="header" href="#manifest-options-4">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-clean---manifest-path"><a class="option-anchor" href="commands/cargo-clean.zh.html#option-cargo-clean---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-clean---frozen"><a class="option-anchor" href="commands/cargo-clean.zh.html#option-cargo-clean---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-clean---locked"><a class="option-anchor" href="commands/cargo-clean.zh.html#option-cargo-clean---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-clean---offline"><a class="option-anchor" href="commands/cargo-clean.zh.html#option-cargo-clean---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-4"><a class="header" href="#common-options-4">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-clean-+toolchain"><a class="option-anchor" href="commands/cargo-clean.zh.html#option-cargo-clean-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-clean--h"><a class="option-anchor" href="commands/cargo-clean.zh.html#option-cargo-clean--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-clean---help"><a class="option-anchor" href="commands/cargo-clean.zh.html#option-cargo-clean---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-clean--Z"><a class="option-anchor" href="commands/cargo-clean.zh.html#option-cargo-clean--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-4"><a class="header" href="#environment-4">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.html">the reference</a>有关Cargo读取的环境变量的详细信息。</p>
<h2 id="exit-status-4"><a class="header" href="#exit-status-4">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>：Cargo成功。</li>
<li><code>101</code>：Cargo未能完成。</li>
</ul>
<h2 id="examples-8"><a class="header" href="#examples-8">EXAMPLES</a></h2>
<ol>
<li>
<p>删除整个目标目录：</p>
<p>Cargo清洁</p>
</li>
<li>
<p>仅删除发布工件：</p>
<p>Cargo清洁-放行</p>
</li>
</ol>
<h2 id="see-also-6"><a class="header" href="#see-also-6">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a>, <a href="commands/cargo-build.html">cargo-build(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-doc1"><a class="header" href="#cargo-doc1">cargo-doc(1)</a></h1>
<h2 id="name-7"><a class="header" href="#name-7">NAME</a></h2>
<p>Cargo文件-生成包裹的文件</p>
<h2 id="synopsis-7"><a class="header" href="#synopsis-7">SYNOPSIS</a></h2>
<p><code>cargo doc</code> [<em>options</em>]</p>
<h2 id="description-7"><a class="header" href="#description-7">DESCRIPTION</a></h2>
<p>为本地包和所有依赖项构建文档。输出被放入<code>target/doc</code>以rustdoc的常规格式。</p>
<h2 id="options-6"><a class="header" href="#options-6">OPTIONS</a></h2>
<h3 id="documentation-options"><a class="header" href="#documentation-options">Documentation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-doc---open"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---open"></a><code>--open</code></dt>
<dd class="option-desc">Open the docs in a browser after building them. This will use your default
browser unless you define another one in the <code>BROWSER</code> environment variable
or use the <a href="commands/../reference/config.html#docbrowser"><code>doc.browser</code></a> configuration
option.</dd>
<dt class="option-term" id="option-cargo-doc---no-deps"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---no-deps"></a><code>--no-deps</code></dt>
<dd class="option-desc">Do not build documentation for dependencies.</dd>
<dt class="option-term" id="option-cargo-doc---document-private-items"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---document-private-items"></a><code>--document-private-items</code></dt>
<dd class="option-desc">Include non-public items in the documentation. This will be enabled by default if documenting a binary target.</dd>
</dl>
<h3 id="package-selection-6"><a class="header" href="#package-selection-6">Package Selection</a></h3>
<p>默认情况下，如果未提供包选择选项，则选择的包取决于选择的清单文件（如果需要，则基于当前工作目录）<code>--manifest-path</code>未给出）。如果清单是工作区的根目录，则会选择工作区默认成员，否则只会选择清单定义的包。</p>
<p>可以使用<code>workspace.default-members</code>输入根清单。如果未设置，虚拟工作区将包括所有工作区成员（相当于传递）<code>--workspace</code>)，非虚拟工作区将只包括根箱子本身。</p>
<dl>
<dt class="option-term" id="option-cargo-doc--p"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-doc---package"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Document only the specified packages. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the
SPEC format. This flag may be specified multiple times and supports common Unix
glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell accidentally 
expanding glob patterns before Cargo handles them, you must use single quotes or
double quotes around each pattern.</dd>
<dt class="option-term" id="option-cargo-doc---workspace"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">Document all members in the workspace.</dd>
<dt class="option-term" id="option-cargo-doc---all"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---all"></a><code>--all</code></dt>
<dd class="option-desc">Deprecated alias for <code>--workspace</code>.</dd>
<dt class="option-term" id="option-cargo-doc---exclude"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---exclude"></a><code>--exclude</code> <em>SPEC</em>...</dt>
<dd class="option-desc">Exclude the specified packages. Must be used in conjunction with the
<code>--workspace</code> flag. This flag may be specified multiple times and supports
common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell
accidentally expanding glob patterns before Cargo handles them, you must use
single quotes or double quotes around each pattern.</dd>
</dl>
<h3 id="target-selection-3"><a class="header" href="#target-selection-3">Target Selection</a></h3>
<p>当没有给出目标选择选项时，<code>cargo doc</code>将记录所选包的所有二进制和库目标。如果二进制文件的名称与lib目标文件相同，则将跳过该二进制文件。如果有二进制文件，则跳过它们<code>required-features</code>这些都不见了。</p>
<p>默认行为可以通过设置<code>doc = false</code>对于清单设置中的目标。使用目标选择选项将忽略<code>doc</code>标记并将始终记录给定的目标。</p>
<dl>
<dt class="option-term" id="option-cargo-doc---lib"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---lib"></a><code>--lib</code></dt>
<dd class="option-desc">Document the package's library.</dd>
<dt class="option-term" id="option-cargo-doc---bin"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">Document the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-doc---bins"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---bins"></a><code>--bins</code></dt>
<dd class="option-desc">Document all binary targets.</dd>
<dt class="option-term" id="option-cargo-doc---example"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---example"></a><code>--example</code> <em>name</em>...</dt>
<dd class="option-desc">Document the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-doc---examples"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---examples"></a><code>--examples</code></dt>
<dd class="option-desc">Document all example targets.</dd>
</dl>
<h3 id="feature-selection-3"><a class="header" href="#feature-selection-3">Feature Selection</a></h3>
<p>功能标志允许您控制启用哪些功能。如果未提供任何功能选项，则<code>default</code>为每个选定的软件包激活该功能。</p>
<p>查看<a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>更多细节。</p>
<dl>
<dt class="option-term" id="option-cargo-doc---features"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</dd>
<dt class="option-term" id="option-cargo-doc---all-features"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">Activate all available features of all selected packages.</dd>
<dt class="option-term" id="option-cargo-doc---no-default-features"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">Do not activate the <code>default</code> feature of the selected packages.</dd>
</dl>
<h3 id="compilation-options-3"><a class="header" href="#compilation-options-3">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-doc---target"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Document for the given architecture. The default is the host
architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>. Run <code>rustc --print target-list</code> for a
list of supported targets.</p>
<p>This may also be specified with the <code>build.target</code>
<a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../guide/build-cache.html">build cache</a> documentation for more details.</dd>
<dt class="option-term" id="option-cargo-doc--r"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc--r"></a><code>-r</code></dt>
<dt class="option-term" id="option-cargo-doc---release"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---release"></a><code>--release</code></dt>
<dd class="option-desc">Document optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</dd>
<dt class="option-term" id="option-cargo-doc---profile"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Document with the given profile.
See the <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</dd>
<dt class="option-term" id="option-cargo-doc---ignore-rust-version"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---ignore-rust-version"></a><code>--ignore-rust-version</code></dt>
<dd class="option-desc">Document the target even if the selected Rust compiler is older than the
required Rust version as configured in the project's <code>rust-version</code> field.</dd>
</dl>
<h3 id="output-options-3"><a class="header" href="#output-options-3">Output Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-doc---target-dir"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</dd>
</dl>
<h3 id="display-options-5"><a class="header" href="#display-options-5">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-doc--v"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-doc---verbose"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-doc--q"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-doc---quiet"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-doc---color"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-doc---message-format"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the &quot;short&quot; rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc's default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics in
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo's own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul></dd>
</dl>
<h3 id="manifest-options-5"><a class="header" href="#manifest-options-5">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-doc---manifest-path"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-doc---frozen"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-doc---locked"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-doc---offline"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-5"><a class="header" href="#common-options-5">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-doc-+toolchain"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-doc--h"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-doc---help"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-doc--Z"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h3 id="miscellaneous-options-3"><a class="header" href="#miscellaneous-options-3">Miscellaneous Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-doc--j"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-doc---jobs"><a class="option-anchor" href="commands/cargo-doc.zh.html#option-cargo-doc---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of CPUs.</dd>
</dl>
<h2 id="environment-5"><a class="header" href="#environment-5">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.html">the reference</a>有关Cargo读取的环境变量的详细信息。</p>
<h2 id="exit-status-5"><a class="header" href="#exit-status-5">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>：Cargo成功。</li>
<li><code>101</code>：Cargo未能完成。</li>
</ul>
<h2 id="examples-9"><a class="header" href="#examples-9">EXAMPLES</a></h2>
<ol>
<li>
<p>构建本地包文档及其依赖项，并将其输出到<code>target/doc</code>.</p>
<pre><code>cargo doc
</code></pre>
</li>
</ol>
<h2 id="see-also-7"><a class="header" href="#see-also-7">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a>, <a href="commands/cargo-rustdoc.html">cargo-rustdoc(1)</a>, <a href="https://doc.rust-lang.org/rustdoc/index.html">rustdoc(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-fetch1"><a class="header" href="#cargo-fetch1">cargo-fetch(1)</a></h1>
<h2 id="name-8"><a class="header" href="#name-8">NAME</a></h2>
<p>cargo fetch（Cargo提取）-从网络中提取包裹的依赖项</p>
<h2 id="synopsis-8"><a class="header" href="#synopsis-8">SYNOPSIS</a></h2>
<p><code>cargo fetch</code> [<em>options</em>]</p>
<h2 id="description-8"><a class="header" href="#description-8">DESCRIPTION</a></h2>
<p>如果<code>Cargo.lock</code>如果文件可用，此命令将确保所有git依赖项和/或注册表依赖项都已下载并在本地可用。随后的货运命令在发生故障后不会接触网络<code>cargo fetch</code>除非锁文件更改。</p>
<p>如果锁文件不可用，则此命令将在获取依赖项之前生成锁文件。</p>
<p>如果<code>--target</code>如果未指定，则将获取所有目标依赖项。</p>
<p>另见<a href="https://crates.io/crates/cargo-prefetch">cargo-prefetch</a>插件，它添加了一个命令来下载流行的箱子。如果您计划在没有网络的情况下使用Cargo<code>--offline</code>选项</p>
<h2 id="options-7"><a class="header" href="#options-7">OPTIONS</a></h2>
<h3 id="fetch-options"><a class="header" href="#fetch-options">Fetch options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fetch---target"><a class="option-anchor" href="commands/cargo-fetch.zh.html#option-cargo-fetch---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Fetch for the given architecture. The default is the host
architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>. Run <code>rustc --print target-list</code> for a
list of supported targets.</p>
<p>This may also be specified with the <code>build.target</code>
<a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../guide/build-cache.html">build cache</a> documentation for more details.</dd>
</dl>
<h3 id="display-options-6"><a class="header" href="#display-options-6">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fetch--v"><a class="option-anchor" href="commands/cargo-fetch.zh.html#option-cargo-fetch--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-fetch---verbose"><a class="option-anchor" href="commands/cargo-fetch.zh.html#option-cargo-fetch---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-fetch--q"><a class="option-anchor" href="commands/cargo-fetch.zh.html#option-cargo-fetch--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-fetch---quiet"><a class="option-anchor" href="commands/cargo-fetch.zh.html#option-cargo-fetch---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-fetch---color"><a class="option-anchor" href="commands/cargo-fetch.zh.html#option-cargo-fetch---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="manifest-options-6"><a class="header" href="#manifest-options-6">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fetch---manifest-path"><a class="option-anchor" href="commands/cargo-fetch.zh.html#option-cargo-fetch---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-fetch---frozen"><a class="option-anchor" href="commands/cargo-fetch.zh.html#option-cargo-fetch---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-fetch---locked"><a class="option-anchor" href="commands/cargo-fetch.zh.html#option-cargo-fetch---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-fetch---offline"><a class="option-anchor" href="commands/cargo-fetch.zh.html#option-cargo-fetch---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-6"><a class="header" href="#common-options-6">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fetch-+toolchain"><a class="option-anchor" href="commands/cargo-fetch.zh.html#option-cargo-fetch-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-fetch--h"><a class="option-anchor" href="commands/cargo-fetch.zh.html#option-cargo-fetch--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-fetch---help"><a class="option-anchor" href="commands/cargo-fetch.zh.html#option-cargo-fetch---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-fetch--Z"><a class="option-anchor" href="commands/cargo-fetch.zh.html#option-cargo-fetch--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-6"><a class="header" href="#environment-6">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.html">the reference</a>有关Cargo读取的环境变量的详细信息。</p>
<h2 id="exit-status-6"><a class="header" href="#exit-status-6">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>：Cargo成功。</li>
<li><code>101</code>：Cargo未能完成。</li>
</ul>
<h2 id="examples-10"><a class="header" href="#examples-10">EXAMPLES</a></h2>
<ol>
<li>
<p>获取所有依赖项：</p>
<p>提货</p>
</li>
</ol>
<h2 id="see-also-8"><a class="header" href="#see-also-8">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a>, <a href="commands/cargo-update.html">cargo-update(1)</a>, <a href="commands/cargo-generate-lockfile.html">cargo-generate-lockfile(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-fix1"><a class="header" href="#cargo-fix1">cargo-fix(1)</a></h1>
<h2 id="name-9"><a class="header" href="#name-9">NAME</a></h2>
<p>Cargo修复-自动修复rustc报告的线头警告</p>
<h2 id="synopsis-9"><a class="header" href="#synopsis-9">SYNOPSIS</a></h2>
<p><code>cargo fix</code> [<em>options</em>]</p>
<h2 id="description-9"><a class="header" href="#description-9">DESCRIPTION</a></h2>
<p>这个Cargo子命令将自动从诸如警告之类的诊断中获取rustc的建议，并将其应用到源代码中。这是为了帮助自动化任务，而rustc本身已经知道如何告诉您修复这些任务！</p>
<p>执行<code>cargo fix</code>引擎盖下会执行吗<a href="commands/cargo-check.html">cargo-check(1)</a>。适用于您的箱子的任何警告都将自动修复（如果可能），并且在检查过程完成后，将显示所有剩余的警告。例如，如果要对当前包应用所有修复程序，可以运行：</p>
<pre><code>cargo fix
</code></pre>
<p>其行为与<code>cargo check --all-targets</code>.</p>
<p><code>cargo fix</code>只能修复通常使用<code>cargo check</code>。如果代码有条件地启用了可选功能，则需要启用这些功能才能分析该代码：</p>
<pre><code>cargo fix --features foo
</code></pre>
<p>同样，其他<code>cfg</code>特定于平台的代码等表达式需要传递<code>--target</code>修复给定目标的代码。</p>
<pre><code>cargo fix --target x86_64-pc-windows-gnu
</code></pre>
<p>如果你遇到任何问题<code>cargo fix</code>如果您有任何问题或功能要求，请随时向<a href="https://github.com/rust-lang/cargo">https://github.com/rust-lang/cargo</a>.</p>
<h3 id="edition-migration"><a class="header" href="#edition-migration">Edition migration</a></h3>
<p>这个<code>cargo fix</code>子命令还可用于从一个<a href="https://doc.rust-lang.org/edition-guide/editions/transitioning-an-existing-project-to-a-new-edition.html">edition</a>到下一个。一般程序是：</p>
<ol>
<li>跑<code>cargo fix --edition</code>也可以考虑使用<code>--all-features</code>如果项目具有多个功能，请标记。你可能也想跑步<code>cargo fix --edition</code>多次使用不同的<code>--target</code>标记您的项目是否具有特定于平台的代码<code>cfg</code>属性。</li>
<li>修改<code>Cargo.toml</code>设定<a href="commands/../reference/manifest.html#the-edition-field">edition field</a>到新版。</li>
<li>运行您的项目测试，以验证一切仍然有效。如果发出新的警告，您可能需要考虑运行。<code>cargo fix</code>再次（没有<code>--edition</code>标记）以应用编译器给出的任何建议。</li>
</ol>
<p>希望就是这样！记住上面提到的注意事项<code>cargo fix</code>无法更新非活动功能的代码或<code>cfg</code>表达。此外，在某些罕见的情况下，编译器无法自动将所有代码迁移到新版本，这可能需要在使用新版本构建后进行手动更改。</p>
<h2 id="options-8"><a class="header" href="#options-8">OPTIONS</a></h2>
<h3 id="fix-options"><a class="header" href="#fix-options">Fix options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fix---broken-code"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---broken-code"></a><code>--broken-code</code></dt>
<dd class="option-desc">Fix code even if it already has compiler errors. This is useful if <code>cargo fix</code>
fails to apply the changes. It will apply the changes and leave the broken
code in the working directory for you to inspect and manually fix.</dd>
<dt class="option-term" id="option-cargo-fix---edition"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---edition"></a><code>--edition</code></dt>
<dd class="option-desc">Apply changes that will update the code to the next edition. This will not
update the edition in the <code>Cargo.toml</code> manifest, which must be updated
manually after <code>cargo fix --edition</code> has finished.</dd>
<dt class="option-term" id="option-cargo-fix---edition-idioms"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---edition-idioms"></a><code>--edition-idioms</code></dt>
<dd class="option-desc">Apply suggestions that will update code to the preferred style for the current
edition.</dd>
<dt class="option-term" id="option-cargo-fix---allow-no-vcs"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---allow-no-vcs"></a><code>--allow-no-vcs</code></dt>
<dd class="option-desc">Fix code even if a VCS was not detected.</dd>
<dt class="option-term" id="option-cargo-fix---allow-dirty"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---allow-dirty"></a><code>--allow-dirty</code></dt>
<dd class="option-desc">Fix code even if the working directory has changes.</dd>
<dt class="option-term" id="option-cargo-fix---allow-staged"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---allow-staged"></a><code>--allow-staged</code></dt>
<dd class="option-desc">Fix code even if the working directory has staged changes.</dd>
</dl>
<h3 id="package-selection-7"><a class="header" href="#package-selection-7">Package Selection</a></h3>
<p>默认情况下，如果未提供包选择选项，则选择的包取决于选择的清单文件（如果需要，则基于当前工作目录）<code>--manifest-path</code>未给出）。如果清单是工作区的根目录，则会选择工作区默认成员，否则只会选择清单定义的包。</p>
<p>可以使用<code>workspace.default-members</code>输入根清单。如果未设置，虚拟工作区将包括所有工作区成员（相当于传递）<code>--workspace</code>)，非虚拟工作区将只包括根箱子本身。</p>
<dl>
<dt class="option-term" id="option-cargo-fix--p"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-fix---package"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Fix only the specified packages. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the
SPEC format. This flag may be specified multiple times and supports common Unix
glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell accidentally 
expanding glob patterns before Cargo handles them, you must use single quotes or
double quotes around each pattern.</dd>
<dt class="option-term" id="option-cargo-fix---workspace"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">Fix all members in the workspace.</dd>
<dt class="option-term" id="option-cargo-fix---all"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---all"></a><code>--all</code></dt>
<dd class="option-desc">Deprecated alias for <code>--workspace</code>.</dd>
<dt class="option-term" id="option-cargo-fix---exclude"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---exclude"></a><code>--exclude</code> <em>SPEC</em>...</dt>
<dd class="option-desc">Exclude the specified packages. Must be used in conjunction with the
<code>--workspace</code> flag. This flag may be specified multiple times and supports
common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell
accidentally expanding glob patterns before Cargo handles them, you must use
single quotes or double quotes around each pattern.</dd>
</dl>
<h3 id="target-selection-4"><a class="header" href="#target-selection-4">Target Selection</a></h3>
<p>当没有给出目标选择选项时，<code>cargo fix</code>将修复所有目标(<code>--all-targets</code>暗示的）。如果有二进制文件，则跳过它们<code>required-features</code>这些都不见了。</p>
<p>传递目标选择标志将只修复指定的目标。</p>
<p>注意<code>--bin</code>, <code>--example</code>, <code>--test</code>和<code>--bench</code>标志还支持常见的Unix全局模式，如<code>*</code>, <code>?</code>和<code>[]</code>但是，为了避免您的shell在Cargo处理glob模式之前意外地扩展glob模式，您必须在每个glob模式周围使用单引号或双引号。</p>
<dl>
<dt class="option-term" id="option-cargo-fix---lib"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---lib"></a><code>--lib</code></dt>
<dd class="option-desc">Fix the package's library.</dd>
<dt class="option-term" id="option-cargo-fix---bin"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">Fix the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-fix---bins"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---bins"></a><code>--bins</code></dt>
<dd class="option-desc">Fix all binary targets.</dd>
<dt class="option-term" id="option-cargo-fix---example"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---example"></a><code>--example</code> <em>name</em>...</dt>
<dd class="option-desc">Fix the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-fix---examples"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---examples"></a><code>--examples</code></dt>
<dd class="option-desc">Fix all example targets.</dd>
<dt class="option-term" id="option-cargo-fix---test"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---test"></a><code>--test</code> <em>name</em>...</dt>
<dd class="option-desc">Fix the specified integration test. This flag may be specified
multiple times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-fix---tests"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---tests"></a><code>--tests</code></dt>
<dd class="option-desc">Fix all targets in test mode that have the <code>test = true</code> manifest
flag set. By default this includes the library and binaries built as
unittests, and integration tests. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
unittest, and once as a dependency for binaries, integration tests, etc.).
Targets may be enabled or disabled by setting the <code>test</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-fix---bench"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---bench"></a><code>--bench</code> <em>name</em>...</dt>
<dd class="option-desc">Fix the specified benchmark. This flag may be specified multiple
times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-fix---benches"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---benches"></a><code>--benches</code></dt>
<dd class="option-desc">Fix all targets in benchmark mode that have the <code>bench = true</code>
manifest flag set. By default this includes the library and binaries built
as benchmarks, and bench targets. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
benchmark, and once as a dependency for binaries, benchmarks, etc.).
Targets may be enabled or disabled by setting the <code>bench</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-fix---all-targets"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---all-targets"></a><code>--all-targets</code></dt>
<dd class="option-desc">Fix all targets. This is equivalent to specifying <code>--lib --bins --tests --benches --examples</code>.</dd>
</dl>
<h3 id="feature-selection-4"><a class="header" href="#feature-selection-4">Feature Selection</a></h3>
<p>功能标志允许您控制启用哪些功能。如果未提供任何功能选项，则<code>default</code>为每个选定的软件包激活该功能。</p>
<p>查看<a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>更多细节。</p>
<dl>
<dt class="option-term" id="option-cargo-fix---features"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</dd>
<dt class="option-term" id="option-cargo-fix---all-features"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">Activate all available features of all selected packages.</dd>
<dt class="option-term" id="option-cargo-fix---no-default-features"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">Do not activate the <code>default</code> feature of the selected packages.</dd>
</dl>
<h3 id="compilation-options-4"><a class="header" href="#compilation-options-4">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fix---target"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Fix for the given architecture. The default is the host
architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>. Run <code>rustc --print target-list</code> for a
list of supported targets.</p>
<p>This may also be specified with the <code>build.target</code>
<a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../guide/build-cache.html">build cache</a> documentation for more details.</dd>
<dt class="option-term" id="option-cargo-fix--r"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix--r"></a><code>-r</code></dt>
<dt class="option-term" id="option-cargo-fix---release"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---release"></a><code>--release</code></dt>
<dd class="option-desc">Fix optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</dd>
<dt class="option-term" id="option-cargo-fix---profile"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Fix with the given profile.</p>
<p>As a special case, specifying the <code>test</code> profile will also enable checking in
test mode which will enable checking tests and enable the <code>test</code> cfg option.
See <a href="https://doc.rust-lang.org/rustc/tests/index.html">rustc tests</a> for more
detail.</p>
<p>See the <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</dd>
<dt class="option-term" id="option-cargo-fix---ignore-rust-version"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---ignore-rust-version"></a><code>--ignore-rust-version</code></dt>
<dd class="option-desc">Fix the target even if the selected Rust compiler is older than the
required Rust version as configured in the project's <code>rust-version</code> field.</dd>
</dl>
<h3 id="output-options-4"><a class="header" href="#output-options-4">Output Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fix---target-dir"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</dd>
</dl>
<h3 id="display-options-7"><a class="header" href="#display-options-7">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fix--v"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-fix---verbose"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-fix--q"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-fix---quiet"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-fix---color"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-fix---message-format"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the &quot;short&quot; rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc's default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics in
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo's own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul></dd>
</dl>
<h3 id="manifest-options-7"><a class="header" href="#manifest-options-7">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fix---manifest-path"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-fix---frozen"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-fix---locked"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-fix---offline"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-7"><a class="header" href="#common-options-7">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fix-+toolchain"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-fix--h"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-fix---help"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-fix--Z"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h3 id="miscellaneous-options-4"><a class="header" href="#miscellaneous-options-4">Miscellaneous Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fix--j"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-fix---jobs"><a class="option-anchor" href="commands/cargo-fix.zh.html#option-cargo-fix---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of CPUs.</dd>
</dl>
<h2 id="environment-7"><a class="header" href="#environment-7">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.html">the reference</a>有关Cargo读取的环境变量的详细信息。</p>
<h2 id="exit-status-7"><a class="header" href="#exit-status-7">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>：Cargo成功。</li>
<li><code>101</code>：Cargo未能完成。</li>
</ul>
<h2 id="examples-11"><a class="header" href="#examples-11">EXAMPLES</a></h2>
<ol>
<li>
<p>将编译器建议应用于本地包：</p>
<p>Cargo修理</p>
</li>
<li>
<p>更新软件包以准备下一版本：</p>
<p>Cargo修正版</p>
</li>
<li>
<p>为当前版本应用建议的习惯用法：</p>
<p>cargo fix——版本习惯用法</p>
</li>
</ol>
<h2 id="see-also-9"><a class="header" href="#see-also-9">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a>, <a href="commands/cargo-check.html">cargo-check(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-run1"><a class="header" href="#cargo-run1">cargo-run(1)</a></h1>
<h2 id="name-10"><a class="header" href="#name-10">NAME</a></h2>
<p>Cargo运行-运行当前包</p>
<h2 id="synopsis-10"><a class="header" href="#synopsis-10">SYNOPSIS</a></h2>
<p><code>cargo run</code> [<em>options</em>][<code>--</code> <em>args</em>]</p>
<h2 id="description-10"><a class="header" href="#description-10">DESCRIPTION</a></h2>
<p>运行二进制文件或本地包的示例。</p>
<p>两个破折号后面的所有参数(<code>--</code>)传递给要运行的二进制文件。如果您同时向Cargo和二进制文件传递参数，则后面的参数<code>--</code>进入二进制，在进入Cargo之前。</p>
<h2 id="options-9"><a class="header" href="#options-9">OPTIONS</a></h2>
<h3 id="package-selection-8"><a class="header" href="#package-selection-8">Package Selection</a></h3>
<p>默认情况下，选择当前工作目录中的包。这个<code>-p</code>标志可用于在工作区中选择不同的包。</p>
<dl>
<dt class="option-term" id="option-cargo-run--p"><a class="option-anchor" href="commands/cargo-run.zh.html#option-cargo-run--p"></a><code>-p</code> <em>spec</em></dt>
<dt class="option-term" id="option-cargo-run---package"><a class="option-anchor" href="commands/cargo-run.zh.html#option-cargo-run---package"></a><code>--package</code> <em>spec</em></dt>
<dd class="option-desc">The package to run. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the SPEC
format.</dd>
</dl>
<h3 id="target-selection-5"><a class="header" href="#target-selection-5">Target Selection</a></h3>
<p>当没有给出目标选择选项时，<code>cargo run</code>将运行二进制目标。如果有多个二进制目标，则必须传递目标标志才能选择一个。或者<code>default-run</code>字段可以在<code>[package]</code>部分<code>Cargo.toml</code>选择默认运行的二进制文件的名称。</p>
<dl>
<dt class="option-term" id="option-cargo-run---bin"><a class="option-anchor" href="commands/cargo-run.zh.html#option-cargo-run---bin"></a><code>--bin</code> <em>name</em></dt>
<dd class="option-desc">Run the specified binary.</dd>
<dt class="option-term" id="option-cargo-run---example"><a class="option-anchor" href="commands/cargo-run.zh.html#option-cargo-run---example"></a><code>--example</code> <em>name</em></dt>
<dd class="option-desc">Run the specified example.</dd>
</dl>
<h3 id="feature-selection-5"><a class="header" href="#feature-selection-5">Feature Selection</a></h3>
<p>功能标志允许您控制启用哪些功能。如果未提供任何功能选项，则<code>default</code>为每个选定的软件包激活该功能。</p>
<p>查看<a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>更多细节。</p>
<dl>
<dt class="option-term" id="option-cargo-run---features"><a class="option-anchor" href="commands/cargo-run.zh.html#option-cargo-run---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</dd>
<dt class="option-term" id="option-cargo-run---all-features"><a class="option-anchor" href="commands/cargo-run.zh.html#option-cargo-run---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">Activate all available features of all selected packages.</dd>
<dt class="option-term" id="option-cargo-run---no-default-features"><a class="option-anchor" href="commands/cargo-run.zh.html#option-cargo-run---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">Do not activate the <code>default</code> feature of the selected packages.</dd>
</dl>
<h3 id="compilation-options-5"><a class="header" href="#compilation-options-5">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-run---target"><a class="option-anchor" href="commands/cargo-run.zh.html#option-cargo-run---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Run for the given architecture. The default is the host
architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>. Run <code>rustc --print target-list</code> for a
list of supported targets.</p>
<p>This may also be specified with the <code>build.target</code>
<a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../guide/build-cache.html">build cache</a> documentation for more details.</dd>
<dt class="option-term" id="option-cargo-run--r"><a class="option-anchor" href="commands/cargo-run.zh.html#option-cargo-run--r"></a><code>-r</code></dt>
<dt class="option-term" id="option-cargo-run---release"><a class="option-anchor" href="commands/cargo-run.zh.html#option-cargo-run---release"></a><code>--release</code></dt>
<dd class="option-desc">Run optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</dd>
<dt class="option-term" id="option-cargo-run---profile"><a class="option-anchor" href="commands/cargo-run.zh.html#option-cargo-run---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Run with the given profile.
See the <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</dd>
<dt class="option-term" id="option-cargo-run---ignore-rust-version"><a class="option-anchor" href="commands/cargo-run.zh.html#option-cargo-run---ignore-rust-version"></a><code>--ignore-rust-version</code></dt>
<dd class="option-desc">Run the target even if the selected Rust compiler is older than the
required Rust version as configured in the project's <code>rust-version</code> field.</dd>
</dl>
<h3 id="output-options-5"><a class="header" href="#output-options-5">Output Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-run---target-dir"><a class="option-anchor" href="commands/cargo-run.zh.html#option-cargo-run---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</dd>
</dl>
<h3 id="display-options-8"><a class="header" href="#display-options-8">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-run--v"><a class="option-anchor" href="commands/cargo-run.zh.html#option-cargo-run--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-run---verbose"><a class="option-anchor" href="commands/cargo-run.zh.html#option-cargo-run---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-run--q"><a class="option-anchor" href="commands/cargo-run.zh.html#option-cargo-run--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-run---quiet"><a class="option-anchor" href="commands/cargo-run.zh.html#option-cargo-run---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-run---color"><a class="option-anchor" href="commands/cargo-run.zh.html#option-cargo-run---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-run---message-format"><a class="option-anchor" href="commands/cargo-run.zh.html#option-cargo-run---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the &quot;short&quot; rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc's default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics in
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo's own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul></dd>
</dl>
<h3 id="manifest-options-8"><a class="header" href="#manifest-options-8">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-run---manifest-path"><a class="option-anchor" href="commands/cargo-run.zh.html#option-cargo-run---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-run---frozen"><a class="option-anchor" href="commands/cargo-run.zh.html#option-cargo-run---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-run---locked"><a class="option-anchor" href="commands/cargo-run.zh.html#option-cargo-run---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-run---offline"><a class="option-anchor" href="commands/cargo-run.zh.html#option-cargo-run---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-8"><a class="header" href="#common-options-8">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-run-+toolchain"><a class="option-anchor" href="commands/cargo-run.zh.html#option-cargo-run-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-run--h"><a class="option-anchor" href="commands/cargo-run.zh.html#option-cargo-run--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-run---help"><a class="option-anchor" href="commands/cargo-run.zh.html#option-cargo-run---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-run--Z"><a class="option-anchor" href="commands/cargo-run.zh.html#option-cargo-run--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h3 id="miscellaneous-options-5"><a class="header" href="#miscellaneous-options-5">Miscellaneous Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-run--j"><a class="option-anchor" href="commands/cargo-run.zh.html#option-cargo-run--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-run---jobs"><a class="option-anchor" href="commands/cargo-run.zh.html#option-cargo-run---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of CPUs.</dd>
</dl>
<h2 id="environment-8"><a class="header" href="#environment-8">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.html">the reference</a>有关Cargo读取的环境变量的详细信息。</p>
<h2 id="exit-status-8"><a class="header" href="#exit-status-8">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>：Cargo成功。</li>
<li><code>101</code>：Cargo未能完成。</li>
</ul>
<h2 id="examples-12"><a class="header" href="#examples-12">EXAMPLES</a></h2>
<ol>
<li>
<p>构建本地包并运行其主要目标（假设只有一个二进制）：</p>
<p>Cargo运输</p>
</li>
<li>
<p>运行带有额外参数的示例：</p>
<p>Cargo运行–示例exname–exoption exarg1 exarg2</p>
</li>
</ol>
<h2 id="see-also-10"><a class="header" href="#see-also-10">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a>, <a href="commands/cargo-build.html">cargo-build(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-rustc1"><a class="header" href="#cargo-rustc1">cargo-rustc(1)</a></h1>
<h2 id="name-11"><a class="header" href="#name-11">NAME</a></h2>
<p>C-编译当前包，并将额外选项传递给编译器</p>
<h2 id="synopsis-11"><a class="header" href="#synopsis-11">SYNOPSIS</a></h2>
<p><code>cargo rustc</code> [<em>options</em>][<code>--</code> <em>args</em>]</p>
<h2 id="description-11"><a class="header" href="#description-11">DESCRIPTION</a></h2>
<p>当前包（或由指定的包）的指定目标<code>-p</code>（如果提供）将与其所有依赖项一起编译。指定的<em>阿格斯</em>将全部传递给最终的编译器调用，而不是任何依赖项。请注意，编译器仍将无条件地接收参数，例如<code>-L</code>, <code>--extern</code>和<code>--crate-type</code>，以及指定的<em>阿格斯</em>将简单地添加到编译器调用中。</p>
<p>查看<a href="https://doc.rust-lang.org/rustc/index.html">https://doc.rust-lang.org/rustc/index.html</a>有关rustc标志的文档。</p>
<p>此命令要求在提供附加参数时只编译一个目标。如果当前包有多个目标可用，则<code>--lib</code>, <code>--bin</code>等，必须用于选择要编译的目标。</p>
<p>要将标志传递给Cargo生成的所有编译器进程，请使用<code>RUSTFLAGS</code>
<a href="commands/../reference/environment-variables.html">environment variable</a>或者<code>build.rustflags</code> <a href="commands/../reference/config.html">config value</a>.</p>
<h2 id="options-10"><a class="header" href="#options-10">OPTIONS</a></h2>
<h3 id="package-selection-9"><a class="header" href="#package-selection-9">Package Selection</a></h3>
<p>默认情况下，选择当前工作目录中的包。这个<code>-p</code>标志可用于在工作区中选择不同的包。</p>
<dl>
<dt class="option-term" id="option-cargo-rustc--p"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc--p"></a><code>-p</code> <em>spec</em></dt>
<dt class="option-term" id="option-cargo-rustc---package"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---package"></a><code>--package</code> <em>spec</em></dt>
<dd class="option-desc">The package to build. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the SPEC
format.</dd>
</dl>
<h3 id="target-selection-6"><a class="header" href="#target-selection-6">Target Selection</a></h3>
<p>当没有给出目标选择选项时，<code>cargo rustc</code>将生成所选包的所有二进制和库目标。</p>
<p>传递目标选择标志将只生成指定的目标。</p>
<p>注意<code>--bin</code>, <code>--example</code>, <code>--test</code>和<code>--bench</code>标志还支持常见的Unix全局模式，如<code>*</code>, <code>?</code>和<code>[]</code>但是，为了避免您的shell在Cargo处理glob模式之前意外地扩展glob模式，您必须在每个glob模式周围使用单引号或双引号。</p>
<dl>
<dt class="option-term" id="option-cargo-rustc---lib"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---lib"></a><code>--lib</code></dt>
<dd class="option-desc">Build the package's library.</dd>
<dt class="option-term" id="option-cargo-rustc---bin"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">Build the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-rustc---bins"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---bins"></a><code>--bins</code></dt>
<dd class="option-desc">Build all binary targets.</dd>
<dt class="option-term" id="option-cargo-rustc---example"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---example"></a><code>--example</code> <em>name</em>...</dt>
<dd class="option-desc">Build the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-rustc---examples"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---examples"></a><code>--examples</code></dt>
<dd class="option-desc">Build all example targets.</dd>
<dt class="option-term" id="option-cargo-rustc---test"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---test"></a><code>--test</code> <em>name</em>...</dt>
<dd class="option-desc">Build the specified integration test. This flag may be specified
multiple times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-rustc---tests"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---tests"></a><code>--tests</code></dt>
<dd class="option-desc">Build all targets in test mode that have the <code>test = true</code> manifest
flag set. By default this includes the library and binaries built as
unittests, and integration tests. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
unittest, and once as a dependency for binaries, integration tests, etc.).
Targets may be enabled or disabled by setting the <code>test</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-rustc---bench"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---bench"></a><code>--bench</code> <em>name</em>...</dt>
<dd class="option-desc">Build the specified benchmark. This flag may be specified multiple
times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-rustc---benches"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---benches"></a><code>--benches</code></dt>
<dd class="option-desc">Build all targets in benchmark mode that have the <code>bench = true</code>
manifest flag set. By default this includes the library and binaries built
as benchmarks, and bench targets. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
benchmark, and once as a dependency for binaries, benchmarks, etc.).
Targets may be enabled or disabled by setting the <code>bench</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-rustc---all-targets"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---all-targets"></a><code>--all-targets</code></dt>
<dd class="option-desc">Build all targets. This is equivalent to specifying <code>--lib --bins --tests --benches --examples</code>.</dd>
</dl>
<h3 id="feature-selection-6"><a class="header" href="#feature-selection-6">Feature Selection</a></h3>
<p>功能标志允许您控制启用哪些功能。如果未提供任何功能选项，则<code>default</code>为每个选定的软件包激活该功能。</p>
<p>查看<a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>更多细节。</p>
<dl>
<dt class="option-term" id="option-cargo-rustc---features"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</dd>
<dt class="option-term" id="option-cargo-rustc---all-features"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">Activate all available features of all selected packages.</dd>
<dt class="option-term" id="option-cargo-rustc---no-default-features"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">Do not activate the <code>default</code> feature of the selected packages.</dd>
</dl>
<h3 id="compilation-options-6"><a class="header" href="#compilation-options-6">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustc---target"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Build for the given architecture. The default is the host
architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>. Run <code>rustc --print target-list</code> for a
list of supported targets.</p>
<p>This may also be specified with the <code>build.target</code>
<a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../guide/build-cache.html">build cache</a> documentation for more details.</dd>
<dt class="option-term" id="option-cargo-rustc--r"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc--r"></a><code>-r</code></dt>
<dt class="option-term" id="option-cargo-rustc---release"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---release"></a><code>--release</code></dt>
<dd class="option-desc">Build optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</dd>
<dt class="option-term" id="option-cargo-rustc---profile"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Build with the given profile.</p>
<p>The <code>rustc</code> subcommand will treat the following named profiles with special behaviors:</p>
<ul>
<li><code>check</code> — Builds in the same way as the <a href="commands/cargo-check.html">cargo-check(1)</a> command with
the <code>dev</code> profile.</li>
<li><code>test</code> — Builds in the same way as the <a href="commands/cargo-test.html">cargo-test(1)</a> command,
enabling building in test mode which will enable tests and enable the <code>test</code>
cfg option. See <a href="https://doc.rust-lang.org/rustc/tests/index.html">rustc
tests</a> for more detail.</li>
<li><code>bench</code> — Builds in the same was as the <a href="commands/cargo-bench.html">cargo-bench(1)</a> command,
similar to the <code>test</code> profile.</li>
</ul>
<p>See the <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</dd>
<dt class="option-term" id="option-cargo-rustc---ignore-rust-version"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---ignore-rust-version"></a><code>--ignore-rust-version</code></dt>
<dd class="option-desc">Build the target even if the selected Rust compiler is older than the
required Rust version as configured in the project's <code>rust-version</code> field.</dd>
</dl>
<h3 id="output-options-6"><a class="header" href="#output-options-6">Output Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustc---target-dir"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</dd>
</dl>
<h3 id="display-options-9"><a class="header" href="#display-options-9">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustc--v"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-rustc---verbose"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-rustc--q"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-rustc---quiet"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-rustc---color"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-rustc---message-format"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the &quot;short&quot; rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc's default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics in
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo's own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul></dd>
</dl>
<h3 id="manifest-options-9"><a class="header" href="#manifest-options-9">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustc---manifest-path"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-rustc---frozen"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-rustc---locked"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-rustc---offline"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-9"><a class="header" href="#common-options-9">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustc-+toolchain"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-rustc--h"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-rustc---help"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-rustc--Z"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h3 id="miscellaneous-options-6"><a class="header" href="#miscellaneous-options-6">Miscellaneous Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustc--j"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-rustc---jobs"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of CPUs.</dd>
<dt class="option-term" id="option-cargo-rustc---future-incompat-report"><a class="option-anchor" href="commands/cargo-rustc.zh.html#option-cargo-rustc---future-incompat-report"></a><code>--future-incompat-report</code></dt>
<dd class="option-desc">Displays a future-incompat report for any future-incompatible warnings
produced during execution of this command</p>
<p>See <a href="commands/cargo-report.html">cargo-report(1)</a></dd>
</dl>
<h2 id="environment-9"><a class="header" href="#environment-9">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.html">the reference</a>有关Cargo读取的环境变量的详细信息。</p>
<h2 id="exit-status-9"><a class="header" href="#exit-status-9">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>：Cargo成功。</li>
<li><code>101</code>：Cargo未能完成。</li>
</ul>
<h2 id="examples-13"><a class="header" href="#examples-13">EXAMPLES</a></h2>
<ol>
<li>
<p>检查您的包（不包括依赖项）是否使用了不安全代码：</p>
<p>C–lib–D不安全代码</p>
</li>
<li>
<p>在nightly编译器上尝试一个实验性标志，例如，它会打印每种类型的大小：</p>
<pre><code>cargo rustc --lib -- -Z print-type-sizes
</code></pre>
</li>
</ol>
<h2 id="see-also-11"><a class="header" href="#see-also-11">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a>, <a href="commands/cargo-build.html">cargo-build(1)</a>, <a href="https://doc.rust-lang.org/rustc/index.html">rustc(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-rustdoc1"><a class="header" href="#cargo-rustdoc1">cargo-rustdoc(1)</a></h1>
<h2 id="name-12"><a class="header" href="#name-12">NAME</a></h2>
<p>cargo rustdoc——使用指定的自定义标志构建包的文档</p>
<h2 id="synopsis-12"><a class="header" href="#synopsis-12">SYNOPSIS</a></h2>
<p><code>cargo rustdoc</code> [<em>options</em>][<code>--</code> <em>args</em>]</p>
<h2 id="description-12"><a class="header" href="#description-12">DESCRIPTION</a></h2>
<p>当前包（或由指定的包）的指定目标<code>-p</code>（如果提供）将以规定的<em>阿格斯</em>被传递到最终的rustdoc调用。依赖项不会作为此命令的一部分进行记录。请注意，rustdoc仍将无条件接收参数，例如<code>-L</code>, <code>--extern</code>和<code>--crate-type</code>，以及指定的<em>阿格斯</em>将简单地添加到rustdoc调用中。</p>
<p>查看<a href="https://doc.rust-lang.org/rustdoc/index.html">https://doc.rust-lang.org/rustdoc/index.html</a>有关rustdoc标志的文档。</p>
<p>此命令要求在提供附加参数时只编译一个目标。如果当前包有多个目标可用，则<code>--lib</code>, <code>--bin</code>等，必须用于选择要编译的目标。</p>
<p>要将标志传递给Cargo生成的所有rustdoc进程，请使用<code>RUSTDOCFLAGS</code> <a href="commands/../reference/environment-variables.html">environment variable</a>或者<code>build.rustdocflags</code> <a href="commands/../reference/config.html">config value</a>.</p>
<h2 id="options-11"><a class="header" href="#options-11">OPTIONS</a></h2>
<h3 id="documentation-options-1"><a class="header" href="#documentation-options-1">Documentation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustdoc---open"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---open"></a><code>--open</code></dt>
<dd class="option-desc">Open the docs in a browser after building them. This will use your default
browser unless you define another one in the <code>BROWSER</code> environment variable
or use the <a href="commands/../reference/config.html#docbrowser"><code>doc.browser</code></a> configuration
option.</dd>
</dl>
<h3 id="package-selection-10"><a class="header" href="#package-selection-10">Package Selection</a></h3>
<p>默认情况下，选择当前工作目录中的包。这个<code>-p</code>标志可用于在工作区中选择不同的包。</p>
<dl>
<dt class="option-term" id="option-cargo-rustdoc--p"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc--p"></a><code>-p</code> <em>spec</em></dt>
<dt class="option-term" id="option-cargo-rustdoc---package"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---package"></a><code>--package</code> <em>spec</em></dt>
<dd class="option-desc">The package to document. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the SPEC
format.</dd>
</dl>
<h3 id="target-selection-7"><a class="header" href="#target-selection-7">Target Selection</a></h3>
<p>当没有给出目标选择选项时，<code>cargo rustdoc</code>将记录所选包的所有二进制和库目标。如果二进制文件的名称与lib目标文件相同，则将跳过该二进制文件。如果有二进制文件，则跳过它们<code>required-features</code>这些都不见了。</p>
<p>传递目标选择标志将仅记录指定的目标。</p>
<p>注意<code>--bin</code>, <code>--example</code>, <code>--test</code>和<code>--bench</code>标志还支持常见的Unix全局模式，如<code>*</code>, <code>?</code>和<code>[]</code>但是，为了避免您的shell在Cargo处理glob模式之前意外地扩展glob模式，您必须在每个glob模式周围使用单引号或双引号。</p>
<dl>
<dt class="option-term" id="option-cargo-rustdoc---lib"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---lib"></a><code>--lib</code></dt>
<dd class="option-desc">Document the package's library.</dd>
<dt class="option-term" id="option-cargo-rustdoc---bin"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">Document the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-rustdoc---bins"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---bins"></a><code>--bins</code></dt>
<dd class="option-desc">Document all binary targets.</dd>
<dt class="option-term" id="option-cargo-rustdoc---example"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---example"></a><code>--example</code> <em>name</em>...</dt>
<dd class="option-desc">Document the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-rustdoc---examples"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---examples"></a><code>--examples</code></dt>
<dd class="option-desc">Document all example targets.</dd>
<dt class="option-term" id="option-cargo-rustdoc---test"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---test"></a><code>--test</code> <em>name</em>...</dt>
<dd class="option-desc">Document the specified integration test. This flag may be specified
multiple times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-rustdoc---tests"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---tests"></a><code>--tests</code></dt>
<dd class="option-desc">Document all targets in test mode that have the <code>test = true</code> manifest
flag set. By default this includes the library and binaries built as
unittests, and integration tests. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
unittest, and once as a dependency for binaries, integration tests, etc.).
Targets may be enabled or disabled by setting the <code>test</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-rustdoc---bench"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---bench"></a><code>--bench</code> <em>name</em>...</dt>
<dd class="option-desc">Document the specified benchmark. This flag may be specified multiple
times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-rustdoc---benches"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---benches"></a><code>--benches</code></dt>
<dd class="option-desc">Document all targets in benchmark mode that have the <code>bench = true</code>
manifest flag set. By default this includes the library and binaries built
as benchmarks, and bench targets. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
benchmark, and once as a dependency for binaries, benchmarks, etc.).
Targets may be enabled or disabled by setting the <code>bench</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-rustdoc---all-targets"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---all-targets"></a><code>--all-targets</code></dt>
<dd class="option-desc">Document all targets. This is equivalent to specifying <code>--lib --bins --tests --benches --examples</code>.</dd>
</dl>
<h3 id="feature-selection-7"><a class="header" href="#feature-selection-7">Feature Selection</a></h3>
<p>功能标志允许您控制启用哪些功能。如果未提供任何功能选项，则<code>default</code>为每个选定的软件包激活该功能。</p>
<p>查看<a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>更多细节。</p>
<dl>
<dt class="option-term" id="option-cargo-rustdoc---features"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</dd>
<dt class="option-term" id="option-cargo-rustdoc---all-features"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">Activate all available features of all selected packages.</dd>
<dt class="option-term" id="option-cargo-rustdoc---no-default-features"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">Do not activate the <code>default</code> feature of the selected packages.</dd>
</dl>
<h3 id="compilation-options-7"><a class="header" href="#compilation-options-7">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustdoc---target"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Document for the given architecture. The default is the host
architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>. Run <code>rustc --print target-list</code> for a
list of supported targets.</p>
<p>This may also be specified with the <code>build.target</code>
<a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../guide/build-cache.html">build cache</a> documentation for more details.</dd>
<dt class="option-term" id="option-cargo-rustdoc--r"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc--r"></a><code>-r</code></dt>
<dt class="option-term" id="option-cargo-rustdoc---release"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---release"></a><code>--release</code></dt>
<dd class="option-desc">Document optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</dd>
<dt class="option-term" id="option-cargo-rustdoc---profile"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Document with the given profile.
See the <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</dd>
<dt class="option-term" id="option-cargo-rustdoc---ignore-rust-version"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---ignore-rust-version"></a><code>--ignore-rust-version</code></dt>
<dd class="option-desc">Document the target even if the selected Rust compiler is older than the
required Rust version as configured in the project's <code>rust-version</code> field.</dd>
</dl>
<h3 id="output-options-7"><a class="header" href="#output-options-7">Output Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustdoc---target-dir"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</dd>
</dl>
<h3 id="display-options-10"><a class="header" href="#display-options-10">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustdoc--v"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-rustdoc---verbose"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-rustdoc--q"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-rustdoc---quiet"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-rustdoc---color"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-rustdoc---message-format"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the &quot;short&quot; rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc's default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics in
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo's own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul></dd>
</dl>
<h3 id="manifest-options-10"><a class="header" href="#manifest-options-10">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustdoc---manifest-path"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-rustdoc---frozen"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-rustdoc---locked"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-rustdoc---offline"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-10"><a class="header" href="#common-options-10">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustdoc-+toolchain"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-rustdoc--h"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-rustdoc---help"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-rustdoc--Z"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h3 id="miscellaneous-options-7"><a class="header" href="#miscellaneous-options-7">Miscellaneous Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustdoc--j"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-rustdoc---jobs"><a class="option-anchor" href="commands/cargo-rustdoc.zh.html#option-cargo-rustdoc---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of CPUs.</dd>
</dl>
<h2 id="environment-10"><a class="header" href="#environment-10">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.html">the reference</a>有关Cargo读取的环境变量的详细信息。</p>
<h2 id="exit-status-10"><a class="header" href="#exit-status-10">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>：Cargo成功。</li>
<li><code>101</code>：Cargo未能完成。</li>
</ul>
<h2 id="examples-14"><a class="header" href="#examples-14">EXAMPLES</a></h2>
<ol>
<li>
<p>使用给定文件中包含的自定义CSS生成文档：</p>
<p>cargo rustdoc–lib–extend css extra。css</p>
</li>
</ol>
<h2 id="see-also-12"><a class="header" href="#see-also-12">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a>, <a href="commands/cargo-doc.html">cargo-doc(1)</a>, <a href="https://doc.rust-lang.org/rustdoc/index.html">rustdoc(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-test1"><a class="header" href="#cargo-test1">cargo-test(1)</a></h1>
<h2 id="name-13"><a class="header" href="#name-13">NAME</a></h2>
<p>Cargo测试——执行一个包的单元测试和集成测试</p>
<h2 id="synopsis-13"><a class="header" href="#synopsis-13">SYNOPSIS</a></h2>
<p><code>cargo test</code> [<em>options</em>][<em>testname</em>] [<code>--</code> <em>test-options</em>]</p>
<h2 id="description-13"><a class="header" href="#description-13">DESCRIPTION</a></h2>
<p>编译并执行单元和集成测试。</p>
<p>测试过滤参数<code>TESTNAME</code>以及两个破折号后面的所有论点(<code>--</code>)传递给测试二进制文件，从而传递给<em>利贝斯特</em>（rustc的内置单元测试和微观基准测试框架）。如果您同时向Cargo和二进制文件传递参数，则后面的参数<code>--</code>进入二进制，在进入Cargo之前。有关libtest参数的详细信息，请参阅<code>cargo test -- --help</code>看看rustc书中关于测试如何在实验室工作的章节<a href="https://doc.rust-lang.org/rustc/tests/index.html">https://doc.rust-lang.org/rustc/tests/index.html</a>.</p>
<p>例如，这将筛选具有<code>foo</code>以它们的名义在3个线程上并行运行：</p>
<pre><code>cargo test foo -- --test-threads 3
</code></pre>
<p>测试是用<code>--test</code>选择<code>rustc</code>它创建了一个具有<code>main</code>自动运行所有带注释的函数的函数<code>#[test]</code>属性在多个线程中。<code>#[bench]</code>带注释的函数也将在一次迭代中运行，以验证它们的功能。</p>
<p>libtest线束可以通过设置禁用<code>harness = false</code>在目标清单设置中，在这种情况下，代码需要提供自己的<code>main</code>函数来处理正在运行的测试。</p>
<p>文档测试也默认运行，由<code>rustdoc</code>.它从文档注释中提取代码样本并执行它们。看到了吗<a href="https://doc.rust-lang.org/rustdoc/">rustdoc book</a>有关编写文档测试的更多信息。</p>
<h2 id="options-12"><a class="header" href="#options-12">OPTIONS</a></h2>
<h3 id="test-options"><a class="header" href="#test-options">Test Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-test---no-run"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---no-run"></a><code>--no-run</code></dt>
<dd class="option-desc">Compile, but don't run tests.</dd>
<dt class="option-term" id="option-cargo-test---no-fail-fast"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---no-fail-fast"></a><code>--no-fail-fast</code></dt>
<dd class="option-desc">Run all tests regardless of failure. Without this flag, Cargo will exit
after the first executable fails. The Rust test harness will run all tests
within the executable to completion, this flag only applies to the executable
as a whole.</dd>
</dl>
<h3 id="package-selection-11"><a class="header" href="#package-selection-11">Package Selection</a></h3>
<p>默认情况下，如果未提供包选择选项，则选择的包取决于选择的清单文件（如果需要，则基于当前工作目录）<code>--manifest-path</code>未给出）。如果清单是工作区的根目录，则会选择工作区默认成员，否则只会选择清单定义的包。</p>
<p>可以使用<code>workspace.default-members</code>输入根清单。如果未设置，虚拟工作区将包括所有工作区成员（相当于传递）<code>--workspace</code>)，非虚拟工作区将只包括根箱子本身。</p>
<dl>
<dt class="option-term" id="option-cargo-test--p"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-test---package"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Test only the specified packages. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the
SPEC format. This flag may be specified multiple times and supports common Unix
glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell accidentally 
expanding glob patterns before Cargo handles them, you must use single quotes or
double quotes around each pattern.</dd>
<dt class="option-term" id="option-cargo-test---workspace"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">Test all members in the workspace.</dd>
<dt class="option-term" id="option-cargo-test---all"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---all"></a><code>--all</code></dt>
<dd class="option-desc">Deprecated alias for <code>--workspace</code>.</dd>
<dt class="option-term" id="option-cargo-test---exclude"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---exclude"></a><code>--exclude</code> <em>SPEC</em>...</dt>
<dd class="option-desc">Exclude the specified packages. Must be used in conjunction with the
<code>--workspace</code> flag. This flag may be specified multiple times and supports
common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell
accidentally expanding glob patterns before Cargo handles them, you must use
single quotes or double quotes around each pattern.</dd>
</dl>
<h3 id="target-selection-8"><a class="header" href="#target-selection-8">Target Selection</a></h3>
<p>当没有给出目标选择选项时，<code>cargo test</code>将为选定的软件包建立以下目标：</p>
<ul>
<li>lib-用于链接二进制文件、示例、集成测试和文档测试</li>
<li>垃圾箱（仅当集成测试已构建且所需功能可用时）</li>
<li>示例-确保它们能够编译</li>
<li>作为单元测试的lib</li>
<li>作为单元测试的箱子</li>
<li>集成测试</li>
<li>lib目标的doc测试</li>
</ul>
<p>可以通过设置<code>test</code>清单设置中目标的标志。以身作则<code>test = true</code>将生成并运行示例作为测试。设定目标<code>test = false</code>将阻止默认情况下对其进行测试。按名称获取目标的目标选择选项忽略<code>test</code>标记并始终测试给定的目标。</p>
<p>可以通过设置禁用库的文档测试<code>doctest = false</code>对于清单中的库。</p>
<p>如果存在集成测试或基准测试，则会自动构建二进制目标。这允许集成测试执行二进制文件来练习和测试其行为。这个<code>CARGO_BIN_EXE_&lt;name&gt;</code>
<a href="commands/../reference/environment-variables.html#environment-variables-cargo-sets-for-crates">environment variable</a>在构建集成测试时设置，以便它可以使用<a href="https://doc.rust-lang.org/std/macro.env.html"><code>env</code> macro</a>找到可执行文件。</p>
<p>传递目标选择标志将仅测试指定的目标。</p>
<p>注意<code>--bin</code>, <code>--example</code>, <code>--test</code>和<code>--bench</code>标志还支持常见的Unix全局模式，如<code>*</code>, <code>?</code>和<code>[]</code>但是，为了避免您的shell在Cargo处理glob模式之前意外地扩展glob模式，您必须在每个glob模式周围使用单引号或双引号。</p>
<dl>
<dt class="option-term" id="option-cargo-test---lib"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---lib"></a><code>--lib</code></dt>
<dd class="option-desc">Test the package's library.</dd>
<dt class="option-term" id="option-cargo-test---bin"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">Test the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-test---bins"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---bins"></a><code>--bins</code></dt>
<dd class="option-desc">Test all binary targets.</dd>
<dt class="option-term" id="option-cargo-test---example"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---example"></a><code>--example</code> <em>name</em>...</dt>
<dd class="option-desc">Test the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-test---examples"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---examples"></a><code>--examples</code></dt>
<dd class="option-desc">Test all example targets.</dd>
<dt class="option-term" id="option-cargo-test---test"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---test"></a><code>--test</code> <em>name</em>...</dt>
<dd class="option-desc">Test the specified integration test. This flag may be specified
multiple times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-test---tests"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---tests"></a><code>--tests</code></dt>
<dd class="option-desc">Test all targets in test mode that have the <code>test = true</code> manifest
flag set. By default this includes the library and binaries built as
unittests, and integration tests. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
unittest, and once as a dependency for binaries, integration tests, etc.).
Targets may be enabled or disabled by setting the <code>test</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-test---bench"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---bench"></a><code>--bench</code> <em>name</em>...</dt>
<dd class="option-desc">Test the specified benchmark. This flag may be specified multiple
times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-test---benches"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---benches"></a><code>--benches</code></dt>
<dd class="option-desc">Test all targets in benchmark mode that have the <code>bench = true</code>
manifest flag set. By default this includes the library and binaries built
as benchmarks, and bench targets. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
benchmark, and once as a dependency for binaries, benchmarks, etc.).
Targets may be enabled or disabled by setting the <code>bench</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-test---all-targets"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---all-targets"></a><code>--all-targets</code></dt>
<dd class="option-desc">Test all targets. This is equivalent to specifying <code>--lib --bins --tests --benches --examples</code>.</dd>
</dl>
<dl>
<dt class="option-term" id="option-cargo-test---doc"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---doc"></a><code>--doc</code></dt>
<dd class="option-desc">Test only the library's documentation. This cannot be mixed with other
target options.</dd>
</dl>
<h3 id="feature-selection-8"><a class="header" href="#feature-selection-8">Feature Selection</a></h3>
<p>功能标志允许您控制启用哪些功能。如果未提供任何功能选项，则<code>default</code>为每个选定的软件包激活该功能。</p>
<p>查看<a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>更多细节。</p>
<dl>
<dt class="option-term" id="option-cargo-test---features"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</dd>
<dt class="option-term" id="option-cargo-test---all-features"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">Activate all available features of all selected packages.</dd>
<dt class="option-term" id="option-cargo-test---no-default-features"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">Do not activate the <code>default</code> feature of the selected packages.</dd>
</dl>
<h3 id="compilation-options-8"><a class="header" href="#compilation-options-8">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-test---target"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Test for the given architecture. The default is the host
architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>. Run <code>rustc --print target-list</code> for a
list of supported targets.</p>
<p>This may also be specified with the <code>build.target</code>
<a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../guide/build-cache.html">build cache</a> documentation for more details.</dd>
<dt class="option-term" id="option-cargo-test--r"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test--r"></a><code>-r</code></dt>
<dt class="option-term" id="option-cargo-test---release"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---release"></a><code>--release</code></dt>
<dd class="option-desc">Test optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</dd>
<dt class="option-term" id="option-cargo-test---profile"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Test with the given profile.
See the <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</dd>
<dt class="option-term" id="option-cargo-test---ignore-rust-version"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---ignore-rust-version"></a><code>--ignore-rust-version</code></dt>
<dd class="option-desc">Test the target even if the selected Rust compiler is older than the
required Rust version as configured in the project's <code>rust-version</code> field.</dd>
</dl>
<h3 id="output-options-8"><a class="header" href="#output-options-8">Output Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-test---target-dir"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</dd>
</dl>
<h3 id="display-options-11"><a class="header" href="#display-options-11">Display Options</a></h3>
<p>默认情况下，Rust测试线束会隐藏测试执行的输出，以保持结果的可读性。测试输出可以通过以下方式恢复（例如，用于调试）<code>--nocapture</code>对于测试二进制文件：</p>
<pre><code>cargo test -- --nocapture
</code></pre>
<dl>
<dt class="option-term" id="option-cargo-test--v"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-test---verbose"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-test--q"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-test---quiet"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-test---color"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-test---message-format"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the &quot;short&quot; rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc's default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics in
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo's own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul></dd>
</dl>
<h3 id="manifest-options-11"><a class="header" href="#manifest-options-11">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-test---manifest-path"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-test---frozen"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-test---locked"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-test---offline"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-11"><a class="header" href="#common-options-11">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-test-+toolchain"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-test--h"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-test---help"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-test--Z"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h3 id="miscellaneous-options-8"><a class="header" href="#miscellaneous-options-8">Miscellaneous Options</a></h3>
<p>这个<code>--jobs</code>参数影响测试可执行文件的构建，但不影响运行测试时使用的线程数。防锈测试线束包括一个控制所用螺纹数量的选项：</p>
<pre><code>cargo test -j 2 -- --test-threads=2
</code></pre>
<dl>
<dt class="option-term" id="option-cargo-test--j"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-test---jobs"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of CPUs.</dd>
<dt class="option-term" id="option-cargo-test---future-incompat-report"><a class="option-anchor" href="commands/cargo-test.zh.html#option-cargo-test---future-incompat-report"></a><code>--future-incompat-report</code></dt>
<dd class="option-desc">Displays a future-incompat report for any future-incompatible warnings
produced during execution of this command</p>
<p>See <a href="commands/cargo-report.html">cargo-report(1)</a></dd>
</dl>
<h2 id="environment-11"><a class="header" href="#environment-11">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.html">the reference</a>有关Cargo读取的环境变量的详细信息。</p>
<h2 id="exit-status-11"><a class="header" href="#exit-status-11">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>：Cargo成功。</li>
<li><code>101</code>：Cargo未能完成。</li>
</ul>
<h2 id="examples-15"><a class="header" href="#examples-15">EXAMPLES</a></h2>
<ol>
<li>
<p>执行当前软件包的所有单元和集成测试：</p>
<p>Cargo测试</p>
</li>
<li>
<p>仅运行名称与筛选器字符串匹配的测试：</p>
<p>Cargo测试名称\u过滤器</p>
</li>
<li>
<p>仅在特定集成测试中运行特定测试：</p>
<p>Cargo测试–test int_test_name–modname:：test_name</p>
</li>
</ol>
<h2 id="see-also-13"><a class="header" href="#see-also-13">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a>, <a href="commands/cargo-bench.html">cargo-bench(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-report1"><a class="header" href="#cargo-report1">cargo-report(1)</a></h1>
<h2 id="name-14"><a class="header" href="#name-14">NAME</a></h2>
<p>Cargo报告-生成和显示各种报告</p>
<h2 id="synopsis-14"><a class="header" href="#synopsis-14">SYNOPSIS</a></h2>
<p><code>cargo report</code> <em>类型</em> [<em>options</em>]</p>
<h3 id="description-14"><a class="header" href="#description-14">DESCRIPTION</a></h3>
<p>显示给定项目的报告<em>类型</em>-目前只有<code>future-incompat</code>支持</p>
<h2 id="options-13"><a class="header" href="#options-13">OPTIONS</a></h2>
<dl>
<dt class="option-term" id="option-cargo-report---id"><a class="option-anchor" href="commands/cargo-report.zh.html#option-cargo-report---id"></a><code>--id</code> <em>id</em></dt>
<dd class="option-desc">Show the report with the specified Cargo-generated id</dd>
<dt class="option-term" id="option-cargo-report--p"><a class="option-anchor" href="commands/cargo-report.zh.html#option-cargo-report--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-report---package"><a class="option-anchor" href="commands/cargo-report.zh.html#option-cargo-report---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Only display a report for the specified package</dd>
</dl>
<h2 id="examples-16"><a class="header" href="#examples-16">EXAMPLES</a></h2>
<ol>
<li>
<p>显示最新的未来不匹配报告：</p>
<p>Cargo报告未来不匹配</p>
</li>
<li>
<p>显示特定软件包的最新未来不兼容报告：</p>
<p>Cargo报告未来不匹配——包装我的部门：0.0.1</p>
</li>
</ol>
<h2 id="see-also-14"><a class="header" href="#see-also-14">SEE ALSO</a></h2>
<p><a href="commands/../reference/future-incompat-report.html">Future incompat report</a></p>
<p><a href="commands/cargo.zh.html">cargo(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manifest-commands-1"><a class="header" href="#manifest-commands-1">Manifest Commands</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-generate-lockfile1"><a class="header" href="#cargo-generate-lockfile1">cargo-generate-lockfile(1)</a></h1>
<h2 id="name-15"><a class="header" href="#name-15">NAME</a></h2>
<p>cargo generate lockfile（Cargo生成锁定文件）-为包裹生成锁定文件</p>
<h2 id="synopsis-15"><a class="header" href="#synopsis-15">SYNOPSIS</a></h2>
<p><code>cargo generate-lockfile</code> [<em>options</em>]</p>
<h2 id="description-15"><a class="header" href="#description-15">DESCRIPTION</a></h2>
<p>此命令将创建<code>Cargo.lock</code>当前包或工作区的锁定文件。如果锁文件已经存在，将使用每个包的最新可用版本重新生成它。</p>
<p>另见<a href="commands/cargo-update.html">cargo-update(1)</a>它还能够创造一个<code>Cargo.lock</code>lockfile，并有更多控制更新行为的选项。</p>
<h2 id="options-14"><a class="header" href="#options-14">OPTIONS</a></h2>
<h3 id="display-options-12"><a class="header" href="#display-options-12">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-generate-lockfile--v"><a class="option-anchor" href="commands/cargo-generate-lockfile.zh.html#option-cargo-generate-lockfile--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-generate-lockfile---verbose"><a class="option-anchor" href="commands/cargo-generate-lockfile.zh.html#option-cargo-generate-lockfile---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-generate-lockfile--q"><a class="option-anchor" href="commands/cargo-generate-lockfile.zh.html#option-cargo-generate-lockfile--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-generate-lockfile---quiet"><a class="option-anchor" href="commands/cargo-generate-lockfile.zh.html#option-cargo-generate-lockfile---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-generate-lockfile---color"><a class="option-anchor" href="commands/cargo-generate-lockfile.zh.html#option-cargo-generate-lockfile---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="manifest-options-12"><a class="header" href="#manifest-options-12">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-generate-lockfile---manifest-path"><a class="option-anchor" href="commands/cargo-generate-lockfile.zh.html#option-cargo-generate-lockfile---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-generate-lockfile---frozen"><a class="option-anchor" href="commands/cargo-generate-lockfile.zh.html#option-cargo-generate-lockfile---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-generate-lockfile---locked"><a class="option-anchor" href="commands/cargo-generate-lockfile.zh.html#option-cargo-generate-lockfile---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-generate-lockfile---offline"><a class="option-anchor" href="commands/cargo-generate-lockfile.zh.html#option-cargo-generate-lockfile---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-12"><a class="header" href="#common-options-12">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-generate-lockfile-+toolchain"><a class="option-anchor" href="commands/cargo-generate-lockfile.zh.html#option-cargo-generate-lockfile-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-generate-lockfile--h"><a class="option-anchor" href="commands/cargo-generate-lockfile.zh.html#option-cargo-generate-lockfile--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-generate-lockfile---help"><a class="option-anchor" href="commands/cargo-generate-lockfile.zh.html#option-cargo-generate-lockfile---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-generate-lockfile--Z"><a class="option-anchor" href="commands/cargo-generate-lockfile.zh.html#option-cargo-generate-lockfile--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-12"><a class="header" href="#environment-12">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.html">the reference</a>有关Cargo读取的环境变量的详细信息。</p>
<h2 id="exit-status-12"><a class="header" href="#exit-status-12">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>：Cargo成功。</li>
<li><code>101</code>：Cargo未能完成。</li>
</ul>
<h2 id="examples-17"><a class="header" href="#examples-17">EXAMPLES</a></h2>
<ol>
<li>
<p>为当前包或工作区创建或更新锁文件：</p>
<p>Cargo生成锁文件</p>
</li>
</ol>
<h2 id="see-also-15"><a class="header" href="#see-also-15">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a>, <a href="commands/cargo-update.html">cargo-update(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-locate-project1"><a class="header" href="#cargo-locate-project1">cargo-locate-project(1)</a></h1>
<h2 id="name-16"><a class="header" href="#name-16">NAME</a></h2>
<p>cargo locate项目——打印Cargo的JSON表示。toml文件的位置</p>
<h2 id="synopsis-16"><a class="header" href="#synopsis-16">SYNOPSIS</a></h2>
<p><code>cargo locate-project</code> [<em>options</em>]</p>
<h2 id="description-16"><a class="header" href="#description-16">DESCRIPTION</a></h2>
<p>这个命令将把一个JSON对象打印到stdout，并带有到<code>Cargo.toml</code>显示</p>
<h2 id="options-15"><a class="header" href="#options-15">OPTIONS</a></h2>
<dl>
<dt class="option-term" id="option-cargo-locate-project---workspace"><a class="option-anchor" href="commands/cargo-locate-project.zh.html#option-cargo-locate-project---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">Locate the <code>Cargo.toml</code> at the root of the workspace, as opposed to the current
workspace member.</dd>
</dl>
<h3 id="display-options-13"><a class="header" href="#display-options-13">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-locate-project---message-format"><a class="option-anchor" href="commands/cargo-locate-project.zh.html#option-cargo-locate-project---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The representation in which to print the project location. Valid values:</p>
<ul>
<li><code>json</code> (default): JSON object with the path under the key &quot;root&quot;.</li>
<li><code>plain</code>: Just the path.</li>
</ul></dd>
<dt class="option-term" id="option-cargo-locate-project--v"><a class="option-anchor" href="commands/cargo-locate-project.zh.html#option-cargo-locate-project--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-locate-project---verbose"><a class="option-anchor" href="commands/cargo-locate-project.zh.html#option-cargo-locate-project---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-locate-project--q"><a class="option-anchor" href="commands/cargo-locate-project.zh.html#option-cargo-locate-project--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-locate-project---quiet"><a class="option-anchor" href="commands/cargo-locate-project.zh.html#option-cargo-locate-project---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-locate-project---color"><a class="option-anchor" href="commands/cargo-locate-project.zh.html#option-cargo-locate-project---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="manifest-options-13"><a class="header" href="#manifest-options-13">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-locate-project---manifest-path"><a class="option-anchor" href="commands/cargo-locate-project.zh.html#option-cargo-locate-project---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
</dl>
<h3 id="common-options-13"><a class="header" href="#common-options-13">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-locate-project-+toolchain"><a class="option-anchor" href="commands/cargo-locate-project.zh.html#option-cargo-locate-project-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-locate-project--h"><a class="option-anchor" href="commands/cargo-locate-project.zh.html#option-cargo-locate-project--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-locate-project---help"><a class="option-anchor" href="commands/cargo-locate-project.zh.html#option-cargo-locate-project---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-locate-project--Z"><a class="option-anchor" href="commands/cargo-locate-project.zh.html#option-cargo-locate-project--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-13"><a class="header" href="#environment-13">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.html">the reference</a>有关Cargo读取的环境变量的详细信息。</p>
<h2 id="exit-status-13"><a class="header" href="#exit-status-13">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>：Cargo成功。</li>
<li><code>101</code>：Cargo未能完成。</li>
</ul>
<h2 id="examples-18"><a class="header" href="#examples-18">EXAMPLES</a></h2>
<ol>
<li>
<p>根据当前目录显示清单的路径：</p>
<p>Cargo定位项目</p>
</li>
</ol>
<h2 id="see-also-16"><a class="header" href="#see-also-16">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a>, <a href="commands/cargo-metadata.html">cargo-metadata(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-metadata1"><a class="header" href="#cargo-metadata1">cargo-metadata(1)</a></h1>
<h2 id="name-17"><a class="header" href="#name-17">NAME</a></h2>
<p>cargo metadata-关于当前包的机器可读元数据</p>
<h2 id="synopsis-17"><a class="header" href="#synopsis-17">SYNOPSIS</a></h2>
<p><code>cargo metadata</code> [<em>options</em>]</p>
<h2 id="description-17"><a class="header" href="#description-17">DESCRIPTION</a></h2>
<p>将JSON输出到stdout，其中包含有关工作区成员和当前包的已解析依赖项的信息。</p>
<p>建议包括以下内容：<code>--format-version</code>标记代码，以确保输出的格式符合预期。</p>
<p>看到了吗<a href="https://crates.io/crates/cargo_metadata">cargo_metadata crate</a>获取用于读取元数据的Rust API。</p>
<h2 id="output-format"><a class="header" href="#output-format">OUTPUT FORMAT</a></h2>
<p>输出的格式如下：</p>
<pre><code class="language-javascript">{
    /* Array of all packages in the workspace.
       It also includes all feature-enabled dependencies unless --no-deps is used.
    */
    &quot;packages&quot;: [
        {
            /* The name of the package. */
            &quot;name&quot;: &quot;my-package&quot;,
            /* The version of the package. */
            &quot;version&quot;: &quot;0.1.0&quot;,
            /* The Package ID, a unique identifier for referring to the package. */
            &quot;id&quot;: &quot;my-package 0.1.0 (path+file:///path/to/my-package)&quot;,
            /* The license value from the manifest, or null. */
            &quot;license&quot;: &quot;MIT/Apache-2.0&quot;,
            /* The license-file value from the manifest, or null. */
            &quot;license_file&quot;: &quot;LICENSE&quot;,
            /* The description value from the manifest, or null. */
            &quot;description&quot;: &quot;Package description.&quot;,
            /* The source ID of the package. This represents where
               a package is retrieved from.
               This is null for path dependencies and workspace members.
               For other dependencies, it is a string with the format:
               - &quot;registry+URL&quot; for registry-based dependencies.
                 Example: &quot;registry+https://github.com/rust-lang/crates.io-index&quot;
               - &quot;git+URL&quot; for git-based dependencies.
                 Example: &quot;git+https://github.com/rust-lang/cargo?rev=5e85ba14aaa20f8133863373404cb0af69eeef2c#5e85ba14aaa20f8133863373404cb0af69eeef2c&quot;
            */
            &quot;source&quot;: null,
            /* Array of dependencies declared in the package's manifest. */
            &quot;dependencies&quot;: [
                {
                    /* The name of the dependency. */
                    &quot;name&quot;: &quot;bitflags&quot;,
                    /* The source ID of the dependency. May be null, see
                       description for the package source.
                    */
                    &quot;source&quot;: &quot;registry+https://github.com/rust-lang/crates.io-index&quot;,
                    /* The version requirement for the dependency.
                       Dependencies without a version requirement have a value of &quot;*&quot;.
                    */
                    &quot;req&quot;: &quot;^1.0&quot;,
                    /* The dependency kind.
                       &quot;dev&quot;, &quot;build&quot;, or null for a normal dependency.
                    */
                    &quot;kind&quot;: null,
                    /* If the dependency is renamed, this is the new name for
                       the dependency as a string.  null if it is not renamed.
                    */
                    &quot;rename&quot;: null,
                    /* Boolean of whether or not this is an optional dependency. */
                    &quot;optional&quot;: false,
                    /* Boolean of whether or not default features are enabled. */
                    &quot;uses_default_features&quot;: true,
                    /* Array of features enabled. */
                    &quot;features&quot;: [],
                    /* The target platform for the dependency.
                       null if not a target dependency.
                    */
                    &quot;target&quot;: &quot;cfg(windows)&quot;,
                    /* The file system path for a local path dependency.
                       not present if not a path dependency.
                    */
                    &quot;path&quot;: &quot;/path/to/dep&quot;,
                    /* A string of the URL of the registry this dependency is from.
                       If not specified or null, the dependency is from the default
                       registry (crates.io).
                    */
                    &quot;registry&quot;: null
                }
            ],
            /* Array of Cargo targets. */
            &quot;targets&quot;: [
                {
                    /* Array of target kinds.
                       - lib targets list the `crate-type` values from the
                         manifest such as &quot;lib&quot;, &quot;rlib&quot;, &quot;dylib&quot;,
                         &quot;proc-macro&quot;, etc. (default [&quot;lib&quot;])
                       - binary is [&quot;bin&quot;]
                       - example is [&quot;example&quot;]
                       - integration test is [&quot;test&quot;]
                       - benchmark is [&quot;bench&quot;]
                       - build script is [&quot;custom-build&quot;]
                    */
                    &quot;kind&quot;: [
                        &quot;bin&quot;
                    ],
                    /* Array of crate types.
                       - lib and example libraries list the `crate-type` values
                         from the manifest such as &quot;lib&quot;, &quot;rlib&quot;, &quot;dylib&quot;,
                         &quot;proc-macro&quot;, etc. (default [&quot;lib&quot;])
                       - all other target kinds are [&quot;bin&quot;]
                    */
                    &quot;crate_types&quot;: [
                        &quot;bin&quot;
                    ],
                    /* The name of the target. */
                    &quot;name&quot;: &quot;my-package&quot;,
                    /* Absolute path to the root source file of the target. */
                    &quot;src_path&quot;: &quot;/path/to/my-package/src/main.rs&quot;,
                    /* The Rust edition of the target.
                       Defaults to the package edition.
                    */
                    &quot;edition&quot;: &quot;2018&quot;,
                    /* Array of required features.
                       This property is not included if no required features are set.
                    */
                    &quot;required-features&quot;: [&quot;feat1&quot;],
                    /* Whether the target should be documented by `cargo doc`. */
                    &quot;doc&quot;: true,
                    /* Whether or not this target has doc tests enabled, and
                       the target is compatible with doc testing.
                    */
                    &quot;doctest&quot;: false,
                    /* Whether or not this target should be built and run with `--test`
                    */
                    &quot;test&quot;: true
                }
            ],
            /* Set of features defined for the package.
               Each feature maps to an array of features or dependencies it
               enables.
            */
            &quot;features&quot;: {
                &quot;default&quot;: [
                    &quot;feat1&quot;
                ],
                &quot;feat1&quot;: [],
                &quot;feat2&quot;: []
            },
            /* Absolute path to this package's manifest. */
            &quot;manifest_path&quot;: &quot;/path/to/my-package/Cargo.toml&quot;,
            /* Package metadata.
               This is null if no metadata is specified.
            */
            &quot;metadata&quot;: {
                &quot;docs&quot;: {
                    &quot;rs&quot;: {
                        &quot;all-features&quot;: true
                    }
                }
            },
            /* List of registries to which this package may be published.
               Publishing is unrestricted if null, and forbidden if an empty array. */
            &quot;publish&quot;: [
                &quot;crates-io&quot;
            ],
            /* Array of authors from the manifest.
               Empty array if no authors specified.
            */
            &quot;authors&quot;: [
                &quot;Jane Doe &lt;user@example.com&gt;&quot;
            ],
            /* Array of categories from the manifest. */
            &quot;categories&quot;: [
                &quot;command-line-utilities&quot;
            ],
            /* Optional string that is the default binary picked by cargo run. */
            &quot;default_run&quot;: null,
            /* Optional string that is the minimum supported rust version */
            &quot;rust_version&quot;: &quot;1.56&quot;,
            /* Array of keywords from the manifest. */
            &quot;keywords&quot;: [
                &quot;cli&quot;
            ],
            /* The readme value from the manifest or null if not specified. */
            &quot;readme&quot;: &quot;README.md&quot;,
            /* The repository value from the manifest or null if not specified. */
            &quot;repository&quot;: &quot;https://github.com/rust-lang/cargo&quot;,
            /* The homepage value from the manifest or null if not specified. */
            &quot;homepage&quot;: &quot;https://rust-lang.org&quot;,
            /* The documentation value from the manifest or null if not specified. */
            &quot;documentation&quot;: &quot;https://doc.rust-lang.org/stable/std&quot;,
            /* The default edition of the package.
               Note that individual targets may have different editions.
            */
            &quot;edition&quot;: &quot;2018&quot;,
            /* Optional string that is the name of a native library the package
               is linking to.
            */
            &quot;links&quot;: null,
        }
    ],
    /* Array of members of the workspace.
       Each entry is the Package ID for the package.
    */
    &quot;workspace_members&quot;: [
        &quot;my-package 0.1.0 (path+file:///path/to/my-package)&quot;,
    ],
    // The resolved dependency graph for the entire workspace. The enabled
    // features are based on the enabled features for the &quot;current&quot; package.
    // Inactivated optional dependencies are not listed.
    //
    // This is null if --no-deps is specified.
    //
    // By default, this includes all dependencies for all target platforms.
    // The `--filter-platform` flag may be used to narrow to a specific
    // target triple.
    &quot;resolve&quot;: {
        /* Array of nodes within the dependency graph.
           Each node is a package.
        */
        &quot;nodes&quot;: [
            {
                /* The Package ID of this node. */
                &quot;id&quot;: &quot;my-package 0.1.0 (path+file:///path/to/my-package)&quot;,
                /* The dependencies of this package, an array of Package IDs. */
                &quot;dependencies&quot;: [
                    &quot;bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)&quot;
                ],
                /* The dependencies of this package. This is an alternative to
                   &quot;dependencies&quot; which contains additional information. In
                   particular, this handles renamed dependencies.
                */
                &quot;deps&quot;: [
                    {
                        /* The name of the dependency's library target.
                           If this is a renamed dependency, this is the new
                           name.
                        */
                        &quot;name&quot;: &quot;bitflags&quot;,
                        /* The Package ID of the dependency. */
                        &quot;pkg&quot;: &quot;bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)&quot;,
                        /* Array of dependency kinds. Added in Cargo 1.40. */
                        &quot;dep_kinds&quot;: [
                            {
                                /* The dependency kind.
                                   &quot;dev&quot;, &quot;build&quot;, or null for a normal dependency.
                                */
                                &quot;kind&quot;: null,
                                /* The target platform for the dependency.
                                   null if not a target dependency.
                                */
                                &quot;target&quot;: &quot;cfg(windows)&quot;
                            }
                        ]
                    }
                ],
                /* Array of features enabled on this package. */
                &quot;features&quot;: [
                    &quot;default&quot;
                ]
            }
        ],
        /* The root package of the workspace.
           This is null if this is a virtual workspace. Otherwise it is
           the Package ID of the root package.
        */
        &quot;root&quot;: &quot;my-package 0.1.0 (path+file:///path/to/my-package)&quot;
    },
    /* The absolute path to the build directory where Cargo places its output. */
    &quot;target_directory&quot;: &quot;/path/to/my-package/target&quot;,
    /* The version of the schema for this metadata structure.
       This will be changed if incompatible changes are ever made.
    */
    &quot;version&quot;: 1,
    /* The absolute path to the root of the workspace. */
    &quot;workspace_root&quot;: &quot;/path/to/my-package&quot;
    /* Workspace metadata.
       This is null if no metadata is specified. */
    &quot;metadata&quot;: {
        &quot;docs&quot;: {
            &quot;rs&quot;: {
                &quot;all-features&quot;: true
            }
        }
    }
}
</code></pre>
<h2 id="options-16"><a class="header" href="#options-16">OPTIONS</a></h2>
<h3 id="output-options-9"><a class="header" href="#output-options-9">Output Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-metadata---no-deps"><a class="option-anchor" href="commands/cargo-metadata.zh.html#option-cargo-metadata---no-deps"></a><code>--no-deps</code></dt>
<dd class="option-desc">Output information only about the workspace members and don't fetch
dependencies.</dd>
<dt class="option-term" id="option-cargo-metadata---format-version"><a class="option-anchor" href="commands/cargo-metadata.zh.html#option-cargo-metadata---format-version"></a><code>--format-version</code> <em>version</em></dt>
<dd class="option-desc">Specify the version of the output format to use. Currently <code>1</code> is the only
possible value.</dd>
<dt class="option-term" id="option-cargo-metadata---filter-platform"><a class="option-anchor" href="commands/cargo-metadata.zh.html#option-cargo-metadata---filter-platform"></a><code>--filter-platform</code> <em>triple</em></dt>
<dd class="option-desc">This filters the <code>resolve</code> output to only include dependencies for the
given target triple. Without this flag, the resolve includes all targets.</p>
<p>Note that the dependencies listed in the &quot;packages&quot; array still includes all
dependencies. Each package definition is intended to be an unaltered
reproduction of the information within <code>Cargo.toml</code>.</dd>
</dl>
<h3 id="feature-selection-9"><a class="header" href="#feature-selection-9">Feature Selection</a></h3>
<p>功能标志允许您控制启用哪些功能。如果未提供任何功能选项，则<code>default</code>为每个选定的软件包激活该功能。</p>
<p>查看<a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>更多细节。</p>
<dl>
<dt class="option-term" id="option-cargo-metadata---features"><a class="option-anchor" href="commands/cargo-metadata.zh.html#option-cargo-metadata---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</dd>
<dt class="option-term" id="option-cargo-metadata---all-features"><a class="option-anchor" href="commands/cargo-metadata.zh.html#option-cargo-metadata---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">Activate all available features of all selected packages.</dd>
<dt class="option-term" id="option-cargo-metadata---no-default-features"><a class="option-anchor" href="commands/cargo-metadata.zh.html#option-cargo-metadata---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">Do not activate the <code>default</code> feature of the selected packages.</dd>
</dl>
<h3 id="display-options-14"><a class="header" href="#display-options-14">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-metadata--v"><a class="option-anchor" href="commands/cargo-metadata.zh.html#option-cargo-metadata--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-metadata---verbose"><a class="option-anchor" href="commands/cargo-metadata.zh.html#option-cargo-metadata---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-metadata--q"><a class="option-anchor" href="commands/cargo-metadata.zh.html#option-cargo-metadata--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-metadata---quiet"><a class="option-anchor" href="commands/cargo-metadata.zh.html#option-cargo-metadata---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-metadata---color"><a class="option-anchor" href="commands/cargo-metadata.zh.html#option-cargo-metadata---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="manifest-options-14"><a class="header" href="#manifest-options-14">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-metadata---manifest-path"><a class="option-anchor" href="commands/cargo-metadata.zh.html#option-cargo-metadata---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-metadata---frozen"><a class="option-anchor" href="commands/cargo-metadata.zh.html#option-cargo-metadata---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-metadata---locked"><a class="option-anchor" href="commands/cargo-metadata.zh.html#option-cargo-metadata---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-metadata---offline"><a class="option-anchor" href="commands/cargo-metadata.zh.html#option-cargo-metadata---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-14"><a class="header" href="#common-options-14">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-metadata-+toolchain"><a class="option-anchor" href="commands/cargo-metadata.zh.html#option-cargo-metadata-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-metadata--h"><a class="option-anchor" href="commands/cargo-metadata.zh.html#option-cargo-metadata--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-metadata---help"><a class="option-anchor" href="commands/cargo-metadata.zh.html#option-cargo-metadata---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-metadata--Z"><a class="option-anchor" href="commands/cargo-metadata.zh.html#option-cargo-metadata--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-14"><a class="header" href="#environment-14">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.html">the reference</a>有关Cargo读取的环境变量的详细信息。</p>
<h2 id="exit-status-14"><a class="header" href="#exit-status-14">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>：Cargo成功。</li>
<li><code>101</code>：Cargo未能完成。</li>
</ul>
<h2 id="examples-19"><a class="header" href="#examples-19">EXAMPLES</a></h2>
<ol>
<li>
<p>输出关于当前包的JSON：</p>
<p>Cargo元数据——格式版本=1</p>
</li>
</ol>
<h2 id="see-also-17"><a class="header" href="#see-also-17">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-pkgid1"><a class="header" href="#cargo-pkgid1">cargo-pkgid(1)</a></h1>
<h2 id="name-18"><a class="header" href="#name-18">NAME</a></h2>
<p>cargo pkgid-打印完全合格的包装规格</p>
<h2 id="synopsis-18"><a class="header" href="#synopsis-18">SYNOPSIS</a></h2>
<p><code>cargo pkgid</code> [<em>options</em>][<em>spec</em>]</p>
<h2 id="description-18"><a class="header" href="#description-18">DESCRIPTION</a></h2>
<p>给予<em>规格</em>参数，打印出当前工作区中包或依赖项的完全限定包ID说明符。如果<em>规格</em>它在依赖关系图中引用的包不明确。如果没有<em>规格</em>，然后打印本地包的说明符。</p>
<p>此命令要求锁文件可用，并且已获取依赖项。</p>
<p>包说明符由名称、版本和源URL组成。您可以使用部分说明符简洁地匹配特定的包，只要它只匹配一个包。文件的格式<em>规格</em>可以是以下内容之一：</p>
<table><thead><tr><th>规格结构</th><th>示例规范</th></tr></thead><tbody>
<tr><td><em>名称</em></td><td><code>bitflags</code></td></tr>
<tr><td><em>名称</em><code>:</code><em>版本</em></td><td><code>bitflags:1.0.4</code></td></tr>
<tr><td><em>网址</em></td><td><code>https://github.com/rust-lang/cargo</code></td></tr>
<tr><td><em>网址</em><code>#</code><em>版本</em></td><td><code>https://github.com/rust-lang/cargo#0.33.0</code></td></tr>
<tr><td><em>网址</em><code>#</code><em>名称</em></td><td><code>https://github.com/rust-lang/crates.io-index#bitflags</code></td></tr>
<tr><td><em>网址</em><code>#</code><em>名称</em><code>:</code><em>版本</em></td><td><code>https://github.com/rust-lang/cargo#crates-io:0.21.0</code></td></tr>
</tbody></table>
<h2 id="options-17"><a class="header" href="#options-17">OPTIONS</a></h2>
<h3 id="package-selection-12"><a class="header" href="#package-selection-12">Package Selection</a></h3>
<dl>
<dt class="option-term" id="option-cargo-pkgid--p"><a class="option-anchor" href="commands/cargo-pkgid.zh.html#option-cargo-pkgid--p"></a><code>-p</code> <em>spec</em></dt>
<dt class="option-term" id="option-cargo-pkgid---package"><a class="option-anchor" href="commands/cargo-pkgid.zh.html#option-cargo-pkgid---package"></a><code>--package</code> <em>spec</em></dt>
<dd class="option-desc">Get the package ID for the given package instead of the current package.</dd>
</dl>
<h3 id="display-options-15"><a class="header" href="#display-options-15">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-pkgid--v"><a class="option-anchor" href="commands/cargo-pkgid.zh.html#option-cargo-pkgid--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-pkgid---verbose"><a class="option-anchor" href="commands/cargo-pkgid.zh.html#option-cargo-pkgid---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-pkgid--q"><a class="option-anchor" href="commands/cargo-pkgid.zh.html#option-cargo-pkgid--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-pkgid---quiet"><a class="option-anchor" href="commands/cargo-pkgid.zh.html#option-cargo-pkgid---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-pkgid---color"><a class="option-anchor" href="commands/cargo-pkgid.zh.html#option-cargo-pkgid---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="manifest-options-15"><a class="header" href="#manifest-options-15">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-pkgid---manifest-path"><a class="option-anchor" href="commands/cargo-pkgid.zh.html#option-cargo-pkgid---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-pkgid---frozen"><a class="option-anchor" href="commands/cargo-pkgid.zh.html#option-cargo-pkgid---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-pkgid---locked"><a class="option-anchor" href="commands/cargo-pkgid.zh.html#option-cargo-pkgid---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-pkgid---offline"><a class="option-anchor" href="commands/cargo-pkgid.zh.html#option-cargo-pkgid---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-15"><a class="header" href="#common-options-15">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-pkgid-+toolchain"><a class="option-anchor" href="commands/cargo-pkgid.zh.html#option-cargo-pkgid-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-pkgid--h"><a class="option-anchor" href="commands/cargo-pkgid.zh.html#option-cargo-pkgid--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-pkgid---help"><a class="option-anchor" href="commands/cargo-pkgid.zh.html#option-cargo-pkgid---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-pkgid--Z"><a class="option-anchor" href="commands/cargo-pkgid.zh.html#option-cargo-pkgid--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-15"><a class="header" href="#environment-15">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.html">the reference</a>有关Cargo读取的环境变量的详细信息。</p>
<h2 id="exit-status-15"><a class="header" href="#exit-status-15">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>：Cargo成功。</li>
<li><code>101</code>：Cargo未能完成。</li>
</ul>
<h2 id="examples-20"><a class="header" href="#examples-20">EXAMPLES</a></h2>
<ol>
<li>
<p>检索的包规范<code>foo</code>包裹：</p>
<p>Cargo包装费</p>
</li>
<li>
<p>检索1.0.0版的包规范<code>foo</code>:</p>
<p>Cargo包装：1.0.0</p>
</li>
<li>
<p>检索的包规范<code>foo</code>从箱子里。io:</p>
<p>Cargo包装<a href="https://github.com/rust-lang/crates.io-index#foo">https://github.com/rust-lang/crates.io-index#foo</a></p>
</li>
<li>
<p>检索的包规范<code>foo</code>从本地软件包：</p>
<p>Cargo包装file:///path/to/local/package#foo</p>
</li>
</ol>
<h2 id="see-also-18"><a class="header" href="#see-also-18">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a>, <a href="commands/cargo-generate-lockfile.html">cargo-generate-lockfile(1)</a>, <a href="commands/cargo-metadata.html">cargo-metadata(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-tree1"><a class="header" href="#cargo-tree1">cargo-tree(1)</a></h1>
<h2 id="name-19"><a class="header" href="#name-19">NAME</a></h2>
<p>Cargo树-显示依赖关系图的树可视化</p>
<h2 id="synopsis-19"><a class="header" href="#synopsis-19">SYNOPSIS</a></h2>
<p><code>cargo tree</code> [<em>options</em>]</p>
<h2 id="description-19"><a class="header" href="#description-19">DESCRIPTION</a></h2>
<p>此命令将显示终端的依赖关系树。依赖“兰德”软件包的简单项目示例：</p>
<pre><code>myproject v0.1.0 (/myproject)
└── rand v0.7.3
    ├── getrandom v0.1.14
    │   ├── cfg-if v0.1.10
    │   └── libc v0.2.68
    ├── libc v0.2.68 (*)
    ├── rand_chacha v0.2.2
    │   ├── ppv-lite86 v0.2.6
    │   └── rand_core v0.5.1
    │       └── getrandom v0.1.14 (*)
    └── rand_core v0.5.1 (*)
[build-dependencies]
└── cc v1.0.50
</code></pre>
<p>标有<code>(*)</code>已被“消除重复”。包的依赖关系已经在图中的其他地方显示，因此不再重复。使用<code>--no-dedupe</code>选项来重复重复。</p>
<p>这个<code>-e</code>标志可用于选择要显示的依赖项类型。“features”类更改输出，以显示每个依赖项启用的特性。例如<code>cargo tree -e features</code>:</p>
<pre><code>myproject v0.1.0 (/myproject)
└── log feature &quot;serde&quot;
    └── log v0.4.8
        ├── serde v1.0.106
        └── cfg-if feature &quot;default&quot;
            └── cfg-if v0.1.10
</code></pre>
<p>在这棵树上，<code>myproject</code>取决于<code>log</code>和<code>serde</code>特色<code>log</code>反过来取决于<code>cfg-if</code>具有“默认”功能。使用时<code>-e features</code>使用它可能会有所帮助<code>-i</code>标志以显示功能如何流入包中。有关更多详细信息，请参见下面的示例。</p>
<h2 id="options-18"><a class="header" href="#options-18">OPTIONS</a></h2>
<h3 id="tree-options"><a class="header" href="#tree-options">Tree Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-tree--i"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree--i"></a><code>-i</code> <em>spec</em></dt>
<dt class="option-term" id="option-cargo-tree---invert"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree---invert"></a><code>--invert</code> <em>spec</em></dt>
<dd class="option-desc">Show the reverse dependencies for the given package. This flag will invert
the tree and display the packages that depend on the given package.</p>
<p>Note that in a workspace, by default it will only display the package's
reverse dependencies inside the tree of the workspace member in the current
directory. The <code>--workspace</code> flag can be used to extend it so that it will
show the package's reverse dependencies across the entire workspace. The <code>-p</code>
flag can be used to display the package's reverse dependencies only with the
subtree of the package given to <code>-p</code>.</dd>
<dt class="option-term" id="option-cargo-tree---prune"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree---prune"></a><code>--prune</code> <em>spec</em></dt>
<dd class="option-desc">Prune the given package from the display of the dependency tree.</dd>
<dt class="option-term" id="option-cargo-tree---depth"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree---depth"></a><code>--depth</code> <em>depth</em></dt>
<dd class="option-desc">Maximum display depth of the dependency tree. A depth of 1 displays the direct
dependencies, for example.</dd>
<dt class="option-term" id="option-cargo-tree---no-dedupe"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree---no-dedupe"></a><code>--no-dedupe</code></dt>
<dd class="option-desc">Do not de-duplicate repeated dependencies. Usually, when a package has already
displayed its dependencies, further occurrences will not re-display its
dependencies, and will include a <code>(*)</code> to indicate it has already been shown.
This flag will cause those duplicates to be repeated.</dd>
<dt class="option-term" id="option-cargo-tree--d"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree--d"></a><code>-d</code></dt>
<dt class="option-term" id="option-cargo-tree---duplicates"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree---duplicates"></a><code>--duplicates</code></dt>
<dd class="option-desc">Show only dependencies which come in multiple versions (implies <code>--invert</code>).
When used with the <code>-p</code> flag, only shows duplicates within the subtree of the
given package.</p>
<p>It can be beneficial for build times and executable sizes to avoid building
that same package multiple times. This flag can help identify the offending
packages. You can then investigate if the package that depends on the
duplicate with the older version can be updated to the newer version so that
only one instance is built.</dd>
<dt class="option-term" id="option-cargo-tree--e"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree--e"></a><code>-e</code> <em>kinds</em></dt>
<dt class="option-term" id="option-cargo-tree---edges"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree---edges"></a><code>--edges</code> <em>kinds</em></dt>
<dd class="option-desc">The dependency kinds to display. Takes a comma separated list of values:</p>
<ul>
<li><code>all</code> — Show all edge kinds.</li>
<li><code>normal</code> — Show normal dependencies.</li>
<li><code>build</code> — Show build dependencies.</li>
<li><code>dev</code> — Show development dependencies.</li>
<li><code>features</code> — Show features enabled by each dependency. If this is the only
kind given, then it will automatically include the other dependency kinds.</li>
<li><code>no-normal</code> — Do not include normal dependencies.</li>
<li><code>no-build</code> — Do not include build dependencies.</li>
<li><code>no-dev</code> — Do not include development dependencies.</li>
<li><code>no-proc-macro</code> — Do not include procedural macro dependencies.</li>
</ul>
<p>The <code>normal</code>, <code>build</code>, <code>dev</code>, and <code>all</code> dependency kinds cannot be mixed with
<code>no-normal</code>, <code>no-build</code>, or <code>no-dev</code> dependency kinds.</p>
<p>The default is <code>normal,build,dev</code>.</dd>
<dt class="option-term" id="option-cargo-tree---target"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Filter dependencies matching the given target-triple. The default is the host
platform. Use the value <code>all</code> to include <em>all</em> targets.</dd>
</dl>
<h3 id="tree-formatting-options"><a class="header" href="#tree-formatting-options">Tree Formatting Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-tree---charset"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree---charset"></a><code>--charset</code> <em>charset</em></dt>
<dd class="option-desc">Chooses the character set to use for the tree. Valid values are &quot;utf8&quot; or
&quot;ascii&quot;. Default is &quot;utf8&quot;.</dd>
<dt class="option-term" id="option-cargo-tree--f"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree--f"></a><code>-f</code> <em>format</em></dt>
<dt class="option-term" id="option-cargo-tree---format"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree---format"></a><code>--format</code> <em>format</em></dt>
<dd class="option-desc">Set the format string for each package. The default is &quot;{p}&quot;.</p>
<p>This is an arbitrary string which will be used to display each package. The following
strings will be replaced with the corresponding value:</p>
<ul>
<li><code>{p}</code> — The package name.</li>
<li><code>{l}</code> — The package license.</li>
<li><code>{r}</code> — The package repository URL.</li>
<li><code>{f}</code> — Comma-separated list of package features that are enabled.</li>
<li><code>{lib}</code> — The name, as used in a <code>use</code> statement, of the package's library.</li>
</ul></dd>
<dt class="option-term" id="option-cargo-tree---prefix"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree---prefix"></a><code>--prefix</code> <em>prefix</em></dt>
<dd class="option-desc">Sets how each line is displayed. The <em>prefix</em> value can be one of:</p>
<ul>
<li><code>indent</code> (default) — Shows each line indented as a tree.</li>
<li><code>depth</code> — Show as a list, with the numeric depth printed before each entry.</li>
<li><code>none</code> — Show as a flat list.</li>
</ul></dd>
</dl>
<h3 id="package-selection-13"><a class="header" href="#package-selection-13">Package Selection</a></h3>
<p>默认情况下，如果未提供包选择选项，则选择的包取决于选择的清单文件（如果需要，则基于当前工作目录）<code>--manifest-path</code>未给出）。如果清单是工作区的根目录，则会选择工作区默认成员，否则只会选择清单定义的包。</p>
<p>可以使用<code>workspace.default-members</code>输入根清单。如果未设置，虚拟工作区将包括所有工作区成员（相当于传递）<code>--workspace</code>)，非虚拟工作区将只包括根箱子本身。</p>
<dl>
<dt class="option-term" id="option-cargo-tree--p"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-tree---package"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Display only the specified packages. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the
SPEC format. This flag may be specified multiple times and supports common Unix
glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell accidentally 
expanding glob patterns before Cargo handles them, you must use single quotes or
double quotes around each pattern.</dd>
<dt class="option-term" id="option-cargo-tree---workspace"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">Display all members in the workspace.</dd>
<dt class="option-term" id="option-cargo-tree---exclude"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree---exclude"></a><code>--exclude</code> <em>SPEC</em>...</dt>
<dd class="option-desc">Exclude the specified packages. Must be used in conjunction with the
<code>--workspace</code> flag. This flag may be specified multiple times and supports
common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell
accidentally expanding glob patterns before Cargo handles them, you must use
single quotes or double quotes around each pattern.</dd>
</dl>
<h3 id="manifest-options-16"><a class="header" href="#manifest-options-16">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-tree---manifest-path"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-tree---frozen"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-tree---locked"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-tree---offline"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="feature-selection-10"><a class="header" href="#feature-selection-10">Feature Selection</a></h3>
<p>功能标志允许您控制启用哪些功能。如果未提供任何功能选项，则<code>default</code>为每个选定的软件包激活该功能。</p>
<p>查看<a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>更多细节。</p>
<dl>
<dt class="option-term" id="option-cargo-tree---features"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</dd>
<dt class="option-term" id="option-cargo-tree---all-features"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">Activate all available features of all selected packages.</dd>
<dt class="option-term" id="option-cargo-tree---no-default-features"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">Do not activate the <code>default</code> feature of the selected packages.</dd>
</dl>
<h3 id="display-options-16"><a class="header" href="#display-options-16">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-tree--v"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-tree---verbose"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-tree--q"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-tree---quiet"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-tree---color"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-16"><a class="header" href="#common-options-16">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-tree-+toolchain"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-tree--h"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-tree---help"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-tree--Z"><a class="option-anchor" href="commands/cargo-tree.zh.html#option-cargo-tree--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-16"><a class="header" href="#environment-16">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.html">the reference</a>有关Cargo读取的环境变量的详细信息。</p>
<h2 id="exit-status-16"><a class="header" href="#exit-status-16">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>：Cargo成功。</li>
<li><code>101</code>：Cargo未能完成。</li>
</ul>
<h2 id="examples-21"><a class="header" href="#examples-21">EXAMPLES</a></h2>
<ol>
<li>
<p>在当前目录中显示包的目录树：</p>
<p>货运树</p>
</li>
<li>
<p>显示所有依赖于<code>syn</code>包裹：</p>
<p>货运树-i syn</p>
</li>
<li>
<p>显示每个软件包上启用的功能：</p>
<p>Cargo树–格式“{p}{f}”</p>
</li>
<li>
<p>显示多次生成的所有包。如果树中出现多个semver不兼容的版本（如1.0.0和2.0.0），可能会发生这种情况。</p>
<pre><code>cargo tree -d
</code></pre>
</li>
<li>
<p>解释为什么为<code>syn</code>包裹：</p>
<pre><code>cargo tree -e features -i syn
</code></pre>
<p>这个<code>-e features</code>标志用于显示特征。这个<code>-i</code>标志用于反转图形，以便显示依赖于<code>syn</code>.这将显示什么的示例：</p>
<pre><code>syn v1.0.17
├── syn feature &quot;clone-impls&quot;
│   └── syn feature &quot;default&quot;
│       └── rustversion v1.0.2
│           └── rustversion feature &quot;default&quot;
│               └── myproject v0.1.0 (/myproject)
│                   └── myproject feature &quot;default&quot; (command-line)
├── syn feature &quot;default&quot; (*)
├── syn feature &quot;derive&quot;
│   └── syn feature &quot;default&quot; (*)
├── syn feature &quot;full&quot;
│   └── rustversion v1.0.2 (*)
├── syn feature &quot;parsing&quot;
│   └── syn feature &quot;default&quot; (*)
├── syn feature &quot;printing&quot;
│   └── syn feature &quot;default&quot; (*)
├── syn feature &quot;proc-macro&quot;
│   └── syn feature &quot;default&quot; (*)
└── syn feature &quot;quote&quot;
    ├── syn feature &quot;printing&quot; (*)
    └── syn feature &quot;proc-macro&quot; (*)
</code></pre>
<p>要阅读此图，您可以从根目录中查看每个功能的链，以了解其包含的原因。例如，“完整”功能由<code>rustversion</code>箱子，包括从<code>myproject</code>（具有默认功能），以及<code>myproject</code>是在命令行上选择的包。所有其他的<code>syn</code>功能由“默认”功能添加（“引用”由“打印”和“proc宏”添加，两者都是默认功能）。</p>
<p>如果交叉引用已消除重复的<code>(*)</code>输入，用<code>--no-dedupe</code>标记以获取完整输出。</p>
</li>
</ol>
<h2 id="see-also-19"><a class="header" href="#see-also-19">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a>, <a href="commands/cargo-metadata.html">cargo-metadata(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-update1"><a class="header" href="#cargo-update1">cargo-update(1)</a></h1>
<h2 id="name-20"><a class="header" href="#name-20">NAME</a></h2>
<p>Cargo更新-更新本地锁文件中记录的依赖项</p>
<h2 id="synopsis-20"><a class="header" href="#synopsis-20">SYNOPSIS</a></h2>
<p><code>cargo update</code> [<em>options</em>]</p>
<h2 id="description-20"><a class="header" href="#description-20">DESCRIPTION</a></h2>
<p>此命令将更新中的依赖项<code>Cargo.lock</code>文件更新至最新版本。如果<code>Cargo.lock</code>文件不存在，将使用最新的可用版本创建。</p>
<h2 id="options-19"><a class="header" href="#options-19">OPTIONS</a></h2>
<h3 id="update-options"><a class="header" href="#update-options">Update Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-update--p"><a class="option-anchor" href="commands/cargo-update.zh.html#option-cargo-update--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-update---package"><a class="option-anchor" href="commands/cargo-update.zh.html#option-cargo-update---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Update only the specified packages. This flag may be specified
multiple times. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the SPEC format.</p>
<p>If packages are specified with the <code>-p</code> flag, then a conservative update of
the lockfile will be performed. This means that only the dependency specified
by SPEC will be updated. Its transitive dependencies will be updated only if
SPEC cannot be updated without updating dependencies.  All other dependencies
will remain locked at their currently recorded versions.</p>
<p>If <code>-p</code> is not specified, all dependencies are updated.</dd>
<dt class="option-term" id="option-cargo-update---aggressive"><a class="option-anchor" href="commands/cargo-update.zh.html#option-cargo-update---aggressive"></a><code>--aggressive</code></dt>
<dd class="option-desc">When used with <code>-p</code>, dependencies of <em>spec</em> are forced to update as well.
Cannot be used with <code>--precise</code>.</dd>
<dt class="option-term" id="option-cargo-update---precise"><a class="option-anchor" href="commands/cargo-update.zh.html#option-cargo-update---precise"></a><code>--precise</code> <em>precise</em></dt>
<dd class="option-desc">When used with <code>-p</code>, allows you to specify a specific version number to set
the package to. If the package comes from a git repository, this can be a git
revision (such as a SHA hash or tag).</dd>
<dt class="option-term" id="option-cargo-update--w"><a class="option-anchor" href="commands/cargo-update.zh.html#option-cargo-update--w"></a><code>-w</code></dt>
<dt class="option-term" id="option-cargo-update---workspace"><a class="option-anchor" href="commands/cargo-update.zh.html#option-cargo-update---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">Attempt to update only packages defined in the workspace. Other packages
are updated only if they don't already exist in the lockfile. This
option is useful for updating <code>Cargo.lock</code> after you've changed version
numbers in <code>Cargo.toml</code>.</dd>
<dt class="option-term" id="option-cargo-update---dry-run"><a class="option-anchor" href="commands/cargo-update.zh.html#option-cargo-update---dry-run"></a><code>--dry-run</code></dt>
<dd class="option-desc">Displays what would be updated, but doesn't actually write the lockfile.</dd>
</dl>
<h3 id="display-options-17"><a class="header" href="#display-options-17">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-update--v"><a class="option-anchor" href="commands/cargo-update.zh.html#option-cargo-update--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-update---verbose"><a class="option-anchor" href="commands/cargo-update.zh.html#option-cargo-update---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-update--q"><a class="option-anchor" href="commands/cargo-update.zh.html#option-cargo-update--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-update---quiet"><a class="option-anchor" href="commands/cargo-update.zh.html#option-cargo-update---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-update---color"><a class="option-anchor" href="commands/cargo-update.zh.html#option-cargo-update---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="manifest-options-17"><a class="header" href="#manifest-options-17">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-update---manifest-path"><a class="option-anchor" href="commands/cargo-update.zh.html#option-cargo-update---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-update---frozen"><a class="option-anchor" href="commands/cargo-update.zh.html#option-cargo-update---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-update---locked"><a class="option-anchor" href="commands/cargo-update.zh.html#option-cargo-update---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-update---offline"><a class="option-anchor" href="commands/cargo-update.zh.html#option-cargo-update---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-17"><a class="header" href="#common-options-17">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-update-+toolchain"><a class="option-anchor" href="commands/cargo-update.zh.html#option-cargo-update-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-update--h"><a class="option-anchor" href="commands/cargo-update.zh.html#option-cargo-update--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-update---help"><a class="option-anchor" href="commands/cargo-update.zh.html#option-cargo-update---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-update--Z"><a class="option-anchor" href="commands/cargo-update.zh.html#option-cargo-update--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-17"><a class="header" href="#environment-17">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.html">the reference</a>有关Cargo读取的环境变量的详细信息。</p>
<h2 id="exit-status-17"><a class="header" href="#exit-status-17">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>：Cargo成功。</li>
<li><code>101</code>：Cargo未能完成。</li>
</ul>
<h2 id="examples-22"><a class="header" href="#examples-22">EXAMPLES</a></h2>
<ol>
<li>
<p>更新锁定文件中的所有依赖项：</p>
<p>Cargo更新</p>
</li>
<li>
<p>仅更新特定的依赖项：</p>
<p>Cargo更新-p foo-p bar</p>
</li>
<li>
<p>将特定依赖项设置为特定版本：</p>
<p>Cargo更新-p foo-精确1.2.3</p>
</li>
</ol>
<h2 id="see-also-20"><a class="header" href="#see-also-20">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a>, <a href="commands/cargo-generate-lockfile.html">cargo-generate-lockfile(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-vendor1"><a class="header" href="#cargo-vendor1">cargo-vendor(1)</a></h1>
<h2 id="name-21"><a class="header" href="#name-21">NAME</a></h2>
<p>Cargo供应商-供应商在本地的所有依赖关系</p>
<h2 id="synopsis-21"><a class="header" href="#synopsis-21">SYNOPSIS</a></h2>
<p><code>cargo vendor</code> [<em>options</em>][<em>path</em>]</p>
<h2 id="description-21"><a class="header" href="#description-21">DESCRIPTION</a></h2>
<p>该Cargo小组负责所有箱子的卖方。将项目的io和git依赖项放入<code>&lt;path&gt;</code>。此命令完成指定的供应商目录后<code>&lt;path&gt;</code>将包含来自指定依赖项的所有远程源。可以使用<code>-s</code>选项</p>
<p>这个<code>cargo vendor</code>命令还将打印出使用供应商源所需的配置，您需要将其添加到<code>.cargo/config.toml</code>.</p>
<h2 id="options-20"><a class="header" href="#options-20">OPTIONS</a></h2>
<h3 id="vendor-options"><a class="header" href="#vendor-options">Vendor Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-vendor--s"><a class="option-anchor" href="commands/cargo-vendor.zh.html#option-cargo-vendor--s"></a><code>-s</code> <em>manifest</em></dt>
<dt class="option-term" id="option-cargo-vendor---sync"><a class="option-anchor" href="commands/cargo-vendor.zh.html#option-cargo-vendor---sync"></a><code>--sync</code> <em>manifest</em></dt>
<dd class="option-desc">Specify extra <code>Cargo.toml</code> manifests to workspaces which should also be
vendored and synced to the output.</dd>
<dt class="option-term" id="option-cargo-vendor---no-delete"><a class="option-anchor" href="commands/cargo-vendor.zh.html#option-cargo-vendor---no-delete"></a><code>--no-delete</code></dt>
<dd class="option-desc">Don't delete the &quot;vendor&quot; directory when vendoring, but rather keep all
existing contents of the vendor directory</dd>
<dt class="option-term" id="option-cargo-vendor---respect-source-config"><a class="option-anchor" href="commands/cargo-vendor.zh.html#option-cargo-vendor---respect-source-config"></a><code>--respect-source-config</code></dt>
<dd class="option-desc">Instead of ignoring <code>[source]</code> configuration by default in <code>.cargo/config.toml</code>
read it and use it when downloading crates from crates.io, for example</dd>
<dt class="option-term" id="option-cargo-vendor---versioned-dirs"><a class="option-anchor" href="commands/cargo-vendor.zh.html#option-cargo-vendor---versioned-dirs"></a><code>--versioned-dirs</code></dt>
<dd class="option-desc">Normally versions are only added to disambiguate multiple versions of the
same package. This option causes all directories in the &quot;vendor&quot; directory
to be versioned, which makes it easier to track the history of vendored
packages over time, and can help with the performance of re-vendoring when
only a subset of the packages have changed.</dd>
</dl>
<h3 id="manifest-options-18"><a class="header" href="#manifest-options-18">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-vendor---manifest-path"><a class="option-anchor" href="commands/cargo-vendor.zh.html#option-cargo-vendor---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-vendor---frozen"><a class="option-anchor" href="commands/cargo-vendor.zh.html#option-cargo-vendor---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-vendor---locked"><a class="option-anchor" href="commands/cargo-vendor.zh.html#option-cargo-vendor---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-vendor---offline"><a class="option-anchor" href="commands/cargo-vendor.zh.html#option-cargo-vendor---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="display-options-18"><a class="header" href="#display-options-18">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-vendor--v"><a class="option-anchor" href="commands/cargo-vendor.zh.html#option-cargo-vendor--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-vendor---verbose"><a class="option-anchor" href="commands/cargo-vendor.zh.html#option-cargo-vendor---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-vendor--q"><a class="option-anchor" href="commands/cargo-vendor.zh.html#option-cargo-vendor--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-vendor---quiet"><a class="option-anchor" href="commands/cargo-vendor.zh.html#option-cargo-vendor---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-vendor---color"><a class="option-anchor" href="commands/cargo-vendor.zh.html#option-cargo-vendor---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-18"><a class="header" href="#common-options-18">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-vendor-+toolchain"><a class="option-anchor" href="commands/cargo-vendor.zh.html#option-cargo-vendor-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-vendor--h"><a class="option-anchor" href="commands/cargo-vendor.zh.html#option-cargo-vendor--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-vendor---help"><a class="option-anchor" href="commands/cargo-vendor.zh.html#option-cargo-vendor---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-vendor--Z"><a class="option-anchor" href="commands/cargo-vendor.zh.html#option-cargo-vendor--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-18"><a class="header" href="#environment-18">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.html">the reference</a>有关Cargo读取的环境变量的详细信息。</p>
<h2 id="exit-status-18"><a class="header" href="#exit-status-18">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>：Cargo成功。</li>
<li><code>101</code>：Cargo未能完成。</li>
</ul>
<h2 id="examples-23"><a class="header" href="#examples-23">EXAMPLES</a></h2>
<ol>
<li>
<p>供应商将所有依赖项放入本地“供应商”文件夹</p>
<p>货贩</p>
</li>
<li>
<p>供应商将所有依赖项放入本地“第三方/供应商”文件夹</p>
<p>Cargo供应商第三方/供应商</p>
</li>
<li>
<p>供应商将当前工作区以及另一个“供应商”</p>
<p>Cargo供应商-s/路径/目的地/Cargo。汤姆</p>
</li>
</ol>
<h2 id="see-also-21"><a class="header" href="#see-also-21">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-verify-project1"><a class="header" href="#cargo-verify-project1">cargo-verify-project(1)</a></h1>
<h2 id="name-22"><a class="header" href="#name-22">NAME</a></h2>
<p>Cargo验证项目-检查箱子舱单的正确性</p>
<h2 id="synopsis-22"><a class="header" href="#synopsis-22">SYNOPSIS</a></h2>
<p><code>cargo verify-project</code> [<em>options</em>]</p>
<h2 id="description-22"><a class="header" href="#description-22">DESCRIPTION</a></h2>
<p>此命令将解析本地清单并检查其有效性。它会发出一个JSON对象，并给出结果。成功的验证将显示：</p>
<pre><code>{&quot;success&quot;:&quot;true&quot;}
</code></pre>
<p>无效的工作区将显示：</p>
<pre><code>{&quot;invalid&quot;:&quot;human-readable error message&quot;}
</code></pre>
<h2 id="options-21"><a class="header" href="#options-21">OPTIONS</a></h2>
<h3 id="display-options-19"><a class="header" href="#display-options-19">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-verify-project--v"><a class="option-anchor" href="commands/cargo-verify-project.zh.html#option-cargo-verify-project--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-verify-project---verbose"><a class="option-anchor" href="commands/cargo-verify-project.zh.html#option-cargo-verify-project---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-verify-project--q"><a class="option-anchor" href="commands/cargo-verify-project.zh.html#option-cargo-verify-project--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-verify-project---quiet"><a class="option-anchor" href="commands/cargo-verify-project.zh.html#option-cargo-verify-project---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-verify-project---color"><a class="option-anchor" href="commands/cargo-verify-project.zh.html#option-cargo-verify-project---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="manifest-options-19"><a class="header" href="#manifest-options-19">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-verify-project---manifest-path"><a class="option-anchor" href="commands/cargo-verify-project.zh.html#option-cargo-verify-project---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-verify-project---frozen"><a class="option-anchor" href="commands/cargo-verify-project.zh.html#option-cargo-verify-project---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-verify-project---locked"><a class="option-anchor" href="commands/cargo-verify-project.zh.html#option-cargo-verify-project---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-verify-project---offline"><a class="option-anchor" href="commands/cargo-verify-project.zh.html#option-cargo-verify-project---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-19"><a class="header" href="#common-options-19">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-verify-project-+toolchain"><a class="option-anchor" href="commands/cargo-verify-project.zh.html#option-cargo-verify-project-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-verify-project--h"><a class="option-anchor" href="commands/cargo-verify-project.zh.html#option-cargo-verify-project--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-verify-project---help"><a class="option-anchor" href="commands/cargo-verify-project.zh.html#option-cargo-verify-project---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-verify-project--Z"><a class="option-anchor" href="commands/cargo-verify-project.zh.html#option-cargo-verify-project--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-19"><a class="header" href="#environment-19">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.html">the reference</a>有关Cargo读取的环境变量的详细信息。</p>
<h2 id="exit-status-19"><a class="header" href="#exit-status-19">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>：工作区正常。</li>
<li><code>1</code>：工作区无效。</li>
</ul>
<h2 id="examples-24"><a class="header" href="#examples-24">EXAMPLES</a></h2>
<ol>
<li>
<p>检查当前工作区是否存在错误：</p>
<p>Cargo验证项目</p>
</li>
</ol>
<h2 id="see-also-22"><a class="header" href="#see-also-22">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a>, <a href="commands/cargo-package.html">cargo-package(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="package-commands-1"><a class="header" href="#package-commands-1">Package Commands</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-init1"><a class="header" href="#cargo-init1">cargo-init(1)</a></h1>
<h2 id="name-23"><a class="header" href="#name-23">NAME</a></h2>
<p>cargo init-在现有目录中创建一个新的Cargo包</p>
<h2 id="synopsis-23"><a class="header" href="#synopsis-23">SYNOPSIS</a></h2>
<p><code>cargo init</code> [<em>options</em>][<em>path</em>]</p>
<h2 id="description-23"><a class="header" href="#description-23">DESCRIPTION</a></h2>
<p>此命令将在当前目录中创建新的Cargo清单。在给定目录中创建一个路径作为参数。</p>
<p>如果目录中已经存在通常命名的源文件，则将使用这些文件。如果没有，则提供样品<code>src/main.rs</code>将创建文件，或<code>src/lib.rs</code>如果<code>--lib</code>通过了。</p>
<p>如果该目录不在VCS存储库中，则会创建一个新的存储库（请参阅<code>--vcs</code>下面）。</p>
<p>查看<a href="commands/cargo-new.html">cargo-new(1)</a>类似的命令将在新目录中创建新包。</p>
<h2 id="options-22"><a class="header" href="#options-22">OPTIONS</a></h2>
<h3 id="init-options"><a class="header" href="#init-options">Init Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-init---bin"><a class="option-anchor" href="commands/cargo-init.zh.html#option-cargo-init---bin"></a><code>--bin</code></dt>
<dd class="option-desc">Create a package with a binary target (<code>src/main.rs</code>).
This is the default behavior.</dd>
<dt class="option-term" id="option-cargo-init---lib"><a class="option-anchor" href="commands/cargo-init.zh.html#option-cargo-init---lib"></a><code>--lib</code></dt>
<dd class="option-desc">Create a package with a library target (<code>src/lib.rs</code>).</dd>
<dt class="option-term" id="option-cargo-init---edition"><a class="option-anchor" href="commands/cargo-init.zh.html#option-cargo-init---edition"></a><code>--edition</code> <em>edition</em></dt>
<dd class="option-desc">Specify the Rust edition to use. Default is 2021.
Possible values: 2015, 2018, 2021</dd>
<dt class="option-term" id="option-cargo-init---name"><a class="option-anchor" href="commands/cargo-init.zh.html#option-cargo-init---name"></a><code>--name</code> <em>name</em></dt>
<dd class="option-desc">Set the package name. Defaults to the directory name.</dd>
<dt class="option-term" id="option-cargo-init---vcs"><a class="option-anchor" href="commands/cargo-init.zh.html#option-cargo-init---vcs"></a><code>--vcs</code> <em>vcs</em></dt>
<dd class="option-desc">Initialize a new VCS repository for the given version control system (git,
hg, pijul, or fossil) or do not initialize any version control at all
(none). If not specified, defaults to <code>git</code> or the configuration value
<code>cargo-new.vcs</code>, or <code>none</code> if already inside a VCS repository.</dd>
<dt class="option-term" id="option-cargo-init---registry"><a class="option-anchor" href="commands/cargo-init.zh.html#option-cargo-init---registry"></a><code>--registry</code> <em>registry</em></dt>
<dd class="option-desc">This sets the <code>publish</code> field in <code>Cargo.toml</code> to the given registry name
which will restrict publishing only to that registry.</p>
<p>Registry names are defined in <a href="commands/../reference/config.html">Cargo config files</a>.
If not specified, the default registry defined by the <code>registry.default</code>
config key is used. If the default registry is not set and <code>--registry</code> is not
used, the <code>publish</code> field will not be set which means that publishing will not
be restricted.</dd>
</dl>
<h3 id="display-options-20"><a class="header" href="#display-options-20">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-init--v"><a class="option-anchor" href="commands/cargo-init.zh.html#option-cargo-init--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-init---verbose"><a class="option-anchor" href="commands/cargo-init.zh.html#option-cargo-init---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-init--q"><a class="option-anchor" href="commands/cargo-init.zh.html#option-cargo-init--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-init---quiet"><a class="option-anchor" href="commands/cargo-init.zh.html#option-cargo-init---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-init---color"><a class="option-anchor" href="commands/cargo-init.zh.html#option-cargo-init---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-20"><a class="header" href="#common-options-20">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-init-+toolchain"><a class="option-anchor" href="commands/cargo-init.zh.html#option-cargo-init-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-init--h"><a class="option-anchor" href="commands/cargo-init.zh.html#option-cargo-init--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-init---help"><a class="option-anchor" href="commands/cargo-init.zh.html#option-cargo-init---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-init--Z"><a class="option-anchor" href="commands/cargo-init.zh.html#option-cargo-init--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-20"><a class="header" href="#environment-20">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.html">the reference</a>有关Cargo读取的环境变量的详细信息。</p>
<h2 id="exit-status-20"><a class="header" href="#exit-status-20">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>：Cargo成功。</li>
<li><code>101</code>：Cargo未能完成。</li>
</ul>
<h2 id="examples-25"><a class="header" href="#examples-25">EXAMPLES</a></h2>
<ol>
<li>
<p>在当前目录中创建二进制Cargo包：</p>
<p>Cargo起算</p>
</li>
</ol>
<h2 id="see-also-23"><a class="header" href="#see-also-23">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a>, <a href="commands/cargo-new.html">cargo-new(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-install1"><a class="header" href="#cargo-install1">cargo-install(1)</a></h1>
<h2 id="name-24"><a class="header" href="#name-24">NAME</a></h2>
<p>Cargo安装-构建并安装 Rust 的二进制文件</p>
<h2 id="synopsis-24"><a class="header" href="#synopsis-24">SYNOPSIS</a></h2>
<p><code>cargo install</code> [<em>options</em>] <em>大木箱</em>…\ <code>cargo install</code> [<em>options</em>] <code>--path</code> <em>路径</em>\ <code>cargo install</code> [<em>options</em>] <code>--git</code> <em>网址</em> [<em>crate</em>…]\ <code>cargo install</code> [<em>options</em>] <code>--list</code></p>
<h2 id="description-24"><a class="header" href="#description-24">DESCRIPTION</a></h2>
<p>此命令管理Cargo的本地安装的二进制箱子集。只有包含可执行文件的包<code>[[bin]]</code>或<code>[[example]]</code>可以安装目标，所有可执行文件都安装到安装根目录中<code>bin</code>文件夹</p>
<p>按照优先顺序确定安装根目录：</p>
<ul>
<li><code>--root</code>选项</li>
<li><code>CARGO_INSTALL_ROOT</code>环境变量</li>
<li><code>install.root</code>Cargo<a href="commands/../reference/config.html">config value</a></li>
<li><code>CARGO_HOME</code>环境变量</li>
<li><code>$HOME/.cargo</code></li>
</ul>
<p>有多个来源可以安装箱子。默认位置是箱子。但是<code>--git</code>, <code>--path</code>和<code>--registry</code>标志可以更改此源。如果源包含多个包（例如crates.io或带有多个箱子的git存储库），则<em>大木箱</em>参数必须指明应该安装哪个箱子。</p>
<p>从箱子到箱子。io可以选择通过<code>--version</code>来自git存储库的标志和类似的包可以选择性地指定应该安装的分支、标记或修订。如果一个箱子有多个二进制文件<code>--bin</code>参数只能选择性地安装其中一个，如果您愿意安装示例<code>--example</code>也可以使用参数。</p>
<p>如果软件包已经安装，如果安装的版本似乎不是最新的，Cargo将重新安装。如果以下任何值发生变化，Cargo将重新安装包装：</p>
<ul>
<li>软件包版本和源代码。</li>
<li>已安装的二进制名称集。</li>
<li>选择的功能。</li>
<li>个人资料(<code>--profile</code>).</li>
<li>目标(<code>--target</code>).</li>
</ul>
<p>安装<code>--path</code>将始终生成和安装，除非另一个包中存在冲突的二进制文件。这个<code>--force</code>标志可用于强制Cargo始终重新安装包装。</p>
<p>如果来源是箱子。io或<code>--git</code>然后默认情况下，箱子将构建在临时目标目录中。为了避免这种情况，可以通过设置<code>CARGO_TARGET_DIR</code>将环境变量设置为相对路径。特别是，这对于在连续集成系统上缓存构建工件非常有用。</p>
<p>默认情况下<code>Cargo.lock</code>包中包含的文件将被忽略。这意味着Cargo将重新计算要使用的依赖项版本，可能会使用自包发布以来发布的较新版本。这个<code>--locked</code>选项可以用来迫使Cargo使用包装好的包装<code>Cargo.lock</code>文件（如果可用）。这可能有助于确保可复制的构建，使用发布包时可用的完全相同的依赖项集。如果发布的依赖项的更新版本不再构建在您的系统上，或者存在其他问题，那么它可能也很有用。使用<code>--locked</code>您将不会收到任何依赖项的修复或更新。请注意，Cargo并没有开始发布<code>Cargo.lock</code>1.37版本之前的文件，这意味着使用以前版本发布的包将不会有<code>Cargo.lock</code>文件可用。</p>
<h2 id="options-23"><a class="header" href="#options-23">OPTIONS</a></h2>
<h3 id="install-options"><a class="header" href="#install-options">Install Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-install---vers"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---vers"></a><code>--vers</code> <em>version</em></dt>
<dt class="option-term" id="option-cargo-install---version"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---version"></a><code>--version</code> <em>version</em></dt>
<dd class="option-desc">Specify a version to install. This may be a <a href="commands/../reference/specifying-dependencies.html">version
requirement</a>, like <code>~1.2</code>, to have Cargo
select the newest version from the given requirement. If the version does not
have a requirement operator (such as <code>^</code> or <code>~</code>), then it must be in the form
<em>MAJOR.MINOR.PATCH</em>, and will install exactly that version; it is <em>not</em>
treated as a caret requirement like Cargo dependencies are.</dd>
<dt class="option-term" id="option-cargo-install---git"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---git"></a><code>--git</code> <em>url</em></dt>
<dd class="option-desc">Git URL to install the specified crate from.</dd>
<dt class="option-term" id="option-cargo-install---branch"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---branch"></a><code>--branch</code> <em>branch</em></dt>
<dd class="option-desc">Branch to use when installing from git.</dd>
<dt class="option-term" id="option-cargo-install---tag"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---tag"></a><code>--tag</code> <em>tag</em></dt>
<dd class="option-desc">Tag to use when installing from git.</dd>
<dt class="option-term" id="option-cargo-install---rev"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---rev"></a><code>--rev</code> <em>sha</em></dt>
<dd class="option-desc">Specific commit to use when installing from git.</dd>
<dt class="option-term" id="option-cargo-install---path"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---path"></a><code>--path</code> <em>path</em></dt>
<dd class="option-desc">Filesystem path to local crate to install.</dd>
<dt class="option-term" id="option-cargo-install---list"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---list"></a><code>--list</code></dt>
<dd class="option-desc">List all installed packages and their versions.</dd>
<dt class="option-term" id="option-cargo-install--f"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install--f"></a><code>-f</code></dt>
<dt class="option-term" id="option-cargo-install---force"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---force"></a><code>--force</code></dt>
<dd class="option-desc">Force overwriting existing crates or binaries. This can be used if a package
has installed a binary with the same name as another package. This is also
useful if something has changed on the system that you want to rebuild with,
such as a newer version of <code>rustc</code>.</dd>
<dt class="option-term" id="option-cargo-install---no-track"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---no-track"></a><code>--no-track</code></dt>
<dd class="option-desc">By default, Cargo keeps track of the installed packages with a metadata file
stored in the installation root directory. This flag tells Cargo not to use or
create that file. With this flag, Cargo will refuse to overwrite any existing
files unless the <code>--force</code> flag is used. This also disables Cargo's ability to
protect against multiple concurrent invocations of Cargo installing at the
same time.</dd>
<dt class="option-term" id="option-cargo-install---bin"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">Install only the specified binary.</dd>
<dt class="option-term" id="option-cargo-install---bins"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---bins"></a><code>--bins</code></dt>
<dd class="option-desc">Install all binaries.</dd>
<dt class="option-term" id="option-cargo-install---example"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---example"></a><code>--example</code> <em>name</em>...</dt>
<dd class="option-desc">Install only the specified example.</dd>
<dt class="option-term" id="option-cargo-install---examples"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---examples"></a><code>--examples</code></dt>
<dd class="option-desc">Install all examples.</dd>
<dt class="option-term" id="option-cargo-install---root"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---root"></a><code>--root</code> <em>dir</em></dt>
<dd class="option-desc">Directory to install packages into.</dd>
<dt class="option-term" id="option-cargo-install---registry"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---registry"></a><code>--registry</code> <em>registry</em></dt>
<dd class="option-desc">Name of the registry to use. Registry names are defined in <a href="commands/../reference/config.html">Cargo config
files</a>. If not specified, the default registry is used,
which is defined by the <code>registry.default</code> config key which defaults to
<code>crates-io</code>.</dd>
<dt class="option-term" id="option-cargo-install---index"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---index"></a><code>--index</code> <em>index</em></dt>
<dd class="option-desc">The URL of the registry index to use.</dd>
</dl>
<h3 id="feature-selection-11"><a class="header" href="#feature-selection-11">Feature Selection</a></h3>
<p>功能标志允许您控制启用哪些功能。如果未提供任何功能选项，则<code>default</code>为每个选定的软件包激活该功能。</p>
<p>查看<a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>更多细节。</p>
<dl>
<dt class="option-term" id="option-cargo-install---features"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</dd>
<dt class="option-term" id="option-cargo-install---all-features"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">Activate all available features of all selected packages.</dd>
<dt class="option-term" id="option-cargo-install---no-default-features"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">Do not activate the <code>default</code> feature of the selected packages.</dd>
</dl>
<h3 id="compilation-options-9"><a class="header" href="#compilation-options-9">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-install---target"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Install for the given architecture. The default is the host
architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>. Run <code>rustc --print target-list</code> for a
list of supported targets.</p>
<p>This may also be specified with the <code>build.target</code>
<a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../guide/build-cache.html">build cache</a> documentation for more details.</dd>
<dt class="option-term" id="option-cargo-install---target-dir"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to a new temporary folder located in the
temporary directory of the platform. </p>
<p>When using <code>--path</code>, by default it will use <code>target</code> directory in the workspace
of the local crate unless <code>--target-dir</code>
is specified.</dd>
<dt class="option-term" id="option-cargo-install---debug"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---debug"></a><code>--debug</code></dt>
<dd class="option-desc">Build with the <code>dev</code> profile instead the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</dd>
<dt class="option-term" id="option-cargo-install---profile"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Install with the given profile.
See the <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</dd>
</dl>
<h3 id="manifest-options-20"><a class="header" href="#manifest-options-20">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-install---frozen"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-install---locked"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-install---offline"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="miscellaneous-options-9"><a class="header" href="#miscellaneous-options-9">Miscellaneous Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-install--j"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-install---jobs"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of CPUs.</dd>
</dl>
<h3 id="display-options-21"><a class="header" href="#display-options-21">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-install--v"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-install---verbose"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-install--q"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-install---quiet"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-install---color"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-install---message-format"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the &quot;short&quot; rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc's default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics in
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo's own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul></dd>
</dl>
<h3 id="common-options-21"><a class="header" href="#common-options-21">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-install-+toolchain"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-install--h"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-install---help"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-install--Z"><a class="option-anchor" href="commands/cargo-install.zh.html#option-cargo-install--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-21"><a class="header" href="#environment-21">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.html">the reference</a>有关Cargo读取的环境变量的详细信息。</p>
<h2 id="exit-status-21"><a class="header" href="#exit-status-21">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>：Cargo成功。</li>
<li><code>101</code>：Cargo未能完成。</li>
</ul>
<h2 id="examples-26"><a class="header" href="#examples-26">EXAMPLES</a></h2>
<ol>
<li>
<p>从箱子安装或升级软件包。io:</p>
<p>Cargo装卸</p>
</li>
<li>
<p>在当前目录中安装或重新安装软件包：</p>
<p>Cargo安装——路径。</p>
</li>
<li>
<p>查看已安装软件包的列表：</p>
<p>Cargo安装——清单</p>
</li>
</ol>
<h2 id="see-also-24"><a class="header" href="#see-also-24">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a>, <a href="commands/cargo-uninstall.html">cargo-uninstall(1)</a>, <a href="commands/cargo-search.html">cargo-search(1)</a>, <a href="commands/cargo-publish.html">cargo-publish(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-new1"><a class="header" href="#cargo-new1">cargo-new(1)</a></h1>
<h2 id="name-25"><a class="header" href="#name-25">NAME</a></h2>
<p>Cargo新建-创建新的Cargo包</p>
<h2 id="synopsis-25"><a class="header" href="#synopsis-25">SYNOPSIS</a></h2>
<p><code>cargo new</code> [<em>options</em>] <em>路径</em></p>
<h2 id="description-25"><a class="header" href="#description-25">DESCRIPTION</a></h2>
<p>此命令将在给定目录中创建一个新的Cargo包。这包括一个带有<code>Cargo.toml</code>清单、样本源文件和VCS忽略文件。如果该目录不在VCS存储库中，则会创建一个新的存储库（请参阅<code>--vcs</code>下面）。</p>
<p>查看<a href="commands/cargo-init.html">cargo-init(1)</a>用于在现有目录中创建新清单的类似命令。</p>
<h2 id="options-24"><a class="header" href="#options-24">OPTIONS</a></h2>
<h3 id="new-options"><a class="header" href="#new-options">New Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-new---bin"><a class="option-anchor" href="commands/cargo-new.zh.html#option-cargo-new---bin"></a><code>--bin</code></dt>
<dd class="option-desc">Create a package with a binary target (<code>src/main.rs</code>).
This is the default behavior.</dd>
<dt class="option-term" id="option-cargo-new---lib"><a class="option-anchor" href="commands/cargo-new.zh.html#option-cargo-new---lib"></a><code>--lib</code></dt>
<dd class="option-desc">Create a package with a library target (<code>src/lib.rs</code>).</dd>
<dt class="option-term" id="option-cargo-new---edition"><a class="option-anchor" href="commands/cargo-new.zh.html#option-cargo-new---edition"></a><code>--edition</code> <em>edition</em></dt>
<dd class="option-desc">Specify the Rust edition to use. Default is 2021.
Possible values: 2015, 2018, 2021</dd>
<dt class="option-term" id="option-cargo-new---name"><a class="option-anchor" href="commands/cargo-new.zh.html#option-cargo-new---name"></a><code>--name</code> <em>name</em></dt>
<dd class="option-desc">Set the package name. Defaults to the directory name.</dd>
<dt class="option-term" id="option-cargo-new---vcs"><a class="option-anchor" href="commands/cargo-new.zh.html#option-cargo-new---vcs"></a><code>--vcs</code> <em>vcs</em></dt>
<dd class="option-desc">Initialize a new VCS repository for the given version control system (git,
hg, pijul, or fossil) or do not initialize any version control at all
(none). If not specified, defaults to <code>git</code> or the configuration value
<code>cargo-new.vcs</code>, or <code>none</code> if already inside a VCS repository.</dd>
<dt class="option-term" id="option-cargo-new---registry"><a class="option-anchor" href="commands/cargo-new.zh.html#option-cargo-new---registry"></a><code>--registry</code> <em>registry</em></dt>
<dd class="option-desc">This sets the <code>publish</code> field in <code>Cargo.toml</code> to the given registry name
which will restrict publishing only to that registry.</p>
<p>Registry names are defined in <a href="commands/../reference/config.html">Cargo config files</a>.
If not specified, the default registry defined by the <code>registry.default</code>
config key is used. If the default registry is not set and <code>--registry</code> is not
used, the <code>publish</code> field will not be set which means that publishing will not
be restricted.</dd>
</dl>
<h3 id="display-options-22"><a class="header" href="#display-options-22">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-new--v"><a class="option-anchor" href="commands/cargo-new.zh.html#option-cargo-new--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-new---verbose"><a class="option-anchor" href="commands/cargo-new.zh.html#option-cargo-new---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-new--q"><a class="option-anchor" href="commands/cargo-new.zh.html#option-cargo-new--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-new---quiet"><a class="option-anchor" href="commands/cargo-new.zh.html#option-cargo-new---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-new---color"><a class="option-anchor" href="commands/cargo-new.zh.html#option-cargo-new---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-22"><a class="header" href="#common-options-22">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-new-+toolchain"><a class="option-anchor" href="commands/cargo-new.zh.html#option-cargo-new-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-new--h"><a class="option-anchor" href="commands/cargo-new.zh.html#option-cargo-new--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-new---help"><a class="option-anchor" href="commands/cargo-new.zh.html#option-cargo-new---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-new--Z"><a class="option-anchor" href="commands/cargo-new.zh.html#option-cargo-new--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-22"><a class="header" href="#environment-22">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.html">the reference</a>有关Cargo读取的环境变量的详细信息。</p>
<h2 id="exit-status-22"><a class="header" href="#exit-status-22">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>：Cargo成功。</li>
<li><code>101</code>：Cargo未能完成。</li>
</ul>
<h2 id="examples-27"><a class="header" href="#examples-27">EXAMPLES</a></h2>
<ol>
<li>
<p>在给定目录中创建二进制Cargo包：</p>
<p>货运新富</p>
</li>
</ol>
<h2 id="see-also-25"><a class="header" href="#see-also-25">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a>, <a href="commands/cargo-init.html">cargo-init(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-search1"><a class="header" href="#cargo-search1">cargo-search(1)</a></h1>
<h2 id="name-26"><a class="header" href="#name-26">NAME</a></h2>
<p>Cargo搜索——在箱子中搜索包裹。木卫一</p>
<h2 id="synopsis-26"><a class="header" href="#synopsis-26">SYNOPSIS</a></h2>
<p><code>cargo search</code> [<em>options</em>][<em>query</em>…]</p>
<h2 id="description-26"><a class="header" href="#description-26">DESCRIPTION</a></h2>
<p>这将对机器上的箱子执行文本搜索<a href="https://crates.io">https://crates.io</a>.匹配的箱子将以适合复制到文件中的TOML格式显示及其说明<code>Cargo.toml</code>显示</p>
<h2 id="options-25"><a class="header" href="#options-25">OPTIONS</a></h2>
<h3 id="search-options"><a class="header" href="#search-options">Search Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-search---limit"><a class="option-anchor" href="commands/cargo-search.zh.html#option-cargo-search---limit"></a><code>--limit</code> <em>limit</em></dt>
<dd class="option-desc">Limit the number of results (default: 10, max: 100).</dd>
<dt class="option-term" id="option-cargo-search---index"><a class="option-anchor" href="commands/cargo-search.zh.html#option-cargo-search---index"></a><code>--index</code> <em>index</em></dt>
<dd class="option-desc">The URL of the registry index to use.</dd>
<dt class="option-term" id="option-cargo-search---registry"><a class="option-anchor" href="commands/cargo-search.zh.html#option-cargo-search---registry"></a><code>--registry</code> <em>registry</em></dt>
<dd class="option-desc">Name of the registry to use. Registry names are defined in <a href="commands/../reference/config.html">Cargo config
files</a>. If not specified, the default registry is used,
which is defined by the <code>registry.default</code> config key which defaults to
<code>crates-io</code>.</dd>
</dl>
<h3 id="display-options-23"><a class="header" href="#display-options-23">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-search--v"><a class="option-anchor" href="commands/cargo-search.zh.html#option-cargo-search--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-search---verbose"><a class="option-anchor" href="commands/cargo-search.zh.html#option-cargo-search---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-search--q"><a class="option-anchor" href="commands/cargo-search.zh.html#option-cargo-search--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-search---quiet"><a class="option-anchor" href="commands/cargo-search.zh.html#option-cargo-search---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-search---color"><a class="option-anchor" href="commands/cargo-search.zh.html#option-cargo-search---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-23"><a class="header" href="#common-options-23">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-search-+toolchain"><a class="option-anchor" href="commands/cargo-search.zh.html#option-cargo-search-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-search--h"><a class="option-anchor" href="commands/cargo-search.zh.html#option-cargo-search--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-search---help"><a class="option-anchor" href="commands/cargo-search.zh.html#option-cargo-search---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-search--Z"><a class="option-anchor" href="commands/cargo-search.zh.html#option-cargo-search--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-23"><a class="header" href="#environment-23">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.html">the reference</a>有关Cargo读取的环境变量的详细信息。</p>
<h2 id="exit-status-23"><a class="header" href="#exit-status-23">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>：Cargo成功。</li>
<li><code>101</code>：Cargo未能完成。</li>
</ul>
<h2 id="examples-28"><a class="header" href="#examples-28">EXAMPLES</a></h2>
<ol>
<li>
<p>从箱子中寻找包裹。io:</p>
<p>Cargo搜索服务</p>
</li>
</ol>
<h2 id="see-also-26"><a class="header" href="#see-also-26">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a>, <a href="commands/cargo-install.html">cargo-install(1)</a>, <a href="commands/cargo-publish.html">cargo-publish(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-uninstall1"><a class="header" href="#cargo-uninstall1">cargo-uninstall(1)</a></h1>
<h2 id="name-27"><a class="header" href="#name-27">NAME</a></h2>
<p>卸载Cargo-清除 Rust 的二进制文件</p>
<h2 id="synopsis-27"><a class="header" href="#synopsis-27">SYNOPSIS</a></h2>
<p><code>cargo uninstall</code> [<em>options</em>][<em>spec</em>…]</p>
<h2 id="description-27"><a class="header" href="#description-27">DESCRIPTION</a></h2>
<p>此命令将删除随一起安装的软件包<a href="commands/cargo-install.html">cargo-install(1)</a>这个<em>规格</em>参数是要删除的包的包ID规范（请参阅<a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a>).</p>
<p>默认情况下，箱子中的所有二进制文件都会被删除，但<code>--bin</code>和<code>--example</code>标志只能用于删除特定的二进制文件。</p>
<p>按照优先顺序确定安装根目录：</p>
<ul>
<li><code>--root</code>选项</li>
<li><code>CARGO_INSTALL_ROOT</code>环境变量</li>
<li><code>install.root</code>Cargo<a href="commands/../reference/config.html">config value</a></li>
<li><code>CARGO_HOME</code>环境变量</li>
<li><code>$HOME/.cargo</code></li>
</ul>
<h2 id="options-26"><a class="header" href="#options-26">OPTIONS</a></h2>
<h3 id="install-options-1"><a class="header" href="#install-options-1">Install Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-uninstall--p"><a class="option-anchor" href="commands/cargo-uninstall.zh.html#option-cargo-uninstall--p"></a><code>-p</code></dt>
<dt class="option-term" id="option-cargo-uninstall---package"><a class="option-anchor" href="commands/cargo-uninstall.zh.html#option-cargo-uninstall---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Package to uninstall.</dd>
<dt class="option-term" id="option-cargo-uninstall---bin"><a class="option-anchor" href="commands/cargo-uninstall.zh.html#option-cargo-uninstall---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">Only uninstall the binary <em>name</em>.</dd>
<dt class="option-term" id="option-cargo-uninstall---root"><a class="option-anchor" href="commands/cargo-uninstall.zh.html#option-cargo-uninstall---root"></a><code>--root</code> <em>dir</em></dt>
<dd class="option-desc">Directory to uninstall packages from.</dd>
</dl>
<h3 id="display-options-24"><a class="header" href="#display-options-24">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-uninstall--v"><a class="option-anchor" href="commands/cargo-uninstall.zh.html#option-cargo-uninstall--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-uninstall---verbose"><a class="option-anchor" href="commands/cargo-uninstall.zh.html#option-cargo-uninstall---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-uninstall--q"><a class="option-anchor" href="commands/cargo-uninstall.zh.html#option-cargo-uninstall--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-uninstall---quiet"><a class="option-anchor" href="commands/cargo-uninstall.zh.html#option-cargo-uninstall---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-uninstall---color"><a class="option-anchor" href="commands/cargo-uninstall.zh.html#option-cargo-uninstall---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-24"><a class="header" href="#common-options-24">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-uninstall-+toolchain"><a class="option-anchor" href="commands/cargo-uninstall.zh.html#option-cargo-uninstall-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-uninstall--h"><a class="option-anchor" href="commands/cargo-uninstall.zh.html#option-cargo-uninstall--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-uninstall---help"><a class="option-anchor" href="commands/cargo-uninstall.zh.html#option-cargo-uninstall---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-uninstall--Z"><a class="option-anchor" href="commands/cargo-uninstall.zh.html#option-cargo-uninstall--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-24"><a class="header" href="#environment-24">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.html">the reference</a>有关Cargo读取的环境变量的详细信息。</p>
<h2 id="exit-status-24"><a class="header" href="#exit-status-24">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>：Cargo成功。</li>
<li><code>101</code>：Cargo未能完成。</li>
</ul>
<h2 id="examples-29"><a class="header" href="#examples-29">EXAMPLES</a></h2>
<ol>
<li>
<p>卸载以前安装的软件包。</p>
<p>Cargo倾覆</p>
</li>
</ol>
<h2 id="see-also-27"><a class="header" href="#see-also-27">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a>, <a href="commands/cargo-install.html">cargo-install(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="publishing-commands-1"><a class="header" href="#publishing-commands-1">Publishing Commands</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-login1"><a class="header" href="#cargo-login1">cargo-login(1)</a></h1>
<h2 id="name-28"><a class="header" href="#name-28">NAME</a></h2>
<p>Cargo登录-从注册表本地保存API令牌</p>
<h2 id="synopsis-28"><a class="header" href="#synopsis-28">SYNOPSIS</a></h2>
<p><code>cargo login</code> [<em>options</em>][<em>token</em>]</p>
<h2 id="description-28"><a class="header" href="#description-28">DESCRIPTION</a></h2>
<p>此命令将API令牌保存到磁盘，以便需要身份验证的命令，例如<a href="commands/cargo-publish.html">cargo-publish(1)</a>，将自动进行身份验证。令牌保存在<code>$CARGO_HOME/credentials.toml</code>. <code>CARGO_HOME</code>默认为<code>.cargo</code>在你的主目录中。</p>
<p>如果<em>代币</em>未指定参数，将从stdin读取。</p>
<p>箱子的API标记。io可以从<a href="https://crates.io/me">https://crates.io/me</a>.</p>
<p>注意对代币保密，不得与他人分享。</p>
<h2 id="options-27"><a class="header" href="#options-27">OPTIONS</a></h2>
<h3 id="login-options"><a class="header" href="#login-options">Login Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-login---registry"><a class="option-anchor" href="commands/cargo-login.zh.html#option-cargo-login---registry"></a><code>--registry</code> <em>registry</em></dt>
<dd class="option-desc">Name of the registry to use. Registry names are defined in <a href="commands/../reference/config.html">Cargo config
files</a>. If not specified, the default registry is used,
which is defined by the <code>registry.default</code> config key which defaults to
<code>crates-io</code>.</dd>
</dl>
<h3 id="display-options-25"><a class="header" href="#display-options-25">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-login--v"><a class="option-anchor" href="commands/cargo-login.zh.html#option-cargo-login--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-login---verbose"><a class="option-anchor" href="commands/cargo-login.zh.html#option-cargo-login---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-login--q"><a class="option-anchor" href="commands/cargo-login.zh.html#option-cargo-login--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-login---quiet"><a class="option-anchor" href="commands/cargo-login.zh.html#option-cargo-login---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-login---color"><a class="option-anchor" href="commands/cargo-login.zh.html#option-cargo-login---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-25"><a class="header" href="#common-options-25">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-login-+toolchain"><a class="option-anchor" href="commands/cargo-login.zh.html#option-cargo-login-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-login--h"><a class="option-anchor" href="commands/cargo-login.zh.html#option-cargo-login--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-login---help"><a class="option-anchor" href="commands/cargo-login.zh.html#option-cargo-login---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-login--Z"><a class="option-anchor" href="commands/cargo-login.zh.html#option-cargo-login--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-25"><a class="header" href="#environment-25">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.html">the reference</a>有关Cargo读取的环境变量的详细信息。</p>
<h2 id="exit-status-25"><a class="header" href="#exit-status-25">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>：Cargo成功。</li>
<li><code>101</code>：Cargo未能完成。</li>
</ul>
<h2 id="examples-30"><a class="header" href="#examples-30">EXAMPLES</a></h2>
<ol>
<li>
<p>将API令牌保存到磁盘：</p>
<p>Cargo登录</p>
</li>
</ol>
<h2 id="see-also-28"><a class="header" href="#see-also-28">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a>, <a href="commands/cargo-publish.html">cargo-publish(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-owner1"><a class="header" href="#cargo-owner1">cargo-owner(1)</a></h1>
<h2 id="name-29"><a class="header" href="#name-29">NAME</a></h2>
<p>货主——管理登记处箱子的货主</p>
<h2 id="synopsis-29"><a class="header" href="#synopsis-29">SYNOPSIS</a></h2>
<p><code>cargo owner</code> [<em>options</em>] <code>--add</code> <em>登录</em> [<em>crate</em>]\ <code>cargo owner</code> [<em>options</em>] <code>--remove</code> <em>登录</em> [<em>crate</em>]\ <code>cargo owner</code> [<em>options</em>] <code>--list</code> [<em>crate</em>]</p>
<h2 id="description-29"><a class="header" href="#description-29">DESCRIPTION</a></h2>
<p>此命令将修改注册表中箱子的所有者。箱子的主人可以上传新版本，也可以拉旧版本。非团队所有者也可以修改所有者集，所以要小心！</p>
<p>此命令要求您通过<code>--token</code>选择或使用<a href="commands/cargo-login.html">cargo-login(1)</a>.</p>
<p>如果未指定箱子名称，它将使用当前目录中的包名称。</p>
<p>查看<a href="commands/../reference/publishing.html#cargo-owner">the reference</a>有关所有者和发布的更多信息。</p>
<h2 id="options-28"><a class="header" href="#options-28">OPTIONS</a></h2>
<h3 id="owner-options"><a class="header" href="#owner-options">Owner Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-owner--a"><a class="option-anchor" href="commands/cargo-owner.zh.html#option-cargo-owner--a"></a><code>-a</code></dt>
<dt class="option-term" id="option-cargo-owner---add"><a class="option-anchor" href="commands/cargo-owner.zh.html#option-cargo-owner---add"></a><code>--add</code> <em>login</em>...</dt>
<dd class="option-desc">Invite the given user or team as an owner.</dd>
<dt class="option-term" id="option-cargo-owner--r"><a class="option-anchor" href="commands/cargo-owner.zh.html#option-cargo-owner--r"></a><code>-r</code></dt>
<dt class="option-term" id="option-cargo-owner---remove"><a class="option-anchor" href="commands/cargo-owner.zh.html#option-cargo-owner---remove"></a><code>--remove</code> <em>login</em>...</dt>
<dd class="option-desc">Remove the given user or team as an owner.</dd>
<dt class="option-term" id="option-cargo-owner--l"><a class="option-anchor" href="commands/cargo-owner.zh.html#option-cargo-owner--l"></a><code>-l</code></dt>
<dt class="option-term" id="option-cargo-owner---list"><a class="option-anchor" href="commands/cargo-owner.zh.html#option-cargo-owner---list"></a><code>--list</code></dt>
<dd class="option-desc">List owners of a crate.</dd>
<dt class="option-term" id="option-cargo-owner---token"><a class="option-anchor" href="commands/cargo-owner.zh.html#option-cargo-owner---token"></a><code>--token</code> <em>token</em></dt>
<dd class="option-desc">API token to use when authenticating. This overrides the token stored in
the credentials file (which is created by <a href="commands/cargo-login.html">cargo-login(1)</a>).</p>
<p><a href="commands/../reference/config.html">Cargo config</a> environment variables can be
used to override the tokens stored in the credentials file. The token for
crates.io may be specified with the <code>CARGO_REGISTRY_TOKEN</code> environment
variable. Tokens for other registries may be specified with environment
variables of the form <code>CARGO_REGISTRIES_NAME_TOKEN</code> where <code>NAME</code> is the name
of the registry in all capital letters.</dd>
<dt class="option-term" id="option-cargo-owner---index"><a class="option-anchor" href="commands/cargo-owner.zh.html#option-cargo-owner---index"></a><code>--index</code> <em>index</em></dt>
<dd class="option-desc">The URL of the registry index to use.</dd>
<dt class="option-term" id="option-cargo-owner---registry"><a class="option-anchor" href="commands/cargo-owner.zh.html#option-cargo-owner---registry"></a><code>--registry</code> <em>registry</em></dt>
<dd class="option-desc">Name of the registry to use. Registry names are defined in <a href="commands/../reference/config.html">Cargo config
files</a>. If not specified, the default registry is used,
which is defined by the <code>registry.default</code> config key which defaults to
<code>crates-io</code>.</dd>
</dl>
<h3 id="display-options-26"><a class="header" href="#display-options-26">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-owner--v"><a class="option-anchor" href="commands/cargo-owner.zh.html#option-cargo-owner--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-owner---verbose"><a class="option-anchor" href="commands/cargo-owner.zh.html#option-cargo-owner---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-owner--q"><a class="option-anchor" href="commands/cargo-owner.zh.html#option-cargo-owner--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-owner---quiet"><a class="option-anchor" href="commands/cargo-owner.zh.html#option-cargo-owner---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-owner---color"><a class="option-anchor" href="commands/cargo-owner.zh.html#option-cargo-owner---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-26"><a class="header" href="#common-options-26">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-owner-+toolchain"><a class="option-anchor" href="commands/cargo-owner.zh.html#option-cargo-owner-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-owner--h"><a class="option-anchor" href="commands/cargo-owner.zh.html#option-cargo-owner--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-owner---help"><a class="option-anchor" href="commands/cargo-owner.zh.html#option-cargo-owner---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-owner--Z"><a class="option-anchor" href="commands/cargo-owner.zh.html#option-cargo-owner--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-26"><a class="header" href="#environment-26">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.html">the reference</a>有关Cargo读取的环境变量的详细信息。</p>
<h2 id="exit-status-26"><a class="header" href="#exit-status-26">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>：Cargo成功。</li>
<li><code>101</code>：Cargo未能完成。</li>
</ul>
<h2 id="examples-31"><a class="header" href="#examples-31">EXAMPLES</a></h2>
<ol>
<li>
<p>列出包的所有者：</p>
<p>货主——列富</p>
</li>
<li>
<p>邀请所有者加入一个包：</p>
<p>货主——添加用户名foo</p>
</li>
<li>
<p>从包中删除所有者：</p>
<p>货主——删除用户名foo</p>
</li>
</ol>
<h2 id="see-also-29"><a class="header" href="#see-also-29">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a>, <a href="commands/cargo-login.html">cargo-login(1)</a>, <a href="commands/cargo-publish.html">cargo-publish(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-package1"><a class="header" href="#cargo-package1">cargo-package(1)</a></h1>
<h2 id="name-30"><a class="header" href="#name-30">NAME</a></h2>
<p>Cargo包装-将本地包装组装成可分配的沥青球</p>
<h2 id="synopsis-30"><a class="header" href="#synopsis-30">SYNOPSIS</a></h2>
<p><code>cargo package</code> [<em>options</em>]</p>
<h2 id="description-30"><a class="header" href="#description-30">DESCRIPTION</a></h2>
<p>此命令将创建一个可分发的、压缩的<code>.crate</code>包含当前目录中包的源代码的文件。生成的文件将存储在<code>target/package</code>目录这将执行以下步骤：</p>
<ol>
<li>加载并检查当前工作区，执行一些基本检查。
<ul>
<li>除非具有版本密钥，否则不允许路径依赖关系。Cargo将忽略已发布包中依赖项的路径键。<code>dev-dependencies</code>没有这个限制。</li>
</ul>
</li>
<li>创建压缩的<code>.crate</code>文件
<ul>
<li>原著<code>Cargo.toml</code>文件被重写和规范化。</li>
<li><code>[patch]</code>, <code>[replace]</code>和<code>[workspace]</code>部分将从清单中删除。</li>
<li><code>Cargo.lock</code>如果包包含可执行二进制文件或示例目标，则会自动包含。<a href="commands/cargo-install.html">cargo-install(1)</a>如果<code>--locked</code>国旗被使用。</li>
<li>A.<code>.cargo_vcs_info.json</code>包含包含有关当前VCS签出哈希（如果可用）信息的文件（不包括在<code>--allow-dirty</code>).</li>
</ul>
</li>
<li>提取<code>.crate</code>归档并构建它，以验证它是否可以构建。
<ul>
<li>这将从头开始重建包，以确保它可以从原始状态构建。这个<code>--no-verify</code>标记可用于跳过此步骤。</li>
</ul>
</li>
<li>检查生成脚本是否未修改任何源文件。</li>
</ol>
<p>包含的文件列表可以通过<code>include</code>和<code>exclude</code>清单中的字段。</p>
<p>查看<a href="commands/../reference/publishing.html">the reference</a>有关打包和发布的更多详细信息。</p>
<h3 id="cargo_vcs_infojson-format"><a class="header" href="#cargo_vcs_infojson-format">.cargo_vcs_info.json format</a></h3>
<p>将产生<code>.cargo_vcs_info.json</code>按以下格式</p>
<pre><code class="language-javascript">{
 &quot;git&quot;: {
   &quot;sha1&quot;: &quot;aac20b6e7e543e6dd4118b246c77225e3a3a1302&quot;
 },
 &quot;path_in_vcs&quot;: &quot;&quot;
}
</code></pre>
<p><code>path_in_vcs</code>将设置为版本控制存储库子目录中的包的repo相对路径。</p>
<h2 id="options-29"><a class="header" href="#options-29">OPTIONS</a></h2>
<h3 id="package-options"><a class="header" href="#package-options">Package Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-package--l"><a class="option-anchor" href="commands/cargo-package.zh.html#option-cargo-package--l"></a><code>-l</code></dt>
<dt class="option-term" id="option-cargo-package---list"><a class="option-anchor" href="commands/cargo-package.zh.html#option-cargo-package---list"></a><code>--list</code></dt>
<dd class="option-desc">Print files included in a package without making one.</dd>
<dt class="option-term" id="option-cargo-package---no-verify"><a class="option-anchor" href="commands/cargo-package.zh.html#option-cargo-package---no-verify"></a><code>--no-verify</code></dt>
<dd class="option-desc">Don't verify the contents by building them.</dd>
<dt class="option-term" id="option-cargo-package---no-metadata"><a class="option-anchor" href="commands/cargo-package.zh.html#option-cargo-package---no-metadata"></a><code>--no-metadata</code></dt>
<dd class="option-desc">Ignore warnings about a lack of human-usable metadata (such as the description
or the license).</dd>
<dt class="option-term" id="option-cargo-package---allow-dirty"><a class="option-anchor" href="commands/cargo-package.zh.html#option-cargo-package---allow-dirty"></a><code>--allow-dirty</code></dt>
<dd class="option-desc">Allow working directories with uncommitted VCS changes to be packaged.</dd>
</dl>
<h3 id="package-selection-14"><a class="header" href="#package-selection-14">Package Selection</a></h3>
<p>默认情况下，如果未提供包选择选项，则选择的包取决于选择的清单文件（如果需要，则基于当前工作目录）<code>--manifest-path</code>未给出）。如果清单是工作区的根目录，则会选择工作区默认成员，否则只会选择清单定义的包。</p>
<p>可以使用<code>workspace.default-members</code>输入根清单。如果未设置，虚拟工作区将包括所有工作区成员（相当于传递）<code>--workspace</code>)，非虚拟工作区将只包括根箱子本身。</p>
<dl>
<dt class="option-term" id="option-cargo-package--p"><a class="option-anchor" href="commands/cargo-package.zh.html#option-cargo-package--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-package---package"><a class="option-anchor" href="commands/cargo-package.zh.html#option-cargo-package---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Package only the specified packages. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the
SPEC format. This flag may be specified multiple times and supports common Unix
glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell accidentally 
expanding glob patterns before Cargo handles them, you must use single quotes or
double quotes around each pattern.</dd>
<dt class="option-term" id="option-cargo-package---workspace"><a class="option-anchor" href="commands/cargo-package.zh.html#option-cargo-package---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">Package all members in the workspace.</dd>
<dt class="option-term" id="option-cargo-package---exclude"><a class="option-anchor" href="commands/cargo-package.zh.html#option-cargo-package---exclude"></a><code>--exclude</code> <em>SPEC</em>...</dt>
<dd class="option-desc">Exclude the specified packages. Must be used in conjunction with the
<code>--workspace</code> flag. This flag may be specified multiple times and supports
common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell
accidentally expanding glob patterns before Cargo handles them, you must use
single quotes or double quotes around each pattern.</dd>
</dl>
<h3 id="compilation-options-10"><a class="header" href="#compilation-options-10">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-package---target"><a class="option-anchor" href="commands/cargo-package.zh.html#option-cargo-package---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Package for the given architecture. The default is the host
architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>. Run <code>rustc --print target-list</code> for a
list of supported targets.</p>
<p>This may also be specified with the <code>build.target</code>
<a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../guide/build-cache.html">build cache</a> documentation for more details.</dd>
<dt class="option-term" id="option-cargo-package---target-dir"><a class="option-anchor" href="commands/cargo-package.zh.html#option-cargo-package---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</dd>
</dl>
<h3 id="feature-selection-12"><a class="header" href="#feature-selection-12">Feature Selection</a></h3>
<p>功能标志允许您控制启用哪些功能。如果未提供任何功能选项，则<code>default</code>为每个选定的软件包激活该功能。</p>
<p>查看<a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>更多细节。</p>
<dl>
<dt class="option-term" id="option-cargo-package---features"><a class="option-anchor" href="commands/cargo-package.zh.html#option-cargo-package---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</dd>
<dt class="option-term" id="option-cargo-package---all-features"><a class="option-anchor" href="commands/cargo-package.zh.html#option-cargo-package---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">Activate all available features of all selected packages.</dd>
<dt class="option-term" id="option-cargo-package---no-default-features"><a class="option-anchor" href="commands/cargo-package.zh.html#option-cargo-package---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">Do not activate the <code>default</code> feature of the selected packages.</dd>
</dl>
<h3 id="manifest-options-21"><a class="header" href="#manifest-options-21">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-package---manifest-path"><a class="option-anchor" href="commands/cargo-package.zh.html#option-cargo-package---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-package---frozen"><a class="option-anchor" href="commands/cargo-package.zh.html#option-cargo-package---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-package---locked"><a class="option-anchor" href="commands/cargo-package.zh.html#option-cargo-package---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-package---offline"><a class="option-anchor" href="commands/cargo-package.zh.html#option-cargo-package---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="miscellaneous-options-10"><a class="header" href="#miscellaneous-options-10">Miscellaneous Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-package--j"><a class="option-anchor" href="commands/cargo-package.zh.html#option-cargo-package--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-package---jobs"><a class="option-anchor" href="commands/cargo-package.zh.html#option-cargo-package---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of CPUs.</dd>
</dl>
<h3 id="display-options-27"><a class="header" href="#display-options-27">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-package--v"><a class="option-anchor" href="commands/cargo-package.zh.html#option-cargo-package--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-package---verbose"><a class="option-anchor" href="commands/cargo-package.zh.html#option-cargo-package---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-package--q"><a class="option-anchor" href="commands/cargo-package.zh.html#option-cargo-package--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-package---quiet"><a class="option-anchor" href="commands/cargo-package.zh.html#option-cargo-package---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-package---color"><a class="option-anchor" href="commands/cargo-package.zh.html#option-cargo-package---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-27"><a class="header" href="#common-options-27">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-package-+toolchain"><a class="option-anchor" href="commands/cargo-package.zh.html#option-cargo-package-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-package--h"><a class="option-anchor" href="commands/cargo-package.zh.html#option-cargo-package--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-package---help"><a class="option-anchor" href="commands/cargo-package.zh.html#option-cargo-package---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-package--Z"><a class="option-anchor" href="commands/cargo-package.zh.html#option-cargo-package--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-27"><a class="header" href="#environment-27">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.html">the reference</a>有关Cargo读取的环境变量的详细信息。</p>
<h2 id="exit-status-27"><a class="header" href="#exit-status-27">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>：Cargo成功。</li>
<li><code>101</code>：Cargo未能完成。</li>
</ul>
<h2 id="examples-32"><a class="header" href="#examples-32">EXAMPLES</a></h2>
<ol>
<li>
<p>创建一个压缩文件<code>.crate</code>当前包的文件：</p>
<p>Cargo包装</p>
</li>
</ol>
<h2 id="see-also-30"><a class="header" href="#see-also-30">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a>, <a href="commands/cargo-publish.html">cargo-publish(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-publish1"><a class="header" href="#cargo-publish1">cargo-publish(1)</a></h1>
<h2 id="name-31"><a class="header" href="#name-31">NAME</a></h2>
<p>Cargo发布-将包裹上载到注册表</p>
<h2 id="synopsis-31"><a class="header" href="#synopsis-31">SYNOPSIS</a></h2>
<p><code>cargo publish</code> [<em>options</em>]</p>
<h2 id="description-31"><a class="header" href="#description-31">DESCRIPTION</a></h2>
<p>此命令将创建一个可分发的、压缩的<code>.crate</code>将包的源代码保存在当前目录中，并将其上载到注册表。默认注册表是<a href="https://crates.io">https://crates.io</a>。这将执行以下步骤：</p>
<ol>
<li>执行一些检查，包括：
<ul>
<li>检查<code>package.publish</code>在清单中输入允许发布到哪些注册表的限制。</li>
</ul>
</li>
<li>创建一个<code>.crate</code>按照中的步骤进行归档<a href="commands/cargo-package.html">cargo-package(1)</a>.</li>
<li>将箱子上载到注册表。请注意，服务器将对箱子执行其他检查。</li>
</ol>
<p>此命令要求您通过<code>--token</code>选择或使用<a href="commands/cargo-login.html">cargo-login(1)</a>.</p>
<p>查看<a href="commands/../reference/publishing.html">the reference</a>有关打包和发布的更多详细信息。</p>
<h2 id="options-30"><a class="header" href="#options-30">OPTIONS</a></h2>
<h3 id="publish-options"><a class="header" href="#publish-options">Publish Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-publish---dry-run"><a class="option-anchor" href="commands/cargo-publish.zh.html#option-cargo-publish---dry-run"></a><code>--dry-run</code></dt>
<dd class="option-desc">Perform all checks without uploading.</dd>
<dt class="option-term" id="option-cargo-publish---token"><a class="option-anchor" href="commands/cargo-publish.zh.html#option-cargo-publish---token"></a><code>--token</code> <em>token</em></dt>
<dd class="option-desc">API token to use when authenticating. This overrides the token stored in
the credentials file (which is created by <a href="commands/cargo-login.html">cargo-login(1)</a>).</p>
<p><a href="commands/../reference/config.html">Cargo config</a> environment variables can be
used to override the tokens stored in the credentials file. The token for
crates.io may be specified with the <code>CARGO_REGISTRY_TOKEN</code> environment
variable. Tokens for other registries may be specified with environment
variables of the form <code>CARGO_REGISTRIES_NAME_TOKEN</code> where <code>NAME</code> is the name
of the registry in all capital letters.</dd>
<dt class="option-term" id="option-cargo-publish---no-verify"><a class="option-anchor" href="commands/cargo-publish.zh.html#option-cargo-publish---no-verify"></a><code>--no-verify</code></dt>
<dd class="option-desc">Don't verify the contents by building them.</dd>
<dt class="option-term" id="option-cargo-publish---allow-dirty"><a class="option-anchor" href="commands/cargo-publish.zh.html#option-cargo-publish---allow-dirty"></a><code>--allow-dirty</code></dt>
<dd class="option-desc">Allow working directories with uncommitted VCS changes to be packaged.</dd>
<dt class="option-term" id="option-cargo-publish---index"><a class="option-anchor" href="commands/cargo-publish.zh.html#option-cargo-publish---index"></a><code>--index</code> <em>index</em></dt>
<dd class="option-desc">The URL of the registry index to use.</dd>
<dt class="option-term" id="option-cargo-publish---registry"><a class="option-anchor" href="commands/cargo-publish.zh.html#option-cargo-publish---registry"></a><code>--registry</code> <em>registry</em></dt>
<dd class="option-desc">Name of the registry to publish to. Registry names are defined in <a href="commands/../reference/config.html">Cargo
config files</a>. If not specified, and there is a
<a href="commands/../reference/manifest.html#the-publish-field"><code>package.publish</code></a> field in
<code>Cargo.toml</code> with a single registry, then it will publish to that registry.
Otherwise it will use the default registry, which is defined by the
<a href="commands/../reference/config.html#registrydefault"><code>registry.default</code></a> config key
which defaults to <code>crates-io</code>.</dd>
</dl>
<h3 id="package-selection-15"><a class="header" href="#package-selection-15">Package Selection</a></h3>
<p>默认情况下，选择当前工作目录中的包。这个<code>-p</code>标志可用于在工作区中选择不同的包。</p>
<dl>
<dt class="option-term" id="option-cargo-publish--p"><a class="option-anchor" href="commands/cargo-publish.zh.html#option-cargo-publish--p"></a><code>-p</code> <em>spec</em></dt>
<dt class="option-term" id="option-cargo-publish---package"><a class="option-anchor" href="commands/cargo-publish.zh.html#option-cargo-publish---package"></a><code>--package</code> <em>spec</em></dt>
<dd class="option-desc">The package to publish. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the SPEC
format.</dd>
</dl>
<h3 id="compilation-options-11"><a class="header" href="#compilation-options-11">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-publish---target"><a class="option-anchor" href="commands/cargo-publish.zh.html#option-cargo-publish---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Publish for the given architecture. The default is the host
architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>. Run <code>rustc --print target-list</code> for a
list of supported targets.</p>
<p>This may also be specified with the <code>build.target</code>
<a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../guide/build-cache.html">build cache</a> documentation for more details.</dd>
<dt class="option-term" id="option-cargo-publish---target-dir"><a class="option-anchor" href="commands/cargo-publish.zh.html#option-cargo-publish---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</dd>
</dl>
<h3 id="feature-selection-13"><a class="header" href="#feature-selection-13">Feature Selection</a></h3>
<p>功能标志允许您控制启用哪些功能。如果未提供任何功能选项，则<code>default</code>为每个选定的软件包激活该功能。</p>
<p>查看<a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>更多细节。</p>
<dl>
<dt class="option-term" id="option-cargo-publish---features"><a class="option-anchor" href="commands/cargo-publish.zh.html#option-cargo-publish---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</dd>
<dt class="option-term" id="option-cargo-publish---all-features"><a class="option-anchor" href="commands/cargo-publish.zh.html#option-cargo-publish---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">Activate all available features of all selected packages.</dd>
<dt class="option-term" id="option-cargo-publish---no-default-features"><a class="option-anchor" href="commands/cargo-publish.zh.html#option-cargo-publish---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">Do not activate the <code>default</code> feature of the selected packages.</dd>
</dl>
<h3 id="manifest-options-22"><a class="header" href="#manifest-options-22">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-publish---manifest-path"><a class="option-anchor" href="commands/cargo-publish.zh.html#option-cargo-publish---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-publish---frozen"><a class="option-anchor" href="commands/cargo-publish.zh.html#option-cargo-publish---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-publish---locked"><a class="option-anchor" href="commands/cargo-publish.zh.html#option-cargo-publish---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-publish---offline"><a class="option-anchor" href="commands/cargo-publish.zh.html#option-cargo-publish---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="miscellaneous-options-11"><a class="header" href="#miscellaneous-options-11">Miscellaneous Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-publish--j"><a class="option-anchor" href="commands/cargo-publish.zh.html#option-cargo-publish--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-publish---jobs"><a class="option-anchor" href="commands/cargo-publish.zh.html#option-cargo-publish---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of CPUs.</dd>
</dl>
<h3 id="display-options-28"><a class="header" href="#display-options-28">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-publish--v"><a class="option-anchor" href="commands/cargo-publish.zh.html#option-cargo-publish--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-publish---verbose"><a class="option-anchor" href="commands/cargo-publish.zh.html#option-cargo-publish---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-publish--q"><a class="option-anchor" href="commands/cargo-publish.zh.html#option-cargo-publish--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-publish---quiet"><a class="option-anchor" href="commands/cargo-publish.zh.html#option-cargo-publish---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-publish---color"><a class="option-anchor" href="commands/cargo-publish.zh.html#option-cargo-publish---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-28"><a class="header" href="#common-options-28">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-publish-+toolchain"><a class="option-anchor" href="commands/cargo-publish.zh.html#option-cargo-publish-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-publish--h"><a class="option-anchor" href="commands/cargo-publish.zh.html#option-cargo-publish--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-publish---help"><a class="option-anchor" href="commands/cargo-publish.zh.html#option-cargo-publish---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-publish--Z"><a class="option-anchor" href="commands/cargo-publish.zh.html#option-cargo-publish--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-28"><a class="header" href="#environment-28">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.html">the reference</a>有关Cargo读取的环境变量的详细信息。</p>
<h2 id="exit-status-28"><a class="header" href="#exit-status-28">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>：Cargo成功。</li>
<li><code>101</code>：Cargo未能完成。</li>
</ul>
<h2 id="examples-33"><a class="header" href="#examples-33">EXAMPLES</a></h2>
<ol>
<li>
<p>发布当前包：</p>
<p>Cargo发布</p>
</li>
</ol>
<h2 id="see-also-31"><a class="header" href="#see-also-31">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a>, <a href="commands/cargo-package.html">cargo-package(1)</a>, <a href="commands/cargo-login.html">cargo-login(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-yank1"><a class="header" href="#cargo-yank1">cargo-yank(1)</a></h1>
<h2 id="name-32"><a class="header" href="#name-32">NAME</a></h2>
<p>Cargo猛拉-从索引中移除一个推动的箱子</p>
<h2 id="synopsis-32"><a class="header" href="#synopsis-32">SYNOPSIS</a></h2>
<p><code>cargo yank</code> [<em>options</em>] <code>--vers</code> <em>版本</em> [<em>crate</em>]</p>
<h2 id="description-32"><a class="header" href="#description-32">DESCRIPTION</a></h2>
<p>yank命令从服务器索引中删除以前发布的箱子版本。此命令不会删除任何数据，箱子仍可通过注册表的下载链接下载。</p>
<p>请注意，锁定到拉扯版本的现有箱子仍然可以下载拉扯版本以使用它。然而，Cargo将不允许任何新的箱子被锁定到任何被拉扯的版本。</p>
<p>此命令要求您通过<code>--token</code>选择或使用<a href="commands/cargo-login.html">cargo-login(1)</a>.</p>
<p>如果未指定箱子名称，它将使用当前目录中的包名称。</p>
<h2 id="options-31"><a class="header" href="#options-31">OPTIONS</a></h2>
<h3 id="yank-options"><a class="header" href="#yank-options">Yank Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-yank---vers"><a class="option-anchor" href="commands/cargo-yank.zh.html#option-cargo-yank---vers"></a><code>--vers</code> <em>version</em></dt>
<dd class="option-desc">The version to yank or un-yank.</dd>
<dt class="option-term" id="option-cargo-yank---undo"><a class="option-anchor" href="commands/cargo-yank.zh.html#option-cargo-yank---undo"></a><code>--undo</code></dt>
<dd class="option-desc">Undo a yank, putting a version back into the index.</dd>
<dt class="option-term" id="option-cargo-yank---token"><a class="option-anchor" href="commands/cargo-yank.zh.html#option-cargo-yank---token"></a><code>--token</code> <em>token</em></dt>
<dd class="option-desc">API token to use when authenticating. This overrides the token stored in
the credentials file (which is created by <a href="commands/cargo-login.html">cargo-login(1)</a>).</p>
<p><a href="commands/../reference/config.html">Cargo config</a> environment variables can be
used to override the tokens stored in the credentials file. The token for
crates.io may be specified with the <code>CARGO_REGISTRY_TOKEN</code> environment
variable. Tokens for other registries may be specified with environment
variables of the form <code>CARGO_REGISTRIES_NAME_TOKEN</code> where <code>NAME</code> is the name
of the registry in all capital letters.</dd>
<dt class="option-term" id="option-cargo-yank---index"><a class="option-anchor" href="commands/cargo-yank.zh.html#option-cargo-yank---index"></a><code>--index</code> <em>index</em></dt>
<dd class="option-desc">The URL of the registry index to use.</dd>
<dt class="option-term" id="option-cargo-yank---registry"><a class="option-anchor" href="commands/cargo-yank.zh.html#option-cargo-yank---registry"></a><code>--registry</code> <em>registry</em></dt>
<dd class="option-desc">Name of the registry to use. Registry names are defined in <a href="commands/../reference/config.html">Cargo config
files</a>. If not specified, the default registry is used,
which is defined by the <code>registry.default</code> config key which defaults to
<code>crates-io</code>.</dd>
</dl>
<h3 id="display-options-29"><a class="header" href="#display-options-29">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-yank--v"><a class="option-anchor" href="commands/cargo-yank.zh.html#option-cargo-yank--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-yank---verbose"><a class="option-anchor" href="commands/cargo-yank.zh.html#option-cargo-yank---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-yank--q"><a class="option-anchor" href="commands/cargo-yank.zh.html#option-cargo-yank--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-yank---quiet"><a class="option-anchor" href="commands/cargo-yank.zh.html#option-cargo-yank---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-yank---color"><a class="option-anchor" href="commands/cargo-yank.zh.html#option-cargo-yank---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-29"><a class="header" href="#common-options-29">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-yank-+toolchain"><a class="option-anchor" href="commands/cargo-yank.zh.html#option-cargo-yank-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-yank--h"><a class="option-anchor" href="commands/cargo-yank.zh.html#option-cargo-yank--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-yank---help"><a class="option-anchor" href="commands/cargo-yank.zh.html#option-cargo-yank---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-yank--Z"><a class="option-anchor" href="commands/cargo-yank.zh.html#option-cargo-yank--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-29"><a class="header" href="#environment-29">ENVIRONMENT</a></h2>
<p>查看<a href="commands/../reference/environment-variables.html">the reference</a>有关Cargo读取的环境变量的详细信息。</p>
<h2 id="exit-status-29"><a class="header" href="#exit-status-29">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>：Cargo成功。</li>
<li><code>101</code>：Cargo未能完成。</li>
</ul>
<h2 id="examples-34"><a class="header" href="#examples-34">EXAMPLES</a></h2>
<ol>
<li>
<p>从索引中拉出一个箱子：</p>
<p>cargo yank——1.0.7版foo</p>
</li>
</ol>
<h2 id="see-also-32"><a class="header" href="#see-also-32">SEE ALSO</a></h2>
<p><a href="commands/cargo.zh.html">cargo(1)</a>, <a href="commands/cargo-login.html">cargo-login(1)</a>, <a href="commands/cargo-publish.html">cargo-publish(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently Asked Questions</a></h2>
<p>常问问题</p>
<h3 id="is-the-plan-to-use-github-as-a-package-repository"><a class="header" href="#is-the-plan-to-use-github-as-a-package-repository">Is the plan to use GitHub as a package repository?</a></h3>
<blockquote>
<p>是否有计划，使用 Github 作为一个包库 ？</p>
</blockquote>
<p>不，Cargo 的计划是使用<a href="https://crates.io/">crates.io</a>，像 NPM 或 RuuGuMes 对应 npmjs.org 和 rubygems.org。</p>
<p>我们计划永远（通过些配置）支持 git 存储库作为包的来源，因为它们可以用于早期开发和临时补丁（加了点灵活性），即便人们使用主要使用注册表作为包的来源。</p>
<h3 id="why-build-cratesio-rather-than-use-github-as-a-registry"><a class="header" href="#why-build-cratesio-rather-than-use-github-as-a-registry">Why build crates.io rather than use GitHub as a registry?</a></h3>
<blockquote>
<p>为啥，选 crates.io，而不是使用 Github 作为 注册表 ？</p>
</blockquote>
<p>我们认为支持多种下载包的方式非常重要，包括从 GitHub 下载包，并将包复制到包本身.</p>
<p>也就是说，我们认为<a href="https://crates.io/">crates.io</a>提供了许多重要的好处，并且预计其会成为人们在 Cargo 中，下载包的主要方式。</p>
<p>前车之鉴，Node.js 的<a href="https://www.npmjs.org">npm</a>和 Ruby 的<a href="https://bundler.io">bundler</a>都支持中央注册中心模式，和基于 Git 的模式，而大多数包都是通过生态系统中的注册中心下载的，其中重要的少数包是使用基于 git 的包。</p>
<p>使中央注册中心，在其他语言中流行的一些优点包括:</p>
<ul>
<li><strong>可发现性</strong>. 中央注册表提供了查找现有包的简单方式。结合标记(版本)，这也使得注册中心能够提供生态系统的范围信息，例如最流行或最依赖的包的列表.</li>
<li><strong>速度</strong>. 中心注册中心使得可以快速有效地只获取包的元数据，然后只高效地下载已发布的包，而不会出现在存储库中的其他膨胀。这大大提高了依赖性解析和获取的速度。要知道随着依赖关系图的扩展，下载所有的 git 存储库会陷入困境。还要记住的是，并不是每个人都有高速、低延迟的互联网连接.</li>
</ul>
<h3 id="will-cargo-work-with-c-code-or-other-languages"><a class="header" href="#will-cargo-work-with-c-code-or-other-languages">Will Cargo work with C code (or other languages)?</a></h3>
<blockquote>
<p>Cargo 可与 C 语言代码(或其他语言)一起工作吗?</p>
</blockquote>
<p>可以的!</p>
<p>Cargo 处理编译 Rust 代码，但我们知道许多 Rust 包与 C 代码都有链接。我们还知道除 Rust 之外，在编译语言方面的工具，已建立了数十年。</p>
<p>我们的解决方案:Cargo 允许一个包可以<a href="./build-scripts.zh.html">指定脚本</a>(用 Rust 编写)，其在调用<code>rustc</code>之前运行。 利用 Rust 实现特定于平台的配置和重构包之间的常见构建功能。</p>
<h3 id="can-cargo-be-used-inside-of-make-or-ninja-or-"><a class="header" href="#can-cargo-be-used-inside-of-make-or-ninja-or-">Can Cargo be used inside of <code>make</code> (or <code>ninja</code>, or …)</a></h3>
<blockquote>
<p>Cargo 能被用在 <code>make</code>(或 <code>ninja</code>或…) 中吗 ?</p>
</blockquote>
<p>当然能。尽管我们希望， Cargo 是作为顶级编译 Rust 包的独立方式，但我们知道有些人希望从其他构建工具调用 Cargo。</p>
<p>我们已将 Cargo 设计成在这些环境中工作良好，并注意错误代码和机器可读输出模式等事项。在这些方面我们还有一些工作要做，但是在传统脚本上下文中使用 Cargo 是我们从一开始就设计的，并且将继续优先考虑。</p>
<h3 id="does-cargo-handle-multi-platform-packages-or-cross-compilation"><a class="header" href="#does-cargo-handle-multi-platform-packages-or-cross-compilation">Does Cargo handle multi-platform packages or cross-compilation?</a></h3>
<blockquote>
<p>Cargo 是怎么平衡 多平台或跨平台的包的？</p>
</blockquote>
<p>Rust 本身提供了基于平台，配置代码段的工具。Cargo 也支持<a href="reference/specifying-dependencies.html#platform-specific-dependencies">特定平台依赖关系</a>，未来，我们计划为每个平台<code>Cargo.toml</code>支持更多的配置.</p>
<p>从长远来看，我们正在寻找使用 Cargo 方便地跨编译包的方法.</p>
<h3 id="does-cargo-support-environments-like-production-or-test"><a class="header" href="#does-cargo-support-environments-like-production-or-test">Does Cargo support environments, like <code>production</code> or <code>test</code>?</a></h3>
<blockquote>
<p>Cargo 有没支持像<code>production</code> 或 <code>test</code>这样的环境？</p>
</blockquote>
<p>我们通过使用<a href="./manifest.zh.html#the-profile-sections">profiles</a>来支持这样的环境:</p>
<ul>
<li>特定环境标志(像 开发环境的 <code>-g --opt-level=0</code>和生产环境的<code>--opt-level=3</code>)。</li>
<li>特定环境依赖性(像 测试断言 的<code>hamcrest</code>).</li>
<li>特定环境变量 <code>#[cfg]</code></li>
<li>一个<code>cargo test</code>命令</li>
</ul>
<h3 id="does-cargo-work-on-windows"><a class="header" href="#does-cargo-work-on-windows">Does Cargo work on Windows?</a></h3>
<blockquote>
<p>Windows 系统 呢，Cargo 能搞吗？</p>
</blockquote>
<p>没问题!</p>
<p>所有提交的 Cargo 都需要通过 Windows 上的本地测试套件。但是，如果你发现一个 Windows 问题，我们认为它就是一个 bug，所以<a href="https://github.com/rust-lang/cargo/issues">请提出一个问题</a>.</p>
<h3 id="why-do-binaries-have-cargolock-in-version-control-but-not-libraries"><a class="header" href="#why-do-binaries-have-cargolock-in-version-control-but-not-libraries">Why do binaries have <code>Cargo.lock</code> in version control, but not libraries?</a></h3>
<blockquote>
<p>为啥，输出二进制的 Cargo 项目具有<code>Cargo.lock</code>，而单输出库的，就没有？</p>
</blockquote>
<p>一个<code>Cargo.lock</code>文件的目的，是在于成功构建，能描述’世界’的状态。然后，它就能用来，通过确保编译完全相同的依赖项，就能跨任何机器上构建确定性的包。</p>
<p>这个属性对于，处在依赖链末端的应用程序和包(二进制文件)是最理想的。因此，建议所有二进制文件都在其<code>Cargo.lock</code>内部进行检查.</p>
<p>对于单库来说，情况有些不同。库不仅被库开发人员使用，而且被库的任何下游消费者使用。依赖库的用户不会检查库的<code>Cargo.lock</code>(即使它存在)。正是如此，库<strong>不</strong>应该对库的所有用户进行确定性地重新编译。</p>
<p>如果一个库最终被多个依赖项传递使用，那么很可能只需要该库的一个副本(基于 semver 兼容性的版本)。如果 Cargo 使用了所有的 <strong>依赖项的<code>Cargo.lock</code>文件</strong>，那结果就是，使用库的多个副本，甚至可能存在版本冲突。</p>
<p>换句话说，库为它们的依赖项指定了 semver 版本，但是不用(无法)看到全部内容。只有像二进制文件这样的最终产品才需要有完整的图，来决定应该使用什么版本的依赖。</p>
<h3 id="can-libraries-use--as-a-version-for-their-dependencies"><a class="header" href="#can-libraries-use--as-a-version-for-their-dependencies">Can libraries use <code>*</code> as a version for their dependencies?</a></h3>
<blockquote>
<p>作为库的项目，可以使用<code>*</code>作为它们的依赖的版本号吗?</p>
</blockquote>
<p><strong>截至 2016 年 1 月 22 日，<a href="https://crates.io/">crates.io</a>拒绝通配符<code>*</code>依赖约束的所有包(不只是库).</strong></p>
<p>库是<em>可以</em>，但严格来说，他们不应该这样做。<code>*</code>版本要求，说明了“这将适用于任何版本“，而这永远不会是真的。库应该总是指定它们工作的范围，即使它和“每个 1.x.y 版本“一样。</p>
<h3 id="why-cargotoml"><a class="header" href="#why-cargotoml">Why <code>Cargo.toml</code>?</a></h3>
<p>作为与 Cargo 最频繁的交互之一，为什么要命名配置文件叫<code>Cargo.toml</code>的问题不时出现。选择领先的大写—<code>C</code>，是为了确保清单与目录清单中的其他类似配置文件组合排序。对文件进行排序时，通常将大写字母放在小写字母之前，确保<code>Makefile</code>和<code>Cargo.toml</code>文件会放在一起。选择<code>.toml</code>结尾是强调文件是<a href="https://github.com/toml-lang/toml">特定的配置文件格式</a>.</p>
<p>Cargo 不允许其他名称(如<code>cargo.toml</code>或<code>Cargofile</code>)，来强调如何如何容易识别 Cargo 仓库。在历史上，许多可能的名称选择都导致了混乱，其中一个选项被选择了，而其他选项就被自然而然地遗忘。</p>
<h3 id="how-can-cargo-work-offline"><a class="header" href="#how-can-cargo-work-offline">How can Cargo work offline?</a></h3>
<blockquote>
<p>Cargo 能 离线 工作吗？</p>
</blockquote>
<p>Cargo 通常用于网络访问有限，或没有网络访问的情况，如飞机、CI 环境或嵌入大型生产部署中。当 Cargo 试图从网络获取资源时，用户常常感到惊讶，因频繁出现 Cargo 离线工作的请求。</p>
<p>Cargo 的核心是不会试图访问网络，除非被告知这样做。也就是说，如果没有来自 crates.io、git 存储库或其他网络位置的箱，则 Cargo 永远不会尝试进行网络连接。因此，如果 Cargo 试图接触网络，那是因为它需要获取所需的资源。</p>
<p>Cargo 还非常积极地缓存信息，保持最小化的网络活动量。例如，它将保证<code>cargo build</code>(或类似的)运行到完成，那下一次<code>cargo build</code>保证不接触网络，只要<code>Cargo.toml</code>在此期间还没有被修改。网络的这种回避归结为，已存在<code>Cargo.lock</code>，和在 lock 文件中反映了，箱子的充分缓存。如果这些组件中的任何一个丢失，那么构建的成功就需要它们，并且必须远程获取它们。</p>
<p>对 Rust 1.11.0 打后的 Cargo ，可以看到新的(标志)参数<code>--frozen</code>，这是它不应该接触网络的断言。当传递给 Cargo，如果 Cargo 试图进行网络请求，它将立即返回一个错误。错误应该包括关于为什么进行网络请求(第一个地方），以帮助调试的上下文信息。注意这个标志是<em>不改变 Cargo 的行为</em>，它只是断言 Cargo 不应该触摸网络，这作为上一个命令已完成的保证，可以相同的网络活动是不必的。</p>
<blockquote>
<p>上一个命令，如<code>cargo build</code></p>
</blockquote>
<p>有关版本管理的详细信息，请参阅文档<a href="./source-replacement.zh.html">来源更换</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<ul>
<li>词汇表</li>
</ul>
<h3 id="artifact"><a class="header" href="#artifact">Artifact</a></h3>
<ul>
<li>工件</li>
</ul>
<p>一个<em>Artifact</em>是由编译过程创建的文件或文件集。这包括可链接库和可执行二进制文件.</p>
<h3 id="crate"><a class="header" href="#crate">Crate</a></h3>
<ul>
<li>箱 (包/库， 又一抽象名)</li>
</ul>
<p>包中的每个目标都是<em>箱</em>。Crates 是库或可执行二进制文件。它可能松散地引用目标的源代码或目标生成的编译工件。一个箱也可以指从注册表中提取的压缩包.</p>
<h3 id="edition"><a class="header" href="#edition">Edition</a></h3>
<ul>
<li>版本</li>
</ul>
<p>一个<em>Rust Edition</em>是 Rust 语言的开发里程碑。该<a href="appendix/../reference/manifest.zh.html#the-edition-field-optional">一个包的版本</a>在<code>Cargo.toml</code>清单中指定，各个目标可以指定它们使用的版本。见<a href="https://rust-lang-nursery.github.io/edition-guide/">版本指南</a>欲获得更多信息.</p>
<h3 id="feature"><a class="header" href="#feature">Feature</a></h3>
<ul>
<li>特性/特征/功能</li>
</ul>
<p>一个<a href="appendix/../reference/manifest.zh.html#the-features-section"><em>特征</em></a>是一个允许条件编译的命名标志参数。一个特性可以引用可选的依赖项，或者在 一个<code>Cargo.toml</code> 中定义的任意名称，可以键入(使用到)源代码中。</p>
<p>Cargo 有<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.zh.md"><em>不稳定的特征标志</em></a>，这可以用来实现 Cargo 本身的实验行为。Rust 编译器和 Rustdoc 也有自己的不稳定特征标志(参见<a href="https://doc.rust-lang.org/nightly/unstable-book/index.zh.md">不稳定的书</a>和<a href="https://doc.rust-lang.org/nightly/rustdoc/unstable-features.zh.md">Rustdoc 书</a>).</p>
<h3 id="index"><a class="header" href="#index">Index</a></h3>
<ul>
<li>索引是注册表中，可搜索的包的列表.</li>
</ul>
<h3 id="lock-file"><a class="header" href="#lock-file">Lock file</a></h3>
<ul>
<li>(锁定/锁) 文件</li>
</ul>
<p><code>Cargo.lock</code>，名:<em>锁定文件</em>，是一个文件，用于捕获工作空间或包中使用的每个依赖项的确切版本，它由 Cargo 自动生成。看到<a href="appendix/../cargo-toml-vs-cargo-lock.zh.html">Cargo.toml 与 Cargo.lock</a>.</p>
<h3 id="manifest"><a class="header" href="#manifest">Manifest</a></h3>
<ul>
<li>清单/元信息</li>
</ul>
<p>一个<a href="appendix/../reference/manifest.zh.html"><em>清单</em></a>是对包或工作空间的描述，名为<code>Cargo.toml</code>.</p>
<p>一个<a href="appendix/../reference/manifest.zh.html#virtual-manifest"><em>虚拟清单</em></a>是一个<code>Cargo.toml</code>，仅描述工作空间的文件，不包含包。</p>
<h3 id="member"><a class="header" href="#member">Member</a></h3>
<ul>
<li>会员/成员</li>
</ul>
<p>一个<em>成员</em>是属于工作空间的一个包.</p>
<h3 id="package"><a class="header" href="#package">Package</a></h3>
<ul>
<li>包</li>
</ul>
<p>一个<em>包</em>是源文件和描述包的清单<code>Cargo.toml</code>的集合。包具有名称和版本，用于指定包之间的依赖关系。包中包含多个目标，这些目标是库或可执行二进制文件。</p>
<p>该<em>包根</em>是<code>Cargo.toml</code>清单位于的包的目录。</p>
<p>该<a href="appendix/../reference/pkgid-spec.zh.html"><em>包 ID 规范</em></a>， 要么<em>SPEC</em>，是一个字符串，用于辨识从特定源，引用特定版本的包唯一性。</p>
<h3 id="project"><a class="header" href="#project">Project</a></h3>
<ul>
<li>包/项目</li>
</ul>
<p><a href="appendix/glossary.zh.html#package">package</a>的另一个名字.</p>
<h3 id="registry"><a class="header" href="#registry">Registry</a></h3>
<ul>
<li>注册表</li>
</ul>
<p>一个<em>注册处</em>是一种服务，包含可下载的包，可以安装或用作包的依赖项.默认注册表是<a href="https://crates.io">crates.io</a>。注册表有一个<em>索引</em>，其中包含所有包装箱的清单，并告诉 Cargo 如何下载所需的箱。</p>
<h3 id="source"><a class="header" href="#source">Source</a></h3>
<ul>
<li>源/资源</li>
</ul>
<p>一个<em>源</em>是一个提供程序，包含箱子，这些箱子可当依赖项的包。有几种源:</p>
<ul>
<li><strong>注册表来源</strong>- 见<a href="appendix/glossary.zh.html#registry">注册表</a>.</li>
<li><strong>本地注册表源</strong>- 在文件系统上存储为压缩文件的一组包。看到<a href="appendix/../reference/source-replacement.zh.html#local-registry-sources">本地注册表来源</a>.</li>
<li><strong>目录来源</strong>- 在文件系统上存储为未压缩文件的一组包.看到<a href="appendix/../reference/source-replacement.zh.html#directory-sources">目录来源</a>.</li>
<li><strong>路径来源</strong>- 位于文件系统上的单个包(例如<a href="appendix/../reference/specifying-dependencies.zh.html#specifying-path-dependencies">路径依赖</a>)或一组多个包(如<a href="appendix/../reference/specifying-dependencies.zh.html#overriding-with-local-dependencies">路径覆盖</a>).</li>
<li><strong>Git 来源</strong>- 位于 git 存储库中的包(例如<a href="appendix/../reference/specifying-dependencies.zh.html#specifying-dependencies-from-git-repositories">git 依赖</a>要么<a href="appendix/../reference/source-replacement.zh.html">git 来源</a>).</li>
</ul>
<p>看到<a href="appendix/../reference/source-replacement.zh.html">来源更换</a>欲获得更多信息.</p>
<h3 id="spec"><a class="header" href="#spec">Spec</a></h3>
<ul>
<li>看到<a href="appendix/glossary.zh.html#package">包 ID 规范</a>.</li>
</ul>
<h3 id="target"><a class="header" href="#target">Target</a></h3>
<ul>
<li>目标</li>
</ul>
<p><em>Target</em>这个词的意思，取决于具体情况:</p>
<ul>
<li><strong>Cargo 目标</strong> - Cargo 项目会有<em>target</em>，其具有对应将要生成的工件。项目可以包含库，二进制，示例，测试和基准目标。该<a href="appendix/../reference/manifest.zh.html#configuring-a-target">目标列表</a>配置在<code>Cargo.toml</code>清单，通常由源文件的<a href="appendix/../reference/manifest.zh.html#the-project-layout">目录布局</a>自动推断的。</li>
<li><strong>目标架构</strong>- 构建工件的 OS 和机器体系结构，通常称为一个<em>目标</em>。</li>
<li><strong>目标 三元(Triple)</strong>- 三元组是用于指定目标体系结构的特定格式。见<a href="http://clang.llvm.org/docs/CrossCompilation.zh.md#target-triple">clang 文档</a> 了解详情。三元组可以称为 一个<em>目标三元</em>，此为产生的工件的架构，以及<em>主机三元</em>，此为编译器运行的体系结构。可以使用<code>--target</code>命令行选项或<code>build.target</code> [配置选项]指定目标三元组。</li>
<li><strong>目标目录</strong>- Cargo 将所有构建的工件和中间文件放入<em>target</em>目录。默认情况下，这是一个名为<code>target</code>的目录会在工作区根目录，或者包根(如果不使用工作空间)。目录随着<code>--target-dir</code>命令行选项，<code>CARGO_TARGET_DIR</code> <a href="appendix/../reference/environment-variables.zh.html">环境变量</a>， 或者<code>build.target-dir</code>
<a href="appendix/../reference/config.zh.html">配置选项</a>改变而改变.</li>
</ul>
<blockquote>
<p>“target-triple (目标 三元)“ 是 编译器的 专用术语，用 “ cpu- vendor- os“ 来标识 交叉编译时的 系统类型</p>
</blockquote>
<h3 id="test-targets"><a class="header" href="#test-targets">Test Targets</a></h3>
<p>Cargo<em>测试目标</em>生成二进制文件，帮助验证代码的正确操作和正确性。有两种类型的测试工件:</p>
<ul>
<li><strong>单元测试</strong>- 一个<em>单元测试</em>是直接从库或二进制目标编译的可执行二进制文件。它包含库或二进制代码的全部内容，并运行<code>#[test]</code>注释函数，用于验证各个代码单元。</li>
<li><strong>集成测试目标</strong>- 一个<a href="appendix/../reference/manifest.zh.html#integration-tests"><em>集成测试目标</em></a>是一个来自<em>测试目标</em>的可执行的二进制文件，这是一个独特的箱子，其来源位于<code>tests</code>目录或由在<code>Cargo.toml</code>清单里面的<a href="appendix/../reference/manifest.zh.html#configuring-a-target"><code>[[test]]</code>表</a>指定。它旨在仅测试库的公共 API，或执行二进制文件以验证其操作。</li>
</ul>
<h3 id="workspace"><a class="header" href="#workspace">Workspace</a></h3>
<ul>
<li>工作区</li>
</ul>
<p>一个<a href="appendix/../reference/manifest.zh.html#the-workspace-section"><em>工作区</em></a>是一个共享公共依赖项解析(具有共享<code>Cargo.lock</code>)，输出目录和各种设置，如配置文件，的一个或多个包的集合。</p>
<p>一个<a href="appendix/../reference/manifest.zh.html#virtual-manifest"><em>虚拟工作区</em></a>是<code>Cargo.toml</code>清单根目录的工作空间， 没有定义包，只列出工作区成员。</p>
<p>该<em>工作区根</em>是工作区的<code>Cargo.toml</code>清单位于的目录.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git-authentication"><a class="header" href="#git-authentication">Git Authentication</a></h1>
<p>Cargo在使用git依赖项和注册表时支持某些形式的身份验证。本附录包含一些信息，用于以与Cargo兼容的方式设置git身份验证。</p>
<p>如果需要其他身份验证方法，则<a href="appendix/../reference/config.html#netgit-fetch-with-cli"><code>net.git-fetch-with-cli</code></a>配置值可以设置为使Cargo执行<code>git</code>用于处理获取远程存储库的可执行文件，而不是使用内置支持。这可以通过<code>CARGO_NET_GIT_FETCH_WITH_CLI=true</code>环境变量。</p>
<h2 id="https-authentication"><a class="header" href="#https-authentication">HTTPS authentication</a></h2>
<p>HTTPS身份验证需要<a href="https://git-scm.com/book/en/v2/Git-Tools-Credential-Storage"><code>credential.helper</code></a>机械装置有多个凭证帮助程序，您可以指定要在全局git配置文件中使用的凭证帮助程序。</p>
<pre><code class="language-ini"># ~/.gitconfig

[credential]
helper = store
</code></pre>
<p>Cargo不要求输入密码，因此对于大多数助手，在运行Cargo之前，您需要为助手提供初始用户名/密码。一种方法是跑步<code>git clone</code>输入用户名/密码。</p>
<blockquote>
<p><strong>提示：</strong><br>MACOS用户可能想考虑使用OXKEY链助手。<br>Windows用户可能想考虑使用<a href="https://github.com/microsoft/Git-Credential-Manager-Core/">GCM</a>帮手</p>
<p>**注：**Windows用户需要确保<code>sh</code>shell在您的<code>PATH</code>。这通常在Git for Windows安装中提供。</p>
</blockquote>
<h2 id="ssh-authentication"><a class="header" href="#ssh-authentication">SSH authentication</a></h2>
<p>SSH身份验证需要<code>ssh-agent</code>正在运行以获取SSH密钥。确保设置了适当的环境变量(<code>SSH_AUTH_SOCK</code>在大多数类似Unix的系统上），并且添加了正确的密钥（使用<code>ssh-add</code>).</p>
<p>Windows可以使用Pageant（部分功能）<a href="https://www.chiark.greenend.org.uk/%7Esgtatham/putty/">PuTTY</a>)或者<code>ssh-agent</code>.使用<code>ssh-agent</code>，Cargo需要使用作为Windows一部分分发的OpenSSH，因为Cargo不支持MinGW或Cygwin使用的模拟Unix域套接字。有关Windows安装的更多信息，请访问<a href="https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_install_firstuse">Microsoft
installation documentation</a>这一页<a href="https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_keymanagement">key management</a>有关于如何开始的说明<code>ssh-agent</code>以及添加密钥。</p>
<blockquote>
<p>**注：**Cargo不支持git的简写SSH URL，比如<code>git@example.com:user/repo.git</code>.使用完整的SSH URL，如<code>ssh://git@example.com/user/repo.git</code>.</p>
<p>**注：**SSH配置文件（如OpenSSH）<code>~/.ssh/config</code>)Cargo的内置SSH库不使用。应该使用更高级的需求<a href="appendix/../reference/config.html#netgit-fetch-with-cli"><code>net.git-fetch-with-cli</code></a>.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
